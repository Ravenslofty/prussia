#![doc = "Peripheral access API for PLAYSTATION2 microcontrollers (generated using svd2rust v0.36.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.36.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 0;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Generic peripheral accessor"]
    pub struct Periph<RB, const A: usize> {
        _marker: marker::PhantomData<RB>,
    }
    unsafe impl<RB, const A: usize> Send for Periph<RB, A> {}
    impl<RB, const A: usize> Periph<RB, A> {
        #[doc = "Pointer to the register block"]
        pub const PTR: *const RB = A as *const _;
        #[doc = "Return the pointer to the register block"]
        #[inline(always)]
        pub const fn ptr() -> *const RB {
            Self::PTR
        }
        #[doc = " Steal an instance of this peripheral"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Ensure that the new instance of the peripheral cannot be used in a way"]
        #[doc = " that may race with any existing instances, for example by only"]
        #[doc = " accessing read-only or write-only registers, or by consuming the"]
        #[doc = " original peripheral and using critical sections to coordinate"]
        #[doc = " access between multiple new instances."]
        #[doc = ""]
        #[doc = " Additionally, other software such as HALs may rely on only one"]
        #[doc = " peripheral instance existing to ensure memory safety; ensure"]
        #[doc = " no stolen instances are passed to such software."]
        pub unsafe fn steal() -> Self {
            Self {
                _marker: marker::PhantomData,
            }
        }
    }
    impl<RB, const A: usize> core::ops::Deref for Periph<RB, A> {
        type Target = RB;
        #[inline(always)]
        fn deref(&self) -> &Self::Target {
            unsafe { &*Self::PTR }
        }
    }
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " `0`"]
        const ZERO: Self;
        #[doc = " `1`"]
        const ONE: Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                const ZERO: Self = 0;
                const ONE: Self = 1;
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + core::fmt::Debug + PartialEq + From<Self>;
    }
    #[doc = " Marker for fields with fixed values"]
    pub trait IsEnum: FieldSpec {}
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Is it safe to write any bits to register"]
        type Safety;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = Self::Ux::ZERO;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = Self::Ux::ZERO;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux = Self::Ux::ZERO;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc(hidden)]
    pub mod raw {
        use super::{marker, BitM, FieldSpec, RegisterSpec, Unsafe, Writable};
        pub struct R<REG: RegisterSpec> {
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct W<REG: RegisterSpec> {
            #[doc = "Writable bits"]
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct FieldReader<FI = u8>
        where
            FI: FieldSpec,
        {
            pub(crate) bits: FI::Ux,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI: FieldSpec> FieldReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: FI::Ux) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct BitReader<FI = bool> {
            pub(crate) bits: bool,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI> BitReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: bool) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        #[must_use = "after creating `FieldWriter` you need to call field value setting method"]
        pub struct FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, Safety)>,
        }
        impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
        #[must_use = "after creating `BitWriter` you need to call bit setting method"]
        pub struct BitWriter<'a, REG, FI = bool, M = BitM>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, M)>,
        }
        impl<'a, REG, FI, M> BitWriter<'a, REG, FI, M>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub type R<REG> = raw::R<REG>;
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub const fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub type W<REG> = raw::W<REG>;
    impl<REG: Writable> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    impl<REG> W<REG>
    where
        REG: Writable<Safety = Safe>,
    {
        #[doc = " Writes raw bits to the register."]
        #[inline(always)]
        pub fn set(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = raw::FieldReader<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = raw::BitReader<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub const fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI: FieldSpec> core::fmt::Debug for FieldReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub const fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub const fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub const fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    impl<FI> core::fmt::Debug for BitReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    #[doc = " Marker for register/field writers which can take any value of specified width"]
    pub struct Safe;
    #[doc = " You should check that value is allowed to pass to register/field writer marked with this"]
    pub struct Unsafe;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct Range<const MIN: u64, const MAX: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeFrom<const MIN: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeTo<const MAX: u64>;
    #[doc = " Write field Proxy"]
    pub type FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe> =
        raw::FieldWriter<'a, REG, WI, FI, Safety>;
    impl<REG, const WI: u8, FI, Safety> FieldWriter<'_, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Field width"]
        #[inline(always)]
        pub const fn width(&self) -> u8 {
            WI
        }
        #[doc = " Field offset"]
        #[inline(always)]
        pub const fn offset(&self) -> u8 {
            self.o
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << self.o);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << self.o;
            self.w
        }
    }
    impl<'a, REG, const WI: u8, FI> FieldWriter<'a, REG, WI, FI, Safe>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64, const MAX: u64>
        FieldWriter<'a, REG, WI, FI, Range<MIN, MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN && value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64> FieldWriter<'a, REG, WI, FI, RangeFrom<MIN>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MAX: u64> FieldWriter<'a, REG, WI, FI, RangeTo<MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: IsEnum,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, FI = bool> = raw::BitWriter<'a, REG, FI, $mwv>;
            impl<'a, REG, FI> $writer<'a, REG, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
                #[doc = " Field width"]
                #[inline(always)]
                pub const fn width(&self) -> u8 {
                    Self::WIDTH
                }
                #[doc = " Field offset"]
                #[inline(always)]
                pub const fn offset(&self) -> u8 {
                    self.o
                }
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W<REG> {
                    self.w.bits &= !(REG::Ux::ONE << self.o);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::ONE) << self.o;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut W<REG> {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, FI> BitWriter<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<REG> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F) -> REG::Ux
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            let value = f(&mut W {
                bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                    | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            })
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Writes bits to a `Writable` register and produce a value."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| unsafe { w.bits(rawbits); });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits)"]
        #[doc = "         .field2().set_bit()"]
        #[doc = "         .field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[doc = ""]
        #[doc = " Values can be returned from the closure:"]
        #[doc = " ```ignore"]
        #[doc = " let state = periph.reg.write_and(|w| State::set(w.field1()));"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn from_write<F, T>(&self, f: F) -> T
        where
            F: FnOnce(&mut W<REG>) -> T,
        {
            let mut writer = W {
                bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                    | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            };
            let result = f(&mut writer);
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F) -> REG::Ux
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            let value = f(&mut W {
                bits: REG::Ux::ZERO,
                _reg: marker::PhantomData,
            })
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Writes 0 to a `Writable` register and produces a value."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn from_write_with_zero<F, T>(&self, f: F) -> T
        where
            F: FnOnce(&mut W<REG>) -> T,
        {
            let mut writer = W {
                bits: REG::Ux::ZERO,
                _reg: marker::PhantomData,
            };
            let result = f(&mut writer);
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F) -> REG::Ux
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            let value = f(
                &R {
                    bits,
                    _reg: marker::PhantomData,
                },
                &mut W {
                    bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                },
            )
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Modifies the contents of the register by reading and then writing it"]
        #[doc = " and produces a value."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.modify(|r, w| {"]
        #[doc = "     let new_bits = r.bits() | 3;"]
        #[doc = "     unsafe {"]
        #[doc = "         w.bits(new_bits);"]
        #[doc = "     }"]
        #[doc = ""]
        #[doc = "     new_bits"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits)"]
        #[doc = "         .field2().set_bit()"]
        #[doc = "         .field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn from_modify<F, T>(&self, f: F) -> T
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> T,
        {
            let bits = self.register.get();
            let mut writer = W {
                bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            };
            let result = f(
                &R {
                    bits,
                    _reg: marker::PhantomData,
                },
                &mut writer,
            );
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Readable> core::fmt::Debug for crate::generic::Reg<REG>
    where
        R<REG>: core::fmt::Debug,
    {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.read(), f)
        }
    }
}
#[doc = "Programmable Timers. See EE User's Manual, Chapter 4."]
pub type Timer = crate::Periph<timer::RegisterBlock, 0xb000_0000>;
impl core::fmt::Debug for Timer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer").finish()
    }
}
#[doc = "Programmable Timers. See EE User's Manual, Chapter 4."]
pub mod timer {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        t0_count: T0Count,
        _reserved1: [u8; 0x0c],
        t0_mode: T0Mode,
        _reserved2: [u8; 0x0c],
        t0_comp: T0Comp,
        _reserved3: [u8; 0x0c],
        t0_hold: T0Hold,
        _reserved4: [u8; 0x07cc],
        t1_count: T1Count,
        _reserved5: [u8; 0x0c],
        t1_mode: T1Mode,
        _reserved6: [u8; 0x0c],
        _reserved_6_t1_comp: [u8; 0x04],
        _reserved7: [u8; 0x0c],
        t1_hold: T1Hold,
        _reserved8: [u8; 0x07cc],
        t2_count: T2Count,
        _reserved9: [u8; 0x0c],
        t2_mode: T2Mode,
        _reserved10: [u8; 0x07ec],
        t3_count: T3Count,
        _reserved11: [u8; 0x0c],
        t3_mode: T3Mode,
        _reserved12: [u8; 0x0c],
        t3_comp: T3Comp,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Counter register"]
        #[inline(always)]
        pub const fn t0_count(&self) -> &T0Count {
            &self.t0_count
        }
        #[doc = "0x10 - Register for setting modes and reading status"]
        #[inline(always)]
        pub const fn t0_mode(&self) -> &T0Mode {
            &self.t0_mode
        }
        #[doc = "0x20 - Comparison register"]
        #[inline(always)]
        pub const fn t0_comp(&self) -> &T0Comp {
            &self.t0_comp
        }
        #[doc = "0x30 - Hold register"]
        #[inline(always)]
        pub const fn t0_hold(&self) -> &T0Hold {
            &self.t0_hold
        }
        #[doc = "0x800 - Counter register"]
        #[inline(always)]
        pub const fn t1_count(&self) -> &T1Count {
            &self.t1_count
        }
        #[doc = "0x810 - Register for setting modes and reading status"]
        #[inline(always)]
        pub const fn t1_mode(&self) -> &T1Mode {
            &self.t1_mode
        }
        #[doc = "0x820 - Comparison register"]
        #[inline(always)]
        pub const fn t2_comp(&self) -> &T2Comp {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(2080).cast() }
        }
        #[doc = "0x820 - Comparison register"]
        #[inline(always)]
        pub const fn t1_comp(&self) -> &T1Comp {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(2080).cast() }
        }
        #[doc = "0x830 - Hold register"]
        #[inline(always)]
        pub const fn t1_hold(&self) -> &T1Hold {
            &self.t1_hold
        }
        #[doc = "0x1000 - Counter register"]
        #[inline(always)]
        pub const fn t2_count(&self) -> &T2Count {
            &self.t2_count
        }
        #[doc = "0x1010 - Register for setting modes and reading status"]
        #[inline(always)]
        pub const fn t2_mode(&self) -> &T2Mode {
            &self.t2_mode
        }
        #[doc = "0x1800 - Counter register"]
        #[inline(always)]
        pub const fn t3_count(&self) -> &T3Count {
            &self.t3_count
        }
        #[doc = "0x1810 - Register for setting modes and reading status"]
        #[inline(always)]
        pub const fn t3_mode(&self) -> &T3Mode {
            &self.t3_mode
        }
        #[doc = "0x1820 - Comparison register"]
        #[inline(always)]
        pub const fn t3_comp(&self) -> &T3Comp {
            &self.t3_comp
        }
    }
    #[doc = "T0_COUNT (rw) register accessor: Counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`t0_count::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t0_count::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@t0_count`] module"]
    #[doc(alias = "T0_COUNT")]
    pub type T0Count = crate::Reg<t0_count::T0CountSpec>;
    #[doc = "Counter register"]
    pub mod t0_count {
        #[doc = "Register `T0_COUNT` reader"]
        pub type R = crate::R<T0CountSpec>;
        #[doc = "Register `T0_COUNT` writer"]
        pub type W = crate::W<T0CountSpec>;
        #[doc = "Field `COUNT` reader - Counter Value. The counter value is incremented according to the conditions of the clock and the gate signal specified in the Tn_MODE."]
        pub type CountR = crate::FieldReader<u16>;
        #[doc = "Field `COUNT` writer - Counter Value. The counter value is incremented according to the conditions of the clock and the gate signal specified in the Tn_MODE."]
        pub type CountW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Counter Value. The counter value is incremented according to the conditions of the clock and the gate signal specified in the Tn_MODE."]
            #[inline(always)]
            pub fn count(&self) -> CountR {
                CountR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Counter Value. The counter value is incremented according to the conditions of the clock and the gate signal specified in the Tn_MODE."]
            #[inline(always)]
            pub fn count(&mut self) -> CountW<T0CountSpec> {
                CountW::new(self, 0)
            }
        }
        #[doc = "Counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`t0_count::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t0_count::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct T0CountSpec;
        impl crate::RegisterSpec for T0CountSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t0_count::R`](R) reader structure"]
        impl crate::Readable for T0CountSpec {}
        #[doc = "`write(|w| ..)` method takes [`t0_count::W`](W) writer structure"]
        impl crate::Writable for T0CountSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets T0_COUNT to value 0"]
        impl crate::Resettable for T0CountSpec {}
    }
    #[doc = "T0_MODE (rw) register accessor: Register for setting modes and reading status\n\nYou can [`read`](crate::Reg::read) this register and get [`t0_mode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t0_mode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@t0_mode`] module"]
    #[doc(alias = "T0_MODE")]
    pub type T0Mode = crate::Reg<t0_mode::T0ModeSpec>;
    #[doc = "Register for setting modes and reading status"]
    pub mod t0_mode {
        #[doc = "Register `T0_MODE` reader"]
        pub type R = crate::R<T0ModeSpec>;
        #[doc = "Register `T0_MODE` writer"]
        pub type W = crate::W<T0ModeSpec>;
        #[doc = "Clock Selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Clks {
            #[doc = "0: BUSCLK (147.456MHz)"]
            Busclk = 0,
            #[doc = "1: 1/16 of the BUSCLK"]
            Busclk16 = 1,
            #[doc = "2: 1/256 of the BUSCLK"]
            Busclk256 = 2,
            #[doc = "3: External Clock (H-BLNK)"]
            Hblnk = 3,
        }
        impl From<Clks> for u8 {
            #[inline(always)]
            fn from(variant: Clks) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Clks {
            type Ux = u8;
        }
        impl crate::IsEnum for Clks {}
        #[doc = "Field `CLKS` reader - Clock Selection"]
        pub type ClksR = crate::FieldReader<Clks>;
        impl ClksR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Clks {
                match self.bits {
                    0 => Clks::Busclk,
                    1 => Clks::Busclk16,
                    2 => Clks::Busclk256,
                    3 => Clks::Hblnk,
                    _ => unreachable!(),
                }
            }
            #[doc = "BUSCLK (147.456MHz)"]
            #[inline(always)]
            pub fn is_busclk(&self) -> bool {
                *self == Clks::Busclk
            }
            #[doc = "1/16 of the BUSCLK"]
            #[inline(always)]
            pub fn is_busclk16(&self) -> bool {
                *self == Clks::Busclk16
            }
            #[doc = "1/256 of the BUSCLK"]
            #[inline(always)]
            pub fn is_busclk256(&self) -> bool {
                *self == Clks::Busclk256
            }
            #[doc = "External Clock (H-BLNK)"]
            #[inline(always)]
            pub fn is_hblnk(&self) -> bool {
                *self == Clks::Hblnk
            }
        }
        #[doc = "Field `CLKS` writer - Clock Selection"]
        pub type ClksW<'a, REG> = crate::FieldWriter<'a, REG, 2, Clks, crate::Safe>;
        impl<'a, REG> ClksW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "BUSCLK (147.456MHz)"]
            #[inline(always)]
            pub fn busclk(self) -> &'a mut crate::W<REG> {
                self.variant(Clks::Busclk)
            }
            #[doc = "1/16 of the BUSCLK"]
            #[inline(always)]
            pub fn busclk16(self) -> &'a mut crate::W<REG> {
                self.variant(Clks::Busclk16)
            }
            #[doc = "1/256 of the BUSCLK"]
            #[inline(always)]
            pub fn busclk256(self) -> &'a mut crate::W<REG> {
                self.variant(Clks::Busclk256)
            }
            #[doc = "External Clock (H-BLNK)"]
            #[inline(always)]
            pub fn hblnk(self) -> &'a mut crate::W<REG> {
                self.variant(Clks::Hblnk)
            }
        }
        #[doc = "Gate Function Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Gate {
            #[doc = "0: Gate function is not used."]
            Disabled = 0,
            #[doc = "1: Gate function is used."]
            Enabled = 1,
        }
        impl From<Gate> for bool {
            #[inline(always)]
            fn from(variant: Gate) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `GATE` reader - Gate Function Enable"]
        pub type GateR = crate::BitReader<Gate>;
        impl GateR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Gate {
                match self.bits {
                    false => Gate::Disabled,
                    true => Gate::Enabled,
                }
            }
            #[doc = "Gate function is not used."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Gate::Disabled
            }
            #[doc = "Gate function is used."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Gate::Enabled
            }
        }
        #[doc = "Field `GATE` writer - Gate Function Enable"]
        pub type GateW<'a, REG> = crate::BitWriter<'a, REG, Gate>;
        impl<'a, REG> GateW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Gate function is not used."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Gate::Disabled)
            }
            #[doc = "Gate function is used."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Gate::Enabled)
            }
        }
        #[doc = "Gate Selection\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Gats {
            #[doc = "0: H-BLNK (Disabled when CLKS equals to 11.)"]
            Hblnk = 0,
            #[doc = "1: V-BLNK"]
            Vblnk = 1,
        }
        impl From<Gats> for bool {
            #[inline(always)]
            fn from(variant: Gats) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `GATS` reader - Gate Selection"]
        pub type GatsR = crate::BitReader<Gats>;
        impl GatsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Gats {
                match self.bits {
                    false => Gats::Hblnk,
                    true => Gats::Vblnk,
                }
            }
            #[doc = "H-BLNK (Disabled when CLKS equals to 11.)"]
            #[inline(always)]
            pub fn is_hblnk(&self) -> bool {
                *self == Gats::Hblnk
            }
            #[doc = "V-BLNK"]
            #[inline(always)]
            pub fn is_vblnk(&self) -> bool {
                *self == Gats::Vblnk
            }
        }
        #[doc = "Field `GATS` writer - Gate Selection"]
        pub type GatsW<'a, REG> = crate::BitWriter<'a, REG, Gats>;
        impl<'a, REG> GatsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "H-BLNK (Disabled when CLKS equals to 11.)"]
            #[inline(always)]
            pub fn hblnk(self) -> &'a mut crate::W<REG> {
                self.variant(Gats::Hblnk)
            }
            #[doc = "V-BLNK"]
            #[inline(always)]
            pub fn vblnk(self) -> &'a mut crate::W<REG> {
                self.variant(Gats::Vblnk)
            }
        }
        #[doc = "Gate Mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Gatm {
            #[doc = "0: Counts while the gate signal is low."]
            Low = 0,
            #[doc = "1: Resets and starts counting at the gate signal's rising edge."]
            Rising = 1,
            #[doc = "2: Resets and starts counting at the gate signal's falling edge."]
            Falling = 2,
            #[doc = "3: Resets and starts counting at both edges of the gate signal."]
            Both = 3,
        }
        impl From<Gatm> for u8 {
            #[inline(always)]
            fn from(variant: Gatm) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Gatm {
            type Ux = u8;
        }
        impl crate::IsEnum for Gatm {}
        #[doc = "Field `GATM` reader - Gate Mode"]
        pub type GatmR = crate::FieldReader<Gatm>;
        impl GatmR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Gatm {
                match self.bits {
                    0 => Gatm::Low,
                    1 => Gatm::Rising,
                    2 => Gatm::Falling,
                    3 => Gatm::Both,
                    _ => unreachable!(),
                }
            }
            #[doc = "Counts while the gate signal is low."]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == Gatm::Low
            }
            #[doc = "Resets and starts counting at the gate signal's rising edge."]
            #[inline(always)]
            pub fn is_rising(&self) -> bool {
                *self == Gatm::Rising
            }
            #[doc = "Resets and starts counting at the gate signal's falling edge."]
            #[inline(always)]
            pub fn is_falling(&self) -> bool {
                *self == Gatm::Falling
            }
            #[doc = "Resets and starts counting at both edges of the gate signal."]
            #[inline(always)]
            pub fn is_both(&self) -> bool {
                *self == Gatm::Both
            }
        }
        #[doc = "Field `GATM` writer - Gate Mode"]
        pub type GatmW<'a, REG> = crate::FieldWriter<'a, REG, 2, Gatm, crate::Safe>;
        impl<'a, REG> GatmW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Counts while the gate signal is low."]
            #[inline(always)]
            pub fn low(self) -> &'a mut crate::W<REG> {
                self.variant(Gatm::Low)
            }
            #[doc = "Resets and starts counting at the gate signal's rising edge."]
            #[inline(always)]
            pub fn rising(self) -> &'a mut crate::W<REG> {
                self.variant(Gatm::Rising)
            }
            #[doc = "Resets and starts counting at the gate signal's falling edge."]
            #[inline(always)]
            pub fn falling(self) -> &'a mut crate::W<REG> {
                self.variant(Gatm::Falling)
            }
            #[doc = "Resets and starts counting at both edges of the gate signal."]
            #[inline(always)]
            pub fn both(self) -> &'a mut crate::W<REG> {
                self.variant(Gatm::Both)
            }
        }
        #[doc = "Zero Return\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Zret {
            #[doc = "0: The counter keeps counting, ignoring the reference value."]
            Disabled = 0,
            #[doc = "1: The counter is cleared to 0 when the counter value is equal to the reference value."]
            Enabled = 1,
        }
        impl From<Zret> for bool {
            #[inline(always)]
            fn from(variant: Zret) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ZRET` reader - Zero Return"]
        pub type ZretR = crate::BitReader<Zret>;
        impl ZretR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Zret {
                match self.bits {
                    false => Zret::Disabled,
                    true => Zret::Enabled,
                }
            }
            #[doc = "The counter keeps counting, ignoring the reference value."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Zret::Disabled
            }
            #[doc = "The counter is cleared to 0 when the counter value is equal to the reference value."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Zret::Enabled
            }
        }
        #[doc = "Field `ZRET` writer - Zero Return"]
        pub type ZretW<'a, REG> = crate::BitWriter<'a, REG, Zret>;
        impl<'a, REG> ZretW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "The counter keeps counting, ignoring the reference value."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Zret::Disabled)
            }
            #[doc = "The counter is cleared to 0 when the counter value is equal to the reference value."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Zret::Enabled)
            }
        }
        #[doc = "Count Up Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cue {
            #[doc = "0: Stops counting."]
            Disabled = 0,
            #[doc = "1: Starts/restarts counting."]
            Enabled = 1,
        }
        impl From<Cue> for bool {
            #[inline(always)]
            fn from(variant: Cue) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CUE` reader - Count Up Enable"]
        pub type CueR = crate::BitReader<Cue>;
        impl CueR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cue {
                match self.bits {
                    false => Cue::Disabled,
                    true => Cue::Enabled,
                }
            }
            #[doc = "Stops counting."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Cue::Disabled
            }
            #[doc = "Starts/restarts counting."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Cue::Enabled
            }
        }
        #[doc = "Field `CUE` writer - Count Up Enable"]
        pub type CueW<'a, REG> = crate::BitWriter<'a, REG, Cue>;
        impl<'a, REG> CueW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Stops counting."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cue::Disabled)
            }
            #[doc = "Starts/restarts counting."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cue::Enabled)
            }
        }
        #[doc = "Compare-Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cmpe {
            #[doc = "0: A compare-interrupt is not generated."]
            Disabled = 0,
            #[doc = "1: An interrupt is generated when the counter value is equal to the reference value."]
            Enabled = 1,
        }
        impl From<Cmpe> for bool {
            #[inline(always)]
            fn from(variant: Cmpe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CMPE` reader - Compare-Interrupt Enable"]
        pub type CmpeR = crate::BitReader<Cmpe>;
        impl CmpeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cmpe {
                match self.bits {
                    false => Cmpe::Disabled,
                    true => Cmpe::Enabled,
                }
            }
            #[doc = "A compare-interrupt is not generated."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Cmpe::Disabled
            }
            #[doc = "An interrupt is generated when the counter value is equal to the reference value."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Cmpe::Enabled
            }
        }
        #[doc = "Field `CMPE` writer - Compare-Interrupt Enable"]
        pub type CmpeW<'a, REG> = crate::BitWriter<'a, REG, Cmpe>;
        impl<'a, REG> CmpeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "A compare-interrupt is not generated."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cmpe::Disabled)
            }
            #[doc = "An interrupt is generated when the counter value is equal to the reference value."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Cmpe::Enabled)
            }
        }
        #[doc = "Overflow-Interrupt Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ovfe {
            #[doc = "0: An overflow interrupt is not generated."]
            Disabled = 0,
            #[doc = "1: An interrupt is generated when an overflow occurs."]
            Enabled = 1,
        }
        impl From<Ovfe> for bool {
            #[inline(always)]
            fn from(variant: Ovfe) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OVFE` reader - Overflow-Interrupt Enable"]
        pub type OvfeR = crate::BitReader<Ovfe>;
        impl OvfeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ovfe {
                match self.bits {
                    false => Ovfe::Disabled,
                    true => Ovfe::Enabled,
                }
            }
            #[doc = "An overflow interrupt is not generated."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ovfe::Disabled
            }
            #[doc = "An interrupt is generated when an overflow occurs."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ovfe::Enabled
            }
        }
        #[doc = "Field `OVFE` writer - Overflow-Interrupt Enable"]
        pub type OvfeW<'a, REG> = crate::BitWriter<'a, REG, Ovfe>;
        impl<'a, REG> OvfeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "An overflow interrupt is not generated."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ovfe::Disabled)
            }
            #[doc = "An interrupt is generated when an overflow occurs."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ovfe::Enabled)
            }
        }
        #[doc = "Equal Flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Equf {
            #[doc = "0: No compare-interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A compare-interrupt has occurred."]
            Set = 1,
        }
        impl From<Equf> for bool {
            #[inline(always)]
            fn from(variant: Equf) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EQUF` reader - Equal Flag"]
        pub type EqufR = crate::BitReader<Equf>;
        impl EqufR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Equf {
                match self.bits {
                    false => Equf::Clear,
                    true => Equf::Set,
                }
            }
            #[doc = "No compare-interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Equf::Clear
            }
            #[doc = "A compare-interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Equf::Set
            }
        }
        #[doc = "Field `EQUF` writer - Equal Flag"]
        pub type EqufW<'a, REG> = crate::BitWriter1C<'a, REG, Equf>;
        impl<'a, REG> EqufW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No compare-interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Equf::Clear)
            }
            #[doc = "A compare-interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Equf::Set)
            }
        }
        #[doc = "Overflow Flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ovff {
            #[doc = "0: No overflow-interrupt has occurred."]
            Clear = 0,
            #[doc = "1: An overflow-interrupt has occurred."]
            Set = 1,
        }
        impl From<Ovff> for bool {
            #[inline(always)]
            fn from(variant: Ovff) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OVFF` reader - Overflow Flag"]
        pub type OvffR = crate::BitReader<Ovff>;
        impl OvffR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ovff {
                match self.bits {
                    false => Ovff::Clear,
                    true => Ovff::Set,
                }
            }
            #[doc = "No overflow-interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Ovff::Clear
            }
            #[doc = "An overflow-interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Ovff::Set
            }
        }
        #[doc = "Field `OVFF` writer - Overflow Flag"]
        pub type OvffW<'a, REG> = crate::BitWriter1C<'a, REG, Ovff>;
        impl<'a, REG> OvffW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No overflow-interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Ovff::Clear)
            }
            #[doc = "An overflow-interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Ovff::Set)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Clock Selection"]
            #[inline(always)]
            pub fn clks(&self) -> ClksR {
                ClksR::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - Gate Function Enable"]
            #[inline(always)]
            pub fn gate(&self) -> GateR {
                GateR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Gate Selection"]
            #[inline(always)]
            pub fn gats(&self) -> GatsR {
                GatsR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - Gate Mode"]
            #[inline(always)]
            pub fn gatm(&self) -> GatmR {
                GatmR::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bit 6 - Zero Return"]
            #[inline(always)]
            pub fn zret(&self) -> ZretR {
                ZretR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Count Up Enable"]
            #[inline(always)]
            pub fn cue(&self) -> CueR {
                CueR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Compare-Interrupt Enable"]
            #[inline(always)]
            pub fn cmpe(&self) -> CmpeR {
                CmpeR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Overflow-Interrupt Enable"]
            #[inline(always)]
            pub fn ovfe(&self) -> OvfeR {
                OvfeR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Equal Flag"]
            #[inline(always)]
            pub fn equf(&self) -> EqufR {
                EqufR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Overflow Flag"]
            #[inline(always)]
            pub fn ovff(&self) -> OvffR {
                OvffR::new(((self.bits >> 11) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Clock Selection"]
            #[inline(always)]
            pub fn clks(&mut self) -> ClksW<T0ModeSpec> {
                ClksW::new(self, 0)
            }
            #[doc = "Bit 2 - Gate Function Enable"]
            #[inline(always)]
            pub fn gate(&mut self) -> GateW<T0ModeSpec> {
                GateW::new(self, 2)
            }
            #[doc = "Bit 3 - Gate Selection"]
            #[inline(always)]
            pub fn gats(&mut self) -> GatsW<T0ModeSpec> {
                GatsW::new(self, 3)
            }
            #[doc = "Bits 4:5 - Gate Mode"]
            #[inline(always)]
            pub fn gatm(&mut self) -> GatmW<T0ModeSpec> {
                GatmW::new(self, 4)
            }
            #[doc = "Bit 6 - Zero Return"]
            #[inline(always)]
            pub fn zret(&mut self) -> ZretW<T0ModeSpec> {
                ZretW::new(self, 6)
            }
            #[doc = "Bit 7 - Count Up Enable"]
            #[inline(always)]
            pub fn cue(&mut self) -> CueW<T0ModeSpec> {
                CueW::new(self, 7)
            }
            #[doc = "Bit 8 - Compare-Interrupt Enable"]
            #[inline(always)]
            pub fn cmpe(&mut self) -> CmpeW<T0ModeSpec> {
                CmpeW::new(self, 8)
            }
            #[doc = "Bit 9 - Overflow-Interrupt Enable"]
            #[inline(always)]
            pub fn ovfe(&mut self) -> OvfeW<T0ModeSpec> {
                OvfeW::new(self, 9)
            }
            #[doc = "Bit 10 - Equal Flag"]
            #[inline(always)]
            pub fn equf(&mut self) -> EqufW<T0ModeSpec> {
                EqufW::new(self, 10)
            }
            #[doc = "Bit 11 - Overflow Flag"]
            #[inline(always)]
            pub fn ovff(&mut self) -> OvffW<T0ModeSpec> {
                OvffW::new(self, 11)
            }
        }
        #[doc = "Register for setting modes and reading status\n\nYou can [`read`](crate::Reg::read) this register and get [`t0_mode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t0_mode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct T0ModeSpec;
        impl crate::RegisterSpec for T0ModeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t0_mode::R`](R) reader structure"]
        impl crate::Readable for T0ModeSpec {}
        #[doc = "`write(|w| ..)` method takes [`t0_mode::W`](W) writer structure"]
        impl crate::Writable for T0ModeSpec {
            type Safety = crate::Unsafe;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0x0c00;
        }
        #[doc = "`reset()` method sets T0_MODE to value 0"]
        impl crate::Resettable for T0ModeSpec {}
    }
    #[doc = "T0_COMP (rw) register accessor: Comparison register\n\nYou can [`read`](crate::Reg::read) this register and get [`t0_comp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t0_comp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@t0_comp`] module"]
    #[doc(alias = "T0_COMP")]
    pub type T0Comp = crate::Reg<t0_comp::T0CompSpec>;
    #[doc = "Comparison register"]
    pub mod t0_comp {
        #[doc = "Register `T0_COMP` reader"]
        pub type R = crate::R<T0CompSpec>;
        #[doc = "Register `T0_COMP` writer"]
        pub type W = crate::W<T0CompSpec>;
        #[doc = "Field `COMP` reader - Compare Value. Reference value to be compared with Tn_COUNT."]
        pub type CompR = crate::FieldReader<u16>;
        #[doc = "Field `COMP` writer - Compare Value. Reference value to be compared with Tn_COUNT."]
        pub type CompW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Compare Value. Reference value to be compared with Tn_COUNT."]
            #[inline(always)]
            pub fn comp(&self) -> CompR {
                CompR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Compare Value. Reference value to be compared with Tn_COUNT."]
            #[inline(always)]
            pub fn comp(&mut self) -> CompW<T0CompSpec> {
                CompW::new(self, 0)
            }
        }
        #[doc = "Comparison register\n\nYou can [`read`](crate::Reg::read) this register and get [`t0_comp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t0_comp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct T0CompSpec;
        impl crate::RegisterSpec for T0CompSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t0_comp::R`](R) reader structure"]
        impl crate::Readable for T0CompSpec {}
        #[doc = "`write(|w| ..)` method takes [`t0_comp::W`](W) writer structure"]
        impl crate::Writable for T0CompSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets T0_COMP to value 0"]
        impl crate::Resettable for T0CompSpec {}
    }
    #[doc = "T0_HOLD (rw) register accessor: Hold register\n\nYou can [`read`](crate::Reg::read) this register and get [`t0_hold::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t0_hold::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@t0_hold`] module"]
    #[doc(alias = "T0_HOLD")]
    pub type T0Hold = crate::Reg<t0_hold::T0HoldSpec>;
    #[doc = "Hold register"]
    pub mod t0_hold {
        #[doc = "Register `T0_HOLD` reader"]
        pub type R = crate::R<T0HoldSpec>;
        #[doc = "Register `T0_HOLD` writer"]
        pub type W = crate::W<T0HoldSpec>;
        #[doc = "Field `HOLD` reader - Hold Value. The value of Tn_COUNT is copied when an SBUS interrupt occurs."]
        pub type HoldR = crate::FieldReader<u16>;
        #[doc = "Field `HOLD` writer - Hold Value. The value of Tn_COUNT is copied when an SBUS interrupt occurs."]
        pub type HoldW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Hold Value. The value of Tn_COUNT is copied when an SBUS interrupt occurs."]
            #[inline(always)]
            pub fn hold(&self) -> HoldR {
                HoldR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Hold Value. The value of Tn_COUNT is copied when an SBUS interrupt occurs."]
            #[inline(always)]
            pub fn hold(&mut self) -> HoldW<T0HoldSpec> {
                HoldW::new(self, 0)
            }
        }
        #[doc = "Hold register\n\nYou can [`read`](crate::Reg::read) this register and get [`t0_hold::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`t0_hold::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct T0HoldSpec;
        impl crate::RegisterSpec for T0HoldSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`t0_hold::R`](R) reader structure"]
        impl crate::Readable for T0HoldSpec {}
        #[doc = "`write(|w| ..)` method takes [`t0_hold::W`](W) writer structure"]
        impl crate::Writable for T0HoldSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets T0_HOLD to value 0"]
        impl crate::Resettable for T0HoldSpec {}
    }
    pub use t0_comp as t1_comp;
    pub use t0_comp as t2_comp;
    pub use t0_comp as t3_comp;
    pub use t0_count as t1_count;
    pub use t0_count as t2_count;
    pub use t0_count as t3_count;
    pub use t0_hold as t1_hold;
    pub use t0_mode as t1_mode;
    pub use t0_mode as t2_mode;
    pub use t0_mode as t3_mode;
    pub use T0Comp as T1Comp;
    pub use T0Comp as T2Comp;
    pub use T0Comp as T3Comp;
    pub use T0Count as T1Count;
    pub use T0Count as T2Count;
    pub use T0Count as T3Count;
    pub use T0Hold as T1Hold;
    pub use T0Mode as T1Mode;
    pub use T0Mode as T2Mode;
    pub use T0Mode as T3Mode;
}
#[doc = "Image Data Processor. See EE User's Manual, Chapter 8."]
pub type Ipu = crate::Periph<ipu::RegisterBlock, 0xb000_2000>;
impl core::fmt::Debug for Ipu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ipu").finish()
    }
}
#[doc = "Image Data Processor. See EE User's Manual, Chapter 8."]
pub mod ipu {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ipu_cmd: IpuCmd,
        _reserved1: [u8; 0x08],
        ipu_ctrl: IpuCtrl,
        _reserved2: [u8; 0x0c],
        ipu_bp: IpuBp,
        _reserved3: [u8; 0x0c],
        ipu_top: IpuTop,
    }
    impl RegisterBlock {
        #[doc = "0x00..0x08 - IPU Decoded-code read register / command register"]
        #[inline(always)]
        pub const fn ipu_cmd(&self) -> &IpuCmd {
            &self.ipu_cmd
        }
        #[doc = "0x10 - IPU control"]
        #[inline(always)]
        pub const fn ipu_ctrl(&self) -> &IpuCtrl {
            &self.ipu_ctrl
        }
        #[doc = "0x20 - IPU input FIFO control."]
        #[inline(always)]
        pub const fn ipu_bp(&self) -> &IpuBp {
            &self.ipu_bp
        }
        #[doc = "0x30..0x38 - Reads the first 32 bits of the bit stream after execution of a BDEC / IDEC / VDEC / FDEC command completes."]
        #[inline(always)]
        pub const fn ipu_top(&self) -> &IpuTop {
            &self.ipu_top
        }
    }
    #[doc = "IPU_CMD (rw) register accessor: IPU Decoded-code read register / command register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipu_cmd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipu_cmd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipu_cmd`] module"]
    #[doc(alias = "IPU_CMD")]
    pub type IpuCmd = crate::Reg<ipu_cmd::IpuCmdSpec>;
    #[doc = "IPU Decoded-code read register / command register"]
    pub mod ipu_cmd {
        #[doc = "Register `IPU_CMD` reader"]
        pub type R = crate::R<IpuCmdSpec>;
        #[doc = "Register `IPU_CMD` writer"]
        pub type W = crate::W<IpuCmdSpec>;
        #[doc = "Field `OPTION` writer - Command Option. Contents differ depending on executed command."]
        pub type OptionW<'a, REG> = crate::FieldWriter<'a, REG, 28, u32>;
        #[doc = "Field `DATA` reader - VDEC / FDEC decoded value."]
        pub type DataR = crate::FieldReader<u32>;
        #[doc = "Field `CODE` writer - Command code."]
        pub type CodeW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "VDEC / FDEC command busy\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Busy {
            #[doc = "0: DATA field enabled (available to read.)"]
            Enable = 0,
            #[doc = "1: DATA field disabled (VDEC / FDEC still in execution.)"]
            Disable = 1,
        }
        impl From<Busy> for bool {
            #[inline(always)]
            fn from(variant: Busy) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BUSY` reader - VDEC / FDEC command busy"]
        pub type BusyR = crate::BitReader<Busy>;
        impl BusyR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Busy {
                match self.bits {
                    false => Busy::Enable,
                    true => Busy::Disable,
                }
            }
            #[doc = "DATA field enabled (available to read.)"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Busy::Enable
            }
            #[doc = "DATA field disabled (VDEC / FDEC still in execution.)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Busy::Disable
            }
        }
        impl R {
            #[doc = "Bits 0:31 - VDEC / FDEC decoded value."]
            #[inline(always)]
            pub fn data(&self) -> DataR {
                DataR::new((self.bits & 0xffff_ffff) as u32)
            }
            #[doc = "Bit 63 - VDEC / FDEC command busy"]
            #[inline(always)]
            pub fn busy(&self) -> BusyR {
                BusyR::new(((self.bits >> 63) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:27 - Command Option. Contents differ depending on executed command."]
            #[inline(always)]
            pub fn option(&mut self) -> OptionW<IpuCmdSpec> {
                OptionW::new(self, 0)
            }
            #[doc = "Bits 28:31 - Command code."]
            #[inline(always)]
            pub fn code(&mut self) -> CodeW<IpuCmdSpec> {
                CodeW::new(self, 28)
            }
        }
        #[doc = "IPU Decoded-code read register / command register\n\nYou can [`read`](crate::Reg::read) this register and get [`ipu_cmd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipu_cmd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IpuCmdSpec;
        impl crate::RegisterSpec for IpuCmdSpec {
            type Ux = u64;
        }
        #[doc = "`read()` method returns [`ipu_cmd::R`](R) reader structure"]
        impl crate::Readable for IpuCmdSpec {}
        #[doc = "`write(|w| ..)` method takes [`ipu_cmd::W`](W) writer structure"]
        impl crate::Writable for IpuCmdSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPU_CMD to value 0"]
        impl crate::Resettable for IpuCmdSpec {}
    }
    #[doc = "IPU_CTRL (rw) register accessor: IPU control\n\nYou can [`read`](crate::Reg::read) this register and get [`ipu_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipu_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipu_ctrl`] module"]
    #[doc(alias = "IPU_CTRL")]
    pub type IpuCtrl = crate::Reg<ipu_ctrl::IpuCtrlSpec>;
    #[doc = "IPU control"]
    pub mod ipu_ctrl {
        #[doc = "Register `IPU_CTRL` reader"]
        pub type R = crate::R<IpuCtrlSpec>;
        #[doc = "Register `IPU_CTRL` writer"]
        pub type W = crate::W<IpuCtrlSpec>;
        #[doc = "Field `IFC` reader - Input FIFO counter. Same as IPU_BP IFC field."]
        pub type IfcR = crate::FieldReader;
        #[doc = "Field `OFC` reader - Output FIFO counter."]
        pub type OfcR = crate::FieldReader;
        #[doc = "Field `CBP` reader - Coded block pattern."]
        pub type CbpR = crate::FieldReader;
        #[doc = "Error code detection. Set to 0 when a new command is issued, then set to 1 if an error is encountered.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ecd {
            #[doc = "0: Not detected."]
            NotDetected = 0,
            #[doc = "1: Detected."]
            Detected = 1,
        }
        impl From<Ecd> for bool {
            #[inline(always)]
            fn from(variant: Ecd) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ECD` reader - Error code detection. Set to 0 when a new command is issued, then set to 1 if an error is encountered."]
        pub type EcdR = crate::BitReader<Ecd>;
        impl EcdR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ecd {
                match self.bits {
                    false => Ecd::NotDetected,
                    true => Ecd::Detected,
                }
            }
            #[doc = "Not detected."]
            #[inline(always)]
            pub fn is_not_detected(&self) -> bool {
                *self == Ecd::NotDetected
            }
            #[doc = "Detected."]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == Ecd::Detected
            }
        }
        #[doc = "Start code detection. Set to 0 when a new command is issued, then set to 1 if a start code is encountered.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Scd {
            #[doc = "0: Not detected."]
            NotDetected = 0,
            #[doc = "1: Detected."]
            Detected = 1,
        }
        impl From<Scd> for bool {
            #[inline(always)]
            fn from(variant: Scd) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SCD` reader - Start code detection. Set to 0 when a new command is issued, then set to 1 if a start code is encountered."]
        pub type ScdR = crate::BitReader<Scd>;
        impl ScdR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Scd {
                match self.bits {
                    false => Scd::NotDetected,
                    true => Scd::Detected,
                }
            }
            #[doc = "Not detected."]
            #[inline(always)]
            pub fn is_not_detected(&self) -> bool {
                *self == Scd::NotDetected
            }
            #[doc = "Detected."]
            #[inline(always)]
            pub fn is_detected(&self) -> bool {
                *self == Scd::Detected
            }
        }
        #[doc = "Intra DC presition.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Idp {
            #[doc = "0: 8 bits."]
            Bits8 = 0,
            #[doc = "1: 9 bits."]
            Bits9 = 1,
            #[doc = "2: 10 bits."]
            Bits10 = 2,
        }
        impl From<Idp> for u8 {
            #[inline(always)]
            fn from(variant: Idp) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Idp {
            type Ux = u8;
        }
        impl crate::IsEnum for Idp {}
        #[doc = "Field `IDP` reader - Intra DC presition."]
        pub type IdpR = crate::FieldReader<Idp>;
        impl IdpR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Idp {
                match self.bits {
                    0 => Idp::Bits8,
                    1 => Idp::Bits9,
                    2 => Idp::Bits10,
                    _ => unreachable!(),
                }
            }
            #[doc = "8 bits."]
            #[inline(always)]
            pub fn is_bits8(&self) -> bool {
                *self == Idp::Bits8
            }
            #[doc = "9 bits."]
            #[inline(always)]
            pub fn is_bits9(&self) -> bool {
                *self == Idp::Bits9
            }
            #[doc = "10 bits."]
            #[inline(always)]
            pub fn is_bits10(&self) -> bool {
                *self == Idp::Bits10
            }
        }
        #[doc = "Field `IDP` writer - Intra DC presition."]
        pub type IdpW<'a, REG> = crate::FieldWriter<'a, REG, 2, Idp>;
        impl<'a, REG> IdpW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "8 bits."]
            #[inline(always)]
            pub fn bits8(self) -> &'a mut crate::W<REG> {
                self.variant(Idp::Bits8)
            }
            #[doc = "9 bits."]
            #[inline(always)]
            pub fn bits9(self) -> &'a mut crate::W<REG> {
                self.variant(Idp::Bits9)
            }
            #[doc = "10 bits."]
            #[inline(always)]
            pub fn bits10(self) -> &'a mut crate::W<REG> {
                self.variant(Idp::Bits10)
            }
        }
        #[doc = "Alternate scan.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum As {
            #[doc = "0: Zigzag scanning."]
            Zigzag = 0,
            #[doc = "1: Alternate scanning."]
            Alternate = 1,
        }
        impl From<As> for bool {
            #[inline(always)]
            fn from(variant: As) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `AS` reader - Alternate scan."]
        pub type AsR = crate::BitReader<As>;
        impl AsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> As {
                match self.bits {
                    false => As::Zigzag,
                    true => As::Alternate,
                }
            }
            #[doc = "Zigzag scanning."]
            #[inline(always)]
            pub fn is_zigzag(&self) -> bool {
                *self == As::Zigzag
            }
            #[doc = "Alternate scanning."]
            #[inline(always)]
            pub fn is_alternate(&self) -> bool {
                *self == As::Alternate
            }
        }
        #[doc = "Field `AS` writer - Alternate scan."]
        pub type AsW<'a, REG> = crate::BitWriter<'a, REG, As>;
        impl<'a, REG> AsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Zigzag scanning."]
            #[inline(always)]
            pub fn zigzag(self) -> &'a mut crate::W<REG> {
                self.variant(As::Zigzag)
            }
            #[doc = "Alternate scanning."]
            #[inline(always)]
            pub fn alternate(self) -> &'a mut crate::W<REG> {
                self.variant(As::Alternate)
            }
        }
        #[doc = "Intra VLC format.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ivf {
            #[doc = "0: MPEG1-compatible 2-dimensional VLC table."]
            Mpeg1Compatible = 0,
            #[doc = "1: 2-dimensional VLC table specially for intra macro block."]
            IntraMacroBlock = 1,
        }
        impl From<Ivf> for bool {
            #[inline(always)]
            fn from(variant: Ivf) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IVF` reader - Intra VLC format."]
        pub type IvfR = crate::BitReader<Ivf>;
        impl IvfR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ivf {
                match self.bits {
                    false => Ivf::Mpeg1Compatible,
                    true => Ivf::IntraMacroBlock,
                }
            }
            #[doc = "MPEG1-compatible 2-dimensional VLC table."]
            #[inline(always)]
            pub fn is_mpeg1_compatible(&self) -> bool {
                *self == Ivf::Mpeg1Compatible
            }
            #[doc = "2-dimensional VLC table specially for intra macro block."]
            #[inline(always)]
            pub fn is_intra_macro_block(&self) -> bool {
                *self == Ivf::IntraMacroBlock
            }
        }
        #[doc = "Field `IVF` writer - Intra VLC format."]
        pub type IvfW<'a, REG> = crate::BitWriter<'a, REG, Ivf>;
        impl<'a, REG> IvfW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "MPEG1-compatible 2-dimensional VLC table."]
            #[inline(always)]
            pub fn mpeg1_compatible(self) -> &'a mut crate::W<REG> {
                self.variant(Ivf::Mpeg1Compatible)
            }
            #[doc = "2-dimensional VLC table specially for intra macro block."]
            #[inline(always)]
            pub fn intra_macro_block(self) -> &'a mut crate::W<REG> {
                self.variant(Ivf::IntraMacroBlock)
            }
        }
        #[doc = "Q scale step.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Qst {
            #[doc = "0: Linear step."]
            Linear = 0,
            #[doc = "1: Non-linear step."]
            NonLinear = 1,
        }
        impl From<Qst> for bool {
            #[inline(always)]
            fn from(variant: Qst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `QST` reader - Q scale step."]
        pub type QstR = crate::BitReader<Qst>;
        impl QstR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Qst {
                match self.bits {
                    false => Qst::Linear,
                    true => Qst::NonLinear,
                }
            }
            #[doc = "Linear step."]
            #[inline(always)]
            pub fn is_linear(&self) -> bool {
                *self == Qst::Linear
            }
            #[doc = "Non-linear step."]
            #[inline(always)]
            pub fn is_non_linear(&self) -> bool {
                *self == Qst::NonLinear
            }
        }
        #[doc = "Field `QST` writer - Q scale step."]
        pub type QstW<'a, REG> = crate::BitWriter<'a, REG, Qst>;
        impl<'a, REG> QstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Linear step."]
            #[inline(always)]
            pub fn linear(self) -> &'a mut crate::W<REG> {
                self.variant(Qst::Linear)
            }
            #[doc = "Non-linear step."]
            #[inline(always)]
            pub fn non_linear(self) -> &'a mut crate::W<REG> {
                self.variant(Qst::NonLinear)
            }
        }
        #[doc = "Bit stream MPEG version.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Mp1 {
            #[doc = "0: MPEG2 bit stream."]
            Mpeg2 = 0,
            #[doc = "1: MPEG1 bit stream."]
            Mpeg1 = 1,
        }
        impl From<Mp1> for bool {
            #[inline(always)]
            fn from(variant: Mp1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MP1` reader - Bit stream MPEG version."]
        pub type Mp1R = crate::BitReader<Mp1>;
        impl Mp1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Mp1 {
                match self.bits {
                    false => Mp1::Mpeg2,
                    true => Mp1::Mpeg1,
                }
            }
            #[doc = "MPEG2 bit stream."]
            #[inline(always)]
            pub fn is_mpeg2(&self) -> bool {
                *self == Mp1::Mpeg2
            }
            #[doc = "MPEG1 bit stream."]
            #[inline(always)]
            pub fn is_mpeg1(&self) -> bool {
                *self == Mp1::Mpeg1
            }
        }
        #[doc = "Field `MP1` writer - Bit stream MPEG version."]
        pub type Mp1W<'a, REG> = crate::BitWriter<'a, REG, Mp1>;
        impl<'a, REG> Mp1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "MPEG2 bit stream."]
            #[inline(always)]
            pub fn mpeg2(self) -> &'a mut crate::W<REG> {
                self.variant(Mp1::Mpeg2)
            }
            #[doc = "MPEG1 bit stream."]
            #[inline(always)]
            pub fn mpeg1(self) -> &'a mut crate::W<REG> {
                self.variant(Mp1::Mpeg1)
            }
        }
        #[doc = "Picture type.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Pct {
            #[doc = "1: I-PICTURE."]
            IPicture = 1,
            #[doc = "2: P-PICTURE."]
            PPicture = 2,
            #[doc = "3: B-PICTURE."]
            BPicture = 3,
            #[doc = "4: D-PICTURE."]
            DPicture = 4,
        }
        impl From<Pct> for u8 {
            #[inline(always)]
            fn from(variant: Pct) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Pct {
            type Ux = u8;
        }
        impl crate::IsEnum for Pct {}
        #[doc = "Field `PCT` reader - Picture type."]
        pub type PctR = crate::FieldReader<Pct>;
        impl PctR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Pct> {
                match self.bits {
                    1 => Some(Pct::IPicture),
                    2 => Some(Pct::PPicture),
                    3 => Some(Pct::BPicture),
                    4 => Some(Pct::DPicture),
                    _ => None,
                }
            }
            #[doc = "I-PICTURE."]
            #[inline(always)]
            pub fn is_i_picture(&self) -> bool {
                *self == Pct::IPicture
            }
            #[doc = "P-PICTURE."]
            #[inline(always)]
            pub fn is_p_picture(&self) -> bool {
                *self == Pct::PPicture
            }
            #[doc = "B-PICTURE."]
            #[inline(always)]
            pub fn is_b_picture(&self) -> bool {
                *self == Pct::BPicture
            }
            #[doc = "D-PICTURE."]
            #[inline(always)]
            pub fn is_d_picture(&self) -> bool {
                *self == Pct::DPicture
            }
        }
        #[doc = "Field `PCT` writer - Picture type."]
        pub type PctW<'a, REG> = crate::FieldWriter<'a, REG, 3, Pct>;
        impl<'a, REG> PctW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "I-PICTURE."]
            #[inline(always)]
            pub fn i_picture(self) -> &'a mut crate::W<REG> {
                self.variant(Pct::IPicture)
            }
            #[doc = "P-PICTURE."]
            #[inline(always)]
            pub fn p_picture(self) -> &'a mut crate::W<REG> {
                self.variant(Pct::PPicture)
            }
            #[doc = "B-PICTURE."]
            #[inline(always)]
            pub fn b_picture(self) -> &'a mut crate::W<REG> {
                self.variant(Pct::BPicture)
            }
            #[doc = "D-PICTURE."]
            #[inline(always)]
            pub fn d_picture(self) -> &'a mut crate::W<REG> {
                self.variant(Pct::DPicture)
            }
        }
        #[doc = "Reset. Writing 1 will force-abandon the current command and data, and reset the IPU.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Rst {
            #[doc = "1: Trigger Reset."]
            Reset = 1,
        }
        impl From<Rst> for bool {
            #[inline(always)]
            fn from(variant: Rst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RST` writer - Reset. Writing 1 will force-abandon the current command and data, and reset the IPU."]
        pub type RstW<'a, REG> = crate::BitWriter<'a, REG, Rst>;
        impl<'a, REG> RstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Trigger Reset."]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(Rst::Reset)
            }
        }
        #[doc = "IPU BUSY status.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Busy {
            #[doc = "0: IPU ready (idle)."]
            Ready = 0,
            #[doc = "1: IPU busy (executing a command.)"]
            Busy = 1,
        }
        impl From<Busy> for bool {
            #[inline(always)]
            fn from(variant: Busy) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BUSY` reader - IPU BUSY status."]
        pub type BusyR = crate::BitReader<Busy>;
        impl BusyR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Busy {
                match self.bits {
                    false => Busy::Ready,
                    true => Busy::Busy,
                }
            }
            #[doc = "IPU ready (idle)."]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == Busy::Ready
            }
            #[doc = "IPU busy (executing a command.)"]
            #[inline(always)]
            pub fn is_busy(&self) -> bool {
                *self == Busy::Busy
            }
        }
        impl R {
            #[doc = "Bits 0:3 - Input FIFO counter. Same as IPU_BP IFC field."]
            #[inline(always)]
            pub fn ifc(&self) -> IfcR {
                IfcR::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Output FIFO counter."]
            #[inline(always)]
            pub fn ofc(&self) -> OfcR {
                OfcR::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:13 - Coded block pattern."]
            #[inline(always)]
            pub fn cbp(&self) -> CbpR {
                CbpR::new(((self.bits >> 8) & 0x3f) as u8)
            }
            #[doc = "Bit 14 - Error code detection. Set to 0 when a new command is issued, then set to 1 if an error is encountered."]
            #[inline(always)]
            pub fn ecd(&self) -> EcdR {
                EcdR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Start code detection. Set to 0 when a new command is issued, then set to 1 if a start code is encountered."]
            #[inline(always)]
            pub fn scd(&self) -> ScdR {
                ScdR::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bits 16:17 - Intra DC presition."]
            #[inline(always)]
            pub fn idp(&self) -> IdpR {
                IdpR::new(((self.bits >> 16) & 3) as u8)
            }
            #[doc = "Bit 20 - Alternate scan."]
            #[inline(always)]
            pub fn as_(&self) -> AsR {
                AsR::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Intra VLC format."]
            #[inline(always)]
            pub fn ivf(&self) -> IvfR {
                IvfR::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Q scale step."]
            #[inline(always)]
            pub fn qst(&self) -> QstR {
                QstR::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Bit stream MPEG version."]
            #[inline(always)]
            pub fn mp1(&self) -> Mp1R {
                Mp1R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bits 24:26 - Picture type."]
            #[inline(always)]
            pub fn pct(&self) -> PctR {
                PctR::new(((self.bits >> 24) & 7) as u8)
            }
            #[doc = "Bit 31 - IPU BUSY status."]
            #[inline(always)]
            pub fn busy(&self) -> BusyR {
                BusyR::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 16:17 - Intra DC presition."]
            #[inline(always)]
            pub fn idp(&mut self) -> IdpW<IpuCtrlSpec> {
                IdpW::new(self, 16)
            }
            #[doc = "Bit 20 - Alternate scan."]
            #[inline(always)]
            pub fn as_(&mut self) -> AsW<IpuCtrlSpec> {
                AsW::new(self, 20)
            }
            #[doc = "Bit 21 - Intra VLC format."]
            #[inline(always)]
            pub fn ivf(&mut self) -> IvfW<IpuCtrlSpec> {
                IvfW::new(self, 21)
            }
            #[doc = "Bit 22 - Q scale step."]
            #[inline(always)]
            pub fn qst(&mut self) -> QstW<IpuCtrlSpec> {
                QstW::new(self, 22)
            }
            #[doc = "Bit 23 - Bit stream MPEG version."]
            #[inline(always)]
            pub fn mp1(&mut self) -> Mp1W<IpuCtrlSpec> {
                Mp1W::new(self, 23)
            }
            #[doc = "Bits 24:26 - Picture type."]
            #[inline(always)]
            pub fn pct(&mut self) -> PctW<IpuCtrlSpec> {
                PctW::new(self, 24)
            }
            #[doc = "Bit 30 - Reset. Writing 1 will force-abandon the current command and data, and reset the IPU."]
            #[inline(always)]
            pub fn rst(&mut self) -> RstW<IpuCtrlSpec> {
                RstW::new(self, 30)
            }
        }
        #[doc = "IPU control\n\nYou can [`read`](crate::Reg::read) this register and get [`ipu_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipu_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IpuCtrlSpec;
        impl crate::RegisterSpec for IpuCtrlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ipu_ctrl::R`](R) reader structure"]
        impl crate::Readable for IpuCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`ipu_ctrl::W`](W) writer structure"]
        impl crate::Writable for IpuCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPU_CTRL to value 0"]
        impl crate::Resettable for IpuCtrlSpec {}
    }
    #[doc = "IPU_BP (r) register accessor: IPU input FIFO control.\n\nYou can [`read`](crate::Reg::read) this register and get [`ipu_bp::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipu_bp`] module"]
    #[doc(alias = "IPU_BP")]
    pub type IpuBp = crate::Reg<ipu_bp::IpuBpSpec>;
    #[doc = "IPU input FIFO control."]
    pub mod ipu_bp {
        #[doc = "Register `IPU_BP` reader"]
        pub type R = crate::R<IpuBpSpec>;
        #[doc = "Field `BP` reader - Bit stream pointer to bit position in first 128-bit data to start decoding."]
        pub type BpR = crate::FieldReader;
        #[doc = "Field `IFC` reader - Input FIFO counter. Equal to number of qwords in IPU_in_FIFO."]
        pub type IfcR = crate::FieldReader;
        #[doc = "Field `FP` reader - FIFO pointer. Equal to number of qwords remaining in IPU except IPU_in_FIFO."]
        pub type FpR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:6 - Bit stream pointer to bit position in first 128-bit data to start decoding."]
            #[inline(always)]
            pub fn bp(&self) -> BpR {
                BpR::new((self.bits & 0x7f) as u8)
            }
            #[doc = "Bits 8:11 - Input FIFO counter. Equal to number of qwords in IPU_in_FIFO."]
            #[inline(always)]
            pub fn ifc(&self) -> IfcR {
                IfcR::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 16:17 - FIFO pointer. Equal to number of qwords remaining in IPU except IPU_in_FIFO."]
            #[inline(always)]
            pub fn fp(&self) -> FpR {
                FpR::new(((self.bits >> 16) & 3) as u8)
            }
        }
        #[doc = "IPU input FIFO control.\n\nYou can [`read`](crate::Reg::read) this register and get [`ipu_bp::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IpuBpSpec;
        impl crate::RegisterSpec for IpuBpSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ipu_bp::R`](R) reader structure"]
        impl crate::Readable for IpuBpSpec {}
        #[doc = "`reset()` method sets IPU_BP to value 0"]
        impl crate::Resettable for IpuBpSpec {}
    }
    #[doc = "IPU_TOP (r) register accessor: Reads the first 32 bits of the bit stream after execution of a BDEC / IDEC / VDEC / FDEC command completes.\n\nYou can [`read`](crate::Reg::read) this register and get [`ipu_top::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipu_top`] module"]
    #[doc(alias = "IPU_TOP")]
    pub type IpuTop = crate::Reg<ipu_top::IpuTopSpec>;
    #[doc = "Reads the first 32 bits of the bit stream after execution of a BDEC / IDEC / VDEC / FDEC command completes."]
    pub mod ipu_top {
        #[doc = "Register `IPU_TOP` reader"]
        pub type R = crate::R<IpuTopSpec>;
        #[doc = "Field `BSTOP` reader - Top 32 bits of the bit stream data."]
        pub type BstopR = crate::FieldReader<u32>;
        #[doc = "Command busy status.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Busy {
            #[doc = "0: BSTOP field is enabled (ready to read.)"]
            Enable = 0,
            #[doc = "1: BSTOP field is disabled (decoding still in execution.)"]
            Disable = 1,
        }
        impl From<Busy> for bool {
            #[inline(always)]
            fn from(variant: Busy) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `BUSY` reader - Command busy status."]
        pub type BusyR = crate::BitReader<Busy>;
        impl BusyR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Busy {
                match self.bits {
                    false => Busy::Enable,
                    true => Busy::Disable,
                }
            }
            #[doc = "BSTOP field is enabled (ready to read.)"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Busy::Enable
            }
            #[doc = "BSTOP field is disabled (decoding still in execution.)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Busy::Disable
            }
        }
        impl R {
            #[doc = "Bits 0:31 - Top 32 bits of the bit stream data."]
            #[inline(always)]
            pub fn bstop(&self) -> BstopR {
                BstopR::new((self.bits & 0xffff_ffff) as u32)
            }
            #[doc = "Bit 63 - Command busy status."]
            #[inline(always)]
            pub fn busy(&self) -> BusyR {
                BusyR::new(((self.bits >> 63) & 1) != 0)
            }
        }
        #[doc = "Reads the first 32 bits of the bit stream after execution of a BDEC / IDEC / VDEC / FDEC command completes.\n\nYou can [`read`](crate::Reg::read) this register and get [`ipu_top::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IpuTopSpec;
        impl crate::RegisterSpec for IpuTopSpec {
            type Ux = u64;
        }
        #[doc = "`read()` method returns [`ipu_top::R`](R) reader structure"]
        impl crate::Readable for IpuTopSpec {}
        #[doc = "`reset()` method sets IPU_TOP to value 0"]
        impl crate::Resettable for IpuTopSpec {}
    }
}
#[doc = "GS Interface. See EE User's Manual, Chapter 7."]
pub type Gif = crate::Periph<gif::RegisterBlock, 0xb000_3000>;
impl core::fmt::Debug for Gif {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gif").finish()
    }
}
#[doc = "GS Interface. See EE User's Manual, Chapter 7."]
pub mod gif {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        gif_ctrl: GifCtrl,
        _reserved1: [u8; 0x0c],
        gif_mode: GifMode,
        _reserved2: [u8; 0x0c],
        gif_stat: GifStat,
        _reserved3: [u8; 0x1c],
        gif_tag0: GifTag0,
        _reserved4: [u8; 0x0c],
        gif_tag1: GifTag1,
        _reserved5: [u8; 0x0c],
        gif_tag2: GifTag2,
        _reserved6: [u8; 0x0c],
        gif_tag3: GifTag3,
        _reserved7: [u8; 0x0c],
        gif_cnt: GifCnt,
        _reserved8: [u8; 0x0c],
        gif_p3cnt: GifP3cnt,
        _reserved9: [u8; 0x0c],
        gif_p3tag: GifP3tag,
    }
    impl RegisterBlock {
        #[doc = "0x00 - GIF control"]
        #[inline(always)]
        pub const fn gif_ctrl(&self) -> &GifCtrl {
            &self.gif_ctrl
        }
        #[doc = "0x10 - GIF mode setting"]
        #[inline(always)]
        pub const fn gif_mode(&self) -> &GifMode {
            &self.gif_mode
        }
        #[doc = "0x20 - GIF status"]
        #[inline(always)]
        pub const fn gif_stat(&self) -> &GifStat {
            &self.gif_stat
        }
        #[doc = "0x40 - GIFtag (bits 31-16) immediately before. Only accessible when GIF_CTRL PSE is set to 1."]
        #[inline(always)]
        pub const fn gif_tag0(&self) -> &GifTag0 {
            &self.gif_tag0
        }
        #[doc = "0x50 - GIFtag (bits 45-32) immediately before. Only accessible when GIF_CTRL PSE is set to 1."]
        #[inline(always)]
        pub const fn gif_tag1(&self) -> &GifTag1 {
            &self.gif_tag1
        }
        #[doc = "0x60 - GIFtag (bits 95-64) immediately before. Only accessible when GIF_CTRL PSE is set to 1."]
        #[inline(always)]
        pub const fn gif_tag2(&self) -> &GifTag2 {
            &self.gif_tag2
        }
        #[doc = "0x70 - GIFtag (bits 127-96) immediately before. Only accessible when GIF_CTRL PSE is set to 1."]
        #[inline(always)]
        pub const fn gif_tag3(&self) -> &GifTag3 {
            &self.gif_tag3
        }
        #[doc = "0x80 - Transfer status counter. Only accessible when GIF_CTRL PSE is set to 1."]
        #[inline(always)]
        pub const fn gif_cnt(&self) -> &GifCnt {
            &self.gif_cnt
        }
        #[doc = "0x90 - PATH3 transfer status counter. Only accessible when GIF_CTRL PSE is set to 1."]
        #[inline(always)]
        pub const fn gif_p3cnt(&self) -> &GifP3cnt {
            &self.gif_p3cnt
        }
        #[doc = "0xa0 - PATH3 tag value. Only accessible when GIF_CTRL PSE is set to 1 and when PATH3 is transferring data in IMAGE mode."]
        #[inline(always)]
        pub const fn gif_p3tag(&self) -> &GifP3tag {
            &self.gif_p3tag
        }
    }
    #[doc = "GIF_CTRL (w) register accessor: GIF control\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gif_ctrl::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gif_ctrl`] module"]
    #[doc(alias = "GIF_CTRL")]
    pub type GifCtrl = crate::Reg<gif_ctrl::GifCtrlSpec>;
    #[doc = "GIF control"]
    pub mod gif_ctrl {
        #[doc = "Register `GIF_CTRL` writer"]
        pub type W = crate::W<GifCtrlSpec>;
        #[doc = "GIF reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Rst {
            #[doc = "0: Does nothing."]
            NoReset = 0,
            #[doc = "1: When set, the GIF is reset and the internal register returns to the initial value."]
            Reset = 1,
        }
        impl From<Rst> for bool {
            #[inline(always)]
            fn from(variant: Rst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RST` writer - GIF reset"]
        pub type RstW<'a, REG> = crate::BitWriter<'a, REG, Rst>;
        impl<'a, REG> RstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does nothing."]
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut crate::W<REG> {
                self.variant(Rst::NoReset)
            }
            #[doc = "When set, the GIF is reset and the internal register returns to the initial value."]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(Rst::Reset)
            }
        }
        #[doc = "Temporary transfer stop\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Pse {
            #[doc = "0: Restarts transfer processing. When set, the other GIF registers can no longer be read."]
            TransferRestart = 0,
            #[doc = "1: Temporarily stops transfer processing. When set, allows reading the other GIF registers for debugging."]
            TempStop = 1,
        }
        impl From<Pse> for bool {
            #[inline(always)]
            fn from(variant: Pse) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PSE` writer - Temporary transfer stop"]
        pub type PseW<'a, REG> = crate::BitWriter<'a, REG, Pse>;
        impl<'a, REG> PseW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Restarts transfer processing. When set, the other GIF registers can no longer be read."]
            #[inline(always)]
            pub fn transfer_restart(self) -> &'a mut crate::W<REG> {
                self.variant(Pse::TransferRestart)
            }
            #[doc = "Temporarily stops transfer processing. When set, allows reading the other GIF registers for debugging."]
            #[inline(always)]
            pub fn temp_stop(self) -> &'a mut crate::W<REG> {
                self.variant(Pse::TempStop)
            }
        }
        impl W {
            #[doc = "Bit 0 - GIF reset"]
            #[inline(always)]
            pub fn rst(&mut self) -> RstW<GifCtrlSpec> {
                RstW::new(self, 0)
            }
            #[doc = "Bit 3 - Temporary transfer stop"]
            #[inline(always)]
            pub fn pse(&mut self) -> PseW<GifCtrlSpec> {
                PseW::new(self, 3)
            }
        }
        #[doc = "GIF control\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gif_ctrl::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GifCtrlSpec;
        impl crate::RegisterSpec for GifCtrlSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`gif_ctrl::W`](W) writer structure"]
        impl crate::Writable for GifCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets GIF_CTRL to value 0"]
        impl crate::Resettable for GifCtrlSpec {}
    }
    #[doc = "GIF_MODE (w) register accessor: GIF mode setting\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gif_mode::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gif_mode`] module"]
    #[doc(alias = "GIF_MODE")]
    pub type GifMode = crate::Reg<gif_mode::GifModeSpec>;
    #[doc = "GIF mode setting"]
    pub mod gif_mode {
        #[doc = "Register `GIF_MODE` writer"]
        pub type W = crate::W<GifModeSpec>;
        #[doc = "PATH3 MASK\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum M3r {
            #[doc = "0: Mask cancel(Initial value)"]
            MaskCancel = 0,
            #[doc = "1: Enables the PATH3 mask. If set during a transmission, the mask is enabled after the end of transmission."]
            Mask = 1,
        }
        impl From<M3r> for bool {
            #[inline(always)]
            fn from(variant: M3r) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `M3R` writer - PATH3 MASK"]
        pub type M3rW<'a, REG> = crate::BitWriter<'a, REG, M3r>;
        impl<'a, REG> M3rW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Mask cancel(Initial value)"]
            #[inline(always)]
            pub fn mask_cancel(self) -> &'a mut crate::W<REG> {
                self.variant(M3r::MaskCancel)
            }
            #[doc = "Enables the PATH3 mask. If set during a transmission, the mask is enabled after the end of transmission."]
            #[inline(always)]
            pub fn mask(self) -> &'a mut crate::W<REG> {
                self.variant(M3r::Mask)
            }
        }
        #[doc = "PATH3 transfer mode specification\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Imt {
            #[doc = "0: (Initial value) Continuous transfer mode"]
            ContinuousTransfer = 0,
            #[doc = "1: Intermittent transfer mode in every 8 qwords."]
            IntermittentTransferMode = 1,
        }
        impl From<Imt> for bool {
            #[inline(always)]
            fn from(variant: Imt) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IMT` writer - PATH3 transfer mode specification"]
        pub type ImtW<'a, REG> = crate::BitWriter<'a, REG, Imt>;
        impl<'a, REG> ImtW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "(Initial value) Continuous transfer mode"]
            #[inline(always)]
            pub fn continuous_transfer(self) -> &'a mut crate::W<REG> {
                self.variant(Imt::ContinuousTransfer)
            }
            #[doc = "Intermittent transfer mode in every 8 qwords."]
            #[inline(always)]
            pub fn intermittent_transfer_mode(self) -> &'a mut crate::W<REG> {
                self.variant(Imt::IntermittentTransferMode)
            }
        }
        impl W {
            #[doc = "Bit 0 - PATH3 MASK"]
            #[inline(always)]
            pub fn m3r(&mut self) -> M3rW<GifModeSpec> {
                M3rW::new(self, 0)
            }
            #[doc = "Bit 2 - PATH3 transfer mode specification"]
            #[inline(always)]
            pub fn imt(&mut self) -> ImtW<GifModeSpec> {
                ImtW::new(self, 2)
            }
        }
        #[doc = "GIF mode setting\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gif_mode::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GifModeSpec;
        impl crate::RegisterSpec for GifModeSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`gif_mode::W`](W) writer structure"]
        impl crate::Writable for GifModeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets GIF_MODE to value 0"]
        impl crate::Resettable for GifModeSpec {}
    }
    #[doc = "GIF_STAT (r) register accessor: GIF status\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_stat::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gif_stat`] module"]
    #[doc(alias = "GIF_STAT")]
    pub type GifStat = crate::Reg<gif_stat::GifStatSpec>;
    #[doc = "GIF status"]
    pub mod gif_stat {
        #[doc = "Register `GIF_STAT` reader"]
        pub type R = crate::R<GifStatSpec>;
        #[doc = "PATH3 mask status.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum M3r {
            #[doc = "0: (Initial value) Enabled."]
            Enable = 0,
            #[doc = "1: Disabled (Masked by the MR3 flag of the GIF_MODE register.)"]
            Disable = 1,
        }
        impl From<M3r> for bool {
            #[inline(always)]
            fn from(variant: M3r) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `M3R` reader - PATH3 mask status."]
        pub type M3rR = crate::BitReader<M3r>;
        impl M3rR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> M3r {
                match self.bits {
                    false => M3r::Enable,
                    true => M3r::Disable,
                }
            }
            #[doc = "(Initial value) Enabled."]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == M3r::Enable
            }
            #[doc = "Disabled (Masked by the MR3 flag of the GIF_MODE register.)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == M3r::Disable
            }
        }
        #[doc = "PATH3 VIF mask status.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum M3p {
            #[doc = "0: (Initial value) Enabled."]
            Enable = 0,
            #[doc = "1: Disabled (Masked by the VIF MASKP3 register.)"]
            Disable = 1,
        }
        impl From<M3p> for bool {
            #[inline(always)]
            fn from(variant: M3p) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `M3P` reader - PATH3 VIF mask status."]
        pub type M3pR = crate::BitReader<M3p>;
        impl M3pR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> M3p {
                match self.bits {
                    false => M3p::Enable,
                    true => M3p::Disable,
                }
            }
            #[doc = "(Initial value) Enabled."]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == M3p::Enable
            }
            #[doc = "Disabled (Masked by the VIF MASKP3 register.)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == M3p::Disable
            }
        }
        #[doc = "PATH3 IMT status.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Imt {
            #[doc = "0: (Initial value) Continuous transfer mode."]
            ContinuousTransferMode = 0,
            #[doc = "1: Intermittent transfer mode."]
            IntermittentTransferMode = 1,
        }
        impl From<Imt> for bool {
            #[inline(always)]
            fn from(variant: Imt) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IMT` reader - PATH3 IMT status."]
        pub type ImtR = crate::BitReader<Imt>;
        impl ImtR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Imt {
                match self.bits {
                    false => Imt::ContinuousTransferMode,
                    true => Imt::IntermittentTransferMode,
                }
            }
            #[doc = "(Initial value) Continuous transfer mode."]
            #[inline(always)]
            pub fn is_continuous_transfer_mode(&self) -> bool {
                *self == Imt::ContinuousTransferMode
            }
            #[doc = "Intermittent transfer mode."]
            #[inline(always)]
            pub fn is_intermittent_transfer_mode(&self) -> bool {
                *self == Imt::IntermittentTransferMode
            }
        }
        #[doc = "Temporary transfer stop.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Pse {
            #[doc = "0: (Initial value) Normal."]
            Normal = 0,
            #[doc = "1: Temporary stop state triggered by PSE flag of GIF_CTRL register."]
            TempStop = 1,
        }
        impl From<Pse> for bool {
            #[inline(always)]
            fn from(variant: Pse) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PSE` reader - Temporary transfer stop."]
        pub type PseR = crate::BitReader<Pse>;
        impl PseR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Pse {
                match self.bits {
                    false => Pse::Normal,
                    true => Pse::TempStop,
                }
            }
            #[doc = "(Initial value) Normal."]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == Pse::Normal
            }
            #[doc = "Temporary stop state triggered by PSE flag of GIF_CTRL register."]
            #[inline(always)]
            pub fn is_temp_stop(&self) -> bool {
                *self == Pse::TempStop
            }
        }
        #[doc = "Interrupted PATH3.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ip3 {
            #[doc = "0: (Initial value) No interrupted transfer via PATH3."]
            NoInterrupt = 0,
            #[doc = "1: Interrupted transfer via PATH3."]
            Interrupt = 1,
        }
        impl From<Ip3> for bool {
            #[inline(always)]
            fn from(variant: Ip3) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IP3` reader - Interrupted PATH3."]
        pub type Ip3R = crate::BitReader<Ip3>;
        impl Ip3R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ip3 {
                match self.bits {
                    false => Ip3::NoInterrupt,
                    true => Ip3::Interrupt,
                }
            }
            #[doc = "(Initial value) No interrupted transfer via PATH3."]
            #[inline(always)]
            pub fn is_no_interrupt(&self) -> bool {
                *self == Ip3::NoInterrupt
            }
            #[doc = "Interrupted transfer via PATH3."]
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == Ip3::Interrupt
            }
        }
        #[doc = "PATH3 in queue.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum P3q {
            #[doc = "0: (Initial value) No request to wait for processing in PATH3."]
            NoRequest = 0,
            #[doc = "1: Request to wait for processing in PATH3."]
            Request = 1,
        }
        impl From<P3q> for bool {
            #[inline(always)]
            fn from(variant: P3q) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `P3Q` reader - PATH3 in queue."]
        pub type P3qR = crate::BitReader<P3q>;
        impl P3qR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> P3q {
                match self.bits {
                    false => P3q::NoRequest,
                    true => P3q::Request,
                }
            }
            #[doc = "(Initial value) No request to wait for processing in PATH3."]
            #[inline(always)]
            pub fn is_no_request(&self) -> bool {
                *self == P3q::NoRequest
            }
            #[doc = "Request to wait for processing in PATH3."]
            #[inline(always)]
            pub fn is_request(&self) -> bool {
                *self == P3q::Request
            }
        }
        #[doc = "PATH2 in queue.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum P2q {
            #[doc = "0: (Initial value) No request to wait for processing in PATH2."]
            NoRequest = 0,
            #[doc = "1: Request to wait for processing in PATH2."]
            Request = 1,
        }
        impl From<P2q> for bool {
            #[inline(always)]
            fn from(variant: P2q) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `P2Q` reader - PATH2 in queue."]
        pub type P2qR = crate::BitReader<P2q>;
        impl P2qR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> P2q {
                match self.bits {
                    false => P2q::NoRequest,
                    true => P2q::Request,
                }
            }
            #[doc = "(Initial value) No request to wait for processing in PATH2."]
            #[inline(always)]
            pub fn is_no_request(&self) -> bool {
                *self == P2q::NoRequest
            }
            #[doc = "Request to wait for processing in PATH2."]
            #[inline(always)]
            pub fn is_request(&self) -> bool {
                *self == P2q::Request
            }
        }
        #[doc = "PATH1 in queue.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum P1q {
            #[doc = "0: (Initial value) No request to wait for processing in PATH1."]
            NoRequest = 0,
            #[doc = "1: Request to wait for processing in PATH1."]
            Request = 1,
        }
        impl From<P1q> for bool {
            #[inline(always)]
            fn from(variant: P1q) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `P1Q` reader - PATH1 in queue."]
        pub type P1qR = crate::BitReader<P1q>;
        impl P1qR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> P1q {
                match self.bits {
                    false => P1q::NoRequest,
                    true => P1q::Request,
                }
            }
            #[doc = "(Initial value) No request to wait for processing in PATH1."]
            #[inline(always)]
            pub fn is_no_request(&self) -> bool {
                *self == P1q::NoRequest
            }
            #[doc = "Request to wait for processing in PATH1."]
            #[inline(always)]
            pub fn is_request(&self) -> bool {
                *self == P1q::Request
            }
        }
        #[doc = "Output path.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Oph {
            #[doc = "0: (Initial value) Idle state."]
            Idle = 0,
            #[doc = "1: Outputting data."]
            Outputting = 1,
        }
        impl From<Oph> for bool {
            #[inline(always)]
            fn from(variant: Oph) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `OPH` reader - Output path."]
        pub type OphR = crate::BitReader<Oph>;
        impl OphR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Oph {
                match self.bits {
                    false => Oph::Idle,
                    true => Oph::Outputting,
                }
            }
            #[doc = "(Initial value) Idle state."]
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == Oph::Idle
            }
            #[doc = "Outputting data."]
            #[inline(always)]
            pub fn is_outputting(&self) -> bool {
                *self == Oph::Outputting
            }
        }
        #[doc = "Data path transferring data.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Apath {
            #[doc = "0: (Initial value) Idle state."]
            Idle = 0,
            #[doc = "1: Transferring data via PATH1."]
            Path1 = 1,
            #[doc = "2: Transferring data via PATH2."]
            Path2 = 2,
            #[doc = "3: Transferring data via PATH3."]
            Path3 = 3,
        }
        impl From<Apath> for u8 {
            #[inline(always)]
            fn from(variant: Apath) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Apath {
            type Ux = u8;
        }
        impl crate::IsEnum for Apath {}
        #[doc = "Field `APATH` reader - Data path transferring data."]
        pub type ApathR = crate::FieldReader<Apath>;
        impl ApathR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Apath {
                match self.bits {
                    0 => Apath::Idle,
                    1 => Apath::Path1,
                    2 => Apath::Path2,
                    3 => Apath::Path3,
                    _ => unreachable!(),
                }
            }
            #[doc = "(Initial value) Idle state."]
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == Apath::Idle
            }
            #[doc = "Transferring data via PATH1."]
            #[inline(always)]
            pub fn is_path1(&self) -> bool {
                *self == Apath::Path1
            }
            #[doc = "Transferring data via PATH2."]
            #[inline(always)]
            pub fn is_path2(&self) -> bool {
                *self == Apath::Path2
            }
            #[doc = "Transferring data via PATH3."]
            #[inline(always)]
            pub fn is_path3(&self) -> bool {
                *self == Apath::Path3
            }
        }
        #[doc = "Transfer direction.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Dir {
            #[doc = "0: (Initial value) EE to GS."]
            EeToGs = 0,
            #[doc = "1: GS to EE."]
            GsToEe = 1,
        }
        impl From<Dir> for bool {
            #[inline(always)]
            fn from(variant: Dir) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIR` reader - Transfer direction."]
        pub type DirR = crate::BitReader<Dir>;
        impl DirR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Dir {
                match self.bits {
                    false => Dir::EeToGs,
                    true => Dir::GsToEe,
                }
            }
            #[doc = "(Initial value) EE to GS."]
            #[inline(always)]
            pub fn is_ee_to_gs(&self) -> bool {
                *self == Dir::EeToGs
            }
            #[doc = "GS to EE."]
            #[inline(always)]
            pub fn is_gs_to_ee(&self) -> bool {
                *self == Dir::GsToEe
            }
        }
        #[doc = "Field `FQC` reader - Effective data count in GIF-FIFO (0-16: in qword units)."]
        pub type FqcR = crate::FieldReader;
        impl R {
            #[doc = "Bit 0 - PATH3 mask status."]
            #[inline(always)]
            pub fn m3r(&self) -> M3rR {
                M3rR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - PATH3 VIF mask status."]
            #[inline(always)]
            pub fn m3p(&self) -> M3pR {
                M3pR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - PATH3 IMT status."]
            #[inline(always)]
            pub fn imt(&self) -> ImtR {
                ImtR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Temporary transfer stop."]
            #[inline(always)]
            pub fn pse(&self) -> PseR {
                PseR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 5 - Interrupted PATH3."]
            #[inline(always)]
            pub fn ip3(&self) -> Ip3R {
                Ip3R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - PATH3 in queue."]
            #[inline(always)]
            pub fn p3q(&self) -> P3qR {
                P3qR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - PATH2 in queue."]
            #[inline(always)]
            pub fn p2q(&self) -> P2qR {
                P2qR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - PATH1 in queue."]
            #[inline(always)]
            pub fn p1q(&self) -> P1qR {
                P1qR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Output path."]
            #[inline(always)]
            pub fn oph(&self) -> OphR {
                OphR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bits 10:11 - Data path transferring data."]
            #[inline(always)]
            pub fn apath(&self) -> ApathR {
                ApathR::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bit 12 - Transfer direction."]
            #[inline(always)]
            pub fn dir(&self) -> DirR {
                DirR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bits 24:28 - Effective data count in GIF-FIFO (0-16: in qword units)."]
            #[inline(always)]
            pub fn fqc(&self) -> FqcR {
                FqcR::new(((self.bits >> 24) & 0x1f) as u8)
            }
        }
        #[doc = "GIF status\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_stat::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GifStatSpec;
        impl crate::RegisterSpec for GifStatSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gif_stat::R`](R) reader structure"]
        impl crate::Readable for GifStatSpec {}
        #[doc = "`reset()` method sets GIF_STAT to value 0"]
        impl crate::Resettable for GifStatSpec {}
    }
    #[doc = "GIF_TAG0 (r) register accessor: GIFtag (bits 31-16) immediately before. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_tag0::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gif_tag0`] module"]
    #[doc(alias = "GIF_TAG0")]
    pub type GifTag0 = crate::Reg<gif_tag0::GifTag0Spec>;
    #[doc = "GIFtag (bits 31-16) immediately before. Only accessible when GIF_CTRL PSE is set to 1."]
    pub mod gif_tag0 {
        #[doc = "Register `GIF_TAG0` reader"]
        pub type R = crate::R<GifTag0Spec>;
        #[doc = "Field `NLOOP` reader - Most recently read NLOOP field of GIFtag."]
        pub type NloopR = crate::FieldReader<u16>;
        #[doc = "Field `EOP` reader - Most recently read EOP flag of GIFtag."]
        pub type EopR = crate::BitReader;
        #[doc = "Field `TAG` reader - (Undefined) Values from bit 31 to bit 16 among the most recently read GIFtag values."]
        pub type TagR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:14 - Most recently read NLOOP field of GIFtag."]
            #[inline(always)]
            pub fn nloop(&self) -> NloopR {
                NloopR::new((self.bits & 0x7fff) as u16)
            }
            #[doc = "Bit 15 - Most recently read EOP flag of GIFtag."]
            #[inline(always)]
            pub fn eop(&self) -> EopR {
                EopR::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bits 16:31 - (Undefined) Values from bit 31 to bit 16 among the most recently read GIFtag values."]
            #[inline(always)]
            pub fn tag(&self) -> TagR {
                TagR::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        #[doc = "GIFtag (bits 31-16) immediately before. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_tag0::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GifTag0Spec;
        impl crate::RegisterSpec for GifTag0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gif_tag0::R`](R) reader structure"]
        impl crate::Readable for GifTag0Spec {}
        #[doc = "`reset()` method sets GIF_TAG0 to value 0"]
        impl crate::Resettable for GifTag0Spec {}
    }
    #[doc = "GIF_TAG1 (r) register accessor: GIFtag (bits 45-32) immediately before. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_tag1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gif_tag1`] module"]
    #[doc(alias = "GIF_TAG1")]
    pub type GifTag1 = crate::Reg<gif_tag1::GifTag1Spec>;
    #[doc = "GIFtag (bits 45-32) immediately before. Only accessible when GIF_CTRL PSE is set to 1."]
    pub mod gif_tag1 {
        #[doc = "Register `GIF_TAG1` reader"]
        pub type R = crate::R<GifTag1Spec>;
        #[doc = "Field `TAG` reader - (Undefined) Values from bit 45 to bit 32 among the most recently read GIFtag values."]
        pub type TagR = crate::FieldReader<u16>;
        #[doc = "Field `PRE` reader - Most recently read PRE flag of GIFtag."]
        pub type PreR = crate::BitReader;
        #[doc = "Field `PRIM` reader - Most recently read PRIM field of GIFtag."]
        pub type PrimR = crate::FieldReader<u16>;
        #[doc = "Field `FLG` reader - Most recently read FLG field of GIFtag."]
        pub type FlgR = crate::FieldReader;
        #[doc = "Field `NREG` reader - Most recently read NREG field of GIFtag."]
        pub type NregR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:13 - (Undefined) Values from bit 45 to bit 32 among the most recently read GIFtag values."]
            #[inline(always)]
            pub fn tag(&self) -> TagR {
                TagR::new((self.bits & 0x3fff) as u16)
            }
            #[doc = "Bit 14 - Most recently read PRE flag of GIFtag."]
            #[inline(always)]
            pub fn pre(&self) -> PreR {
                PreR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bits 15:25 - Most recently read PRIM field of GIFtag."]
            #[inline(always)]
            pub fn prim(&self) -> PrimR {
                PrimR::new(((self.bits >> 15) & 0x07ff) as u16)
            }
            #[doc = "Bits 26:27 - Most recently read FLG field of GIFtag."]
            #[inline(always)]
            pub fn flg(&self) -> FlgR {
                FlgR::new(((self.bits >> 26) & 3) as u8)
            }
            #[doc = "Bits 28:31 - Most recently read NREG field of GIFtag."]
            #[inline(always)]
            pub fn nreg(&self) -> NregR {
                NregR::new(((self.bits >> 28) & 0x0f) as u8)
            }
        }
        #[doc = "GIFtag (bits 45-32) immediately before. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_tag1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GifTag1Spec;
        impl crate::RegisterSpec for GifTag1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gif_tag1::R`](R) reader structure"]
        impl crate::Readable for GifTag1Spec {}
        #[doc = "`reset()` method sets GIF_TAG1 to value 0"]
        impl crate::Resettable for GifTag1Spec {}
    }
    #[doc = "GIF_TAG2 (r) register accessor: GIFtag (bits 95-64) immediately before. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_tag2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gif_tag2`] module"]
    #[doc(alias = "GIF_TAG2")]
    pub type GifTag2 = crate::Reg<gif_tag2::GifTag2Spec>;
    #[doc = "GIFtag (bits 95-64) immediately before. Only accessible when GIF_CTRL PSE is set to 1."]
    pub mod gif_tag2 {
        #[doc = "Register `GIF_TAG2` reader"]
        pub type R = crate::R<GifTag2Spec>;
        #[doc = "Field `REGS` reader - Values from bit 95 to bit 64 among most recently read GIFtag values (Lower part of REGS field.)"]
        pub type RegsR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - Values from bit 95 to bit 64 among most recently read GIFtag values (Lower part of REGS field.)"]
            #[inline(always)]
            pub fn regs(&self) -> RegsR {
                RegsR::new(self.bits)
            }
        }
        #[doc = "GIFtag (bits 95-64) immediately before. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_tag2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GifTag2Spec;
        impl crate::RegisterSpec for GifTag2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gif_tag2::R`](R) reader structure"]
        impl crate::Readable for GifTag2Spec {}
        #[doc = "`reset()` method sets GIF_TAG2 to value 0"]
        impl crate::Resettable for GifTag2Spec {}
    }
    #[doc = "GIF_TAG3 (r) register accessor: GIFtag (bits 127-96) immediately before. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_tag3::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gif_tag3`] module"]
    #[doc(alias = "GIF_TAG3")]
    pub type GifTag3 = crate::Reg<gif_tag3::GifTag3Spec>;
    #[doc = "GIFtag (bits 127-96) immediately before. Only accessible when GIF_CTRL PSE is set to 1."]
    pub mod gif_tag3 {
        #[doc = "Register `GIF_TAG3` reader"]
        pub type R = crate::R<GifTag3Spec>;
        #[doc = "Field `REGS` reader - Values from bit 127 to bit 96 among most recently read GIFtag values (Lower part of REGS field.)"]
        pub type RegsR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - Values from bit 127 to bit 96 among most recently read GIFtag values (Lower part of REGS field.)"]
            #[inline(always)]
            pub fn regs(&self) -> RegsR {
                RegsR::new(self.bits)
            }
        }
        #[doc = "GIFtag (bits 127-96) immediately before. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_tag3::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GifTag3Spec;
        impl crate::RegisterSpec for GifTag3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gif_tag3::R`](R) reader structure"]
        impl crate::Readable for GifTag3Spec {}
        #[doc = "`reset()` method sets GIF_TAG3 to value 0"]
        impl crate::Resettable for GifTag3Spec {}
    }
    #[doc = "GIF_CNT (r) register accessor: Transfer status counter. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_cnt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gif_cnt`] module"]
    #[doc(alias = "GIF_CNT")]
    pub type GifCnt = crate::Reg<gif_cnt::GifCntSpec>;
    #[doc = "Transfer status counter. Only accessible when GIF_CTRL PSE is set to 1."]
    pub mod gif_cnt {
        #[doc = "Register `GIF_CNT` reader"]
        pub type R = crate::R<GifCntSpec>;
        #[doc = "Field `LOOPCNT` reader - Value of current loop counter (backward counter from GIF_TAG0 NLOOP field). Decremented when starting processing of the GIF_TAG1 NREGSth register descriptor."]
        pub type LoopcntR = crate::FieldReader<u16>;
        #[doc = "Field `REGCNT` reader - Register descriptor number (0-15) currently in process (Becomes indeterminate in IMAGE mode). * 1 - Lowest significant register descriptor of REGS field. * 2 - 2nd lowest significant register descriptor of REGS field. .. * 15 - 15th lowest significant register descriptor of REGS field. * 0 - Most significant register descriptor of REGS field."]
        pub type RegcntR = crate::FieldReader;
        #[doc = "Field `VUADDR` reader - Address of VU memory under transfer."]
        pub type VuaddrR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:14 - Value of current loop counter (backward counter from GIF_TAG0 NLOOP field). Decremented when starting processing of the GIF_TAG1 NREGSth register descriptor."]
            #[inline(always)]
            pub fn loopcnt(&self) -> LoopcntR {
                LoopcntR::new((self.bits & 0x7fff) as u16)
            }
            #[doc = "Bits 16:19 - Register descriptor number (0-15) currently in process (Becomes indeterminate in IMAGE mode). * 1 - Lowest significant register descriptor of REGS field. * 2 - 2nd lowest significant register descriptor of REGS field. .. * 15 - 15th lowest significant register descriptor of REGS field. * 0 - Most significant register descriptor of REGS field."]
            #[inline(always)]
            pub fn regcnt(&self) -> RegcntR {
                RegcntR::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 20:29 - Address of VU memory under transfer."]
            #[inline(always)]
            pub fn vuaddr(&self) -> VuaddrR {
                VuaddrR::new(((self.bits >> 20) & 0x03ff) as u16)
            }
        }
        #[doc = "Transfer status counter. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_cnt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GifCntSpec;
        impl crate::RegisterSpec for GifCntSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gif_cnt::R`](R) reader structure"]
        impl crate::Readable for GifCntSpec {}
        #[doc = "`reset()` method sets GIF_CNT to value 0"]
        impl crate::Resettable for GifCntSpec {}
    }
    #[doc = "GIF_P3CNT (r) register accessor: PATH3 transfer status counter. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_p3cnt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gif_p3cnt`] module"]
    #[doc(alias = "GIF_P3CNT")]
    pub type GifP3cnt = crate::Reg<gif_p3cnt::GifP3cntSpec>;
    #[doc = "PATH3 transfer status counter. Only accessible when GIF_CTRL PSE is set to 1."]
    pub mod gif_p3cnt {
        #[doc = "Register `GIF_P3CNT` reader"]
        pub type R = crate::R<GifP3cntSpec>;
        #[doc = "Field `P3CNT` reader - The LOOPCNT field value of the GIF_CNT register when transfer via PATH3 is interrupted. This is not updated in the event of a transfer restart."]
        pub type P3cntR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:14 - The LOOPCNT field value of the GIF_CNT register when transfer via PATH3 is interrupted. This is not updated in the event of a transfer restart."]
            #[inline(always)]
            pub fn p3cnt(&self) -> P3cntR {
                P3cntR::new((self.bits & 0x7fff) as u16)
            }
        }
        #[doc = "PATH3 transfer status counter. Only accessible when GIF_CTRL PSE is set to 1.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_p3cnt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GifP3cntSpec;
        impl crate::RegisterSpec for GifP3cntSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gif_p3cnt::R`](R) reader structure"]
        impl crate::Readable for GifP3cntSpec {}
        #[doc = "`reset()` method sets GIF_P3CNT to value 0"]
        impl crate::Resettable for GifP3cntSpec {}
    }
    #[doc = "GIF_P3TAG (r) register accessor: PATH3 tag value. Only accessible when GIF_CTRL PSE is set to 1 and when PATH3 is transferring data in IMAGE mode.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_p3tag::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gif_p3tag`] module"]
    #[doc(alias = "GIF_P3TAG")]
    pub type GifP3tag = crate::Reg<gif_p3tag::GifP3tagSpec>;
    #[doc = "PATH3 tag value. Only accessible when GIF_CTRL PSE is set to 1 and when PATH3 is transferring data in IMAGE mode."]
    pub mod gif_p3tag {
        #[doc = "Register `GIF_P3TAG` reader"]
        pub type R = crate::R<GifP3tagSpec>;
        #[doc = "Field `LOOPCNT` reader - The NLOOP field value of the GIFtag read via PATH3 at the end."]
        pub type LoopcntR = crate::FieldReader<u16>;
        #[doc = "Field `EOP` reader - The EOP flag value of the GIFtag read via PATH 3 at the end."]
        pub type EopR = crate::BitReader;
        impl R {
            #[doc = "Bits 0:14 - The NLOOP field value of the GIFtag read via PATH3 at the end."]
            #[inline(always)]
            pub fn loopcnt(&self) -> LoopcntR {
                LoopcntR::new((self.bits & 0x7fff) as u16)
            }
            #[doc = "Bit 15 - The EOP flag value of the GIFtag read via PATH 3 at the end."]
            #[inline(always)]
            pub fn eop(&self) -> EopR {
                EopR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        #[doc = "PATH3 tag value. Only accessible when GIF_CTRL PSE is set to 1 and when PATH3 is transferring data in IMAGE mode.\n\nYou can [`read`](crate::Reg::read) this register and get [`gif_p3tag::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GifP3tagSpec;
        impl crate::RegisterSpec for GifP3tagSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gif_p3tag::R`](R) reader structure"]
        impl crate::Readable for GifP3tagSpec {}
        #[doc = "`reset()` method sets GIF_P3TAG to value 0"]
        impl crate::Resettable for GifP3tagSpec {}
    }
}
#[doc = "Privileged GS registers. Some are accessible via mapped EE addressed, but some require the GIF for accessing the relevant registers on the GS."]
pub type GsPrivileged = crate::Periph<gs_privileged::RegisterBlock, 0xb200_0000>;
impl core::fmt::Debug for GsPrivileged {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GsPrivileged").finish()
    }
}
#[doc = "Privileged GS registers. Some are accessible via mapped EE addressed, but some require the GIF for accessing the relevant registers on the GS."]
pub mod gs_privileged {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        pmode: Pmode,
        _reserved1: [u8; 0x08],
        smode1: Smode1,
        _reserved2: [u8; 0x08],
        smode2: Smode2,
        _reserved3: [u8; 0x08],
        srfsh: Srfsh,
        _reserved4: [u8; 0x08],
        synch1: Synch1,
        _reserved5: [u8; 0x08],
        synch2: Synch2,
        _reserved6: [u8; 0x08],
        syncv: Syncv,
        _reserved7: [u8; 0x08],
        dispfb1: Dispfb1,
        _reserved8: [u8; 0x08],
        display1: Display1,
        _reserved9: [u8; 0x08],
        dispfb2: Dispfb2,
        _reserved10: [u8; 0x08],
        display2: Display2,
        _reserved11: [u8; 0x08],
        extbuf: Extbuf,
        _reserved12: [u8; 0x08],
        extdata: Extdata,
        _reserved13: [u8; 0x08],
        extwrite: Extwrite,
        _reserved14: [u8; 0x08],
        bgcolor: Bgcolor,
        _reserved15: [u8; 0x0f18],
        csr: Csr,
        _reserved16: [u8; 0x08],
        imr: Imr,
        _reserved17: [u8; 0x28],
        busdir: Busdir,
        _reserved18: [u8; 0x38],
        siglblid: Siglblid,
    }
    impl RegisterBlock {
        #[doc = "0x00..0x08 - Various PCRTC controls. Accessible via EE."]
        #[inline(always)]
        pub const fn pmode(&self) -> &Pmode {
            &self.pmode
        }
        #[doc = "0x10..0x18 - Video signal settings. Sync parameters for the PCRTC."]
        #[inline(always)]
        pub const fn smode1(&self) -> &Smode1 {
            &self.smode1
        }
        #[doc = "0x20..0x28 - Video mode settings for synchronisation."]
        #[inline(always)]
        pub const fn smode2(&self) -> &Smode2 {
            &self.smode2
        }
        #[doc = "0x30..0x38 - GS DRAM refresh rate."]
        #[inline(always)]
        pub const fn srfsh(&self) -> &Srfsh {
            &self.srfsh
        }
        #[doc = "0x40..0x48 - Sync-related. Specific purpose unknown."]
        #[inline(always)]
        pub const fn synch1(&self) -> &Synch1 {
            &self.synch1
        }
        #[doc = "0x50..0x58 - Sync-related. Specific purpose unknown."]
        #[inline(always)]
        pub const fn synch2(&self) -> &Synch2 {
            &self.synch2
        }
        #[doc = "0x60..0x68 - VSync-related interval timins (?)"]
        #[inline(always)]
        pub const fn syncv(&self) -> &Syncv {
            &self.syncv
        }
        #[doc = "0x70..0x78 - Framebuffer register for Output Circuit 1."]
        #[inline(always)]
        pub const fn dispfb1(&self) -> &Dispfb1 {
            &self.dispfb1
        }
        #[doc = "0x80..0x88 - Rectangular viewport from output of Read Circuit 1."]
        #[inline(always)]
        pub const fn display1(&self) -> &Display1 {
            &self.display1
        }
        #[doc = "0x90..0x98 - Framebuffer register for Output Circuit 2."]
        #[inline(always)]
        pub const fn dispfb2(&self) -> &Dispfb2 {
            &self.dispfb2
        }
        #[doc = "0xa0..0xa8 - Rectangular viewport from output of Read Circuit 1."]
        #[inline(always)]
        pub const fn display2(&self) -> &Display2 {
            &self.display2
        }
        #[doc = "0xb0..0xb8 - Feedback write buffer."]
        #[inline(always)]
        pub const fn extbuf(&self) -> &Extbuf {
            &self.extbuf
        }
        #[doc = "0xc0..0xc8 - Feedback write setting."]
        #[inline(always)]
        pub const fn extdata(&self) -> &Extdata {
            &self.extdata
        }
        #[doc = "0xd0..0xd8 - Feedback write function control."]
        #[inline(always)]
        pub const fn extwrite(&self) -> &Extwrite {
            &self.extwrite
        }
        #[doc = "0xe0..0xe8 - Background colour."]
        #[inline(always)]
        pub const fn bgcolor(&self) -> &Bgcolor {
            &self.bgcolor
        }
        #[doc = "0x1000..0x1008 - GS system status and control registers."]
        #[inline(always)]
        pub const fn csr(&self) -> &Csr {
            &self.csr
        }
        #[doc = "0x1010..0x1018 - Interrupt mask control."]
        #[inline(always)]
        pub const fn imr(&self) -> &Imr {
            &self.imr
        }
        #[doc = "0x1040..0x1048 - GS bus direction."]
        #[inline(always)]
        pub const fn busdir(&self) -> &Busdir {
            &self.busdir
        }
        #[doc = "0x1080..0x1088 - Signal Id value."]
        #[inline(always)]
        pub const fn siglblid(&self) -> &Siglblid {
            &self.siglblid
        }
    }
    #[doc = "PMODE (w) register accessor: Various PCRTC controls. Accessible via EE.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pmode::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pmode`] module"]
    #[doc(alias = "PMODE")]
    pub type Pmode = crate::Reg<pmode::PmodeSpec>;
    #[doc = "Various PCRTC controls. Accessible via EE."]
    pub mod pmode {
        #[doc = "Register `PMODE` writer"]
        pub type W = crate::W<PmodeSpec>;
        #[doc = "Enable / disable Read Circuit 1.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum En1 {
            #[doc = "0: Disable Read Circuit 1."]
            Disable = 0,
            #[doc = "1: Enable Read Circuit 1."]
            Enable = 1,
        }
        impl From<En1> for bool {
            #[inline(always)]
            fn from(variant: En1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EN1` writer - Enable / disable Read Circuit 1."]
        pub type En1W<'a, REG> = crate::BitWriter<'a, REG, En1>;
        impl<'a, REG> En1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable Read Circuit 1."]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(En1::Disable)
            }
            #[doc = "Enable Read Circuit 1."]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(En1::Enable)
            }
        }
        #[doc = "Enable / disable Read Circuit 2.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum En2 {
            #[doc = "0: Disable Read Circuit 2."]
            Disable = 0,
            #[doc = "1: Enable Read Circuit 2."]
            Enable = 1,
        }
        impl From<En2> for bool {
            #[inline(always)]
            fn from(variant: En2) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EN2` writer - Enable / disable Read Circuit 2."]
        pub type En2W<'a, REG> = crate::BitWriter<'a, REG, En2>;
        impl<'a, REG> En2W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable Read Circuit 2."]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(En2::Disable)
            }
            #[doc = "Enable Read Circuit 2."]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(En2::Enable)
            }
        }
        #[doc = "CRT output switching. Always set to 1.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Crtmd {
            #[doc = "1: Only (known) valid value."]
            Out1 = 1,
        }
        impl From<Crtmd> for u8 {
            #[inline(always)]
            fn from(variant: Crtmd) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Crtmd {
            type Ux = u8;
        }
        impl crate::IsEnum for Crtmd {}
        #[doc = "Field `CRTMD` writer - CRT output switching. Always set to 1."]
        pub type CrtmdW<'a, REG> = crate::FieldWriter<'a, REG, 3, Crtmd>;
        impl<'a, REG> CrtmdW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Only (known) valid value."]
            #[inline(always)]
            pub fn out1(self) -> &'a mut crate::W<REG> {
                self.variant(Crtmd::Out1)
            }
        }
        #[doc = "Alpha blending value source.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Mmod {
            #[doc = "0: Get alpha from ALP field."]
            BlendAlp = 0,
            #[doc = "1: Get alpha from output of Read Circuit 1."]
            BlendRc1 = 1,
        }
        impl From<Mmod> for bool {
            #[inline(always)]
            fn from(variant: Mmod) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MMOD` writer - Alpha blending value source."]
        pub type MmodW<'a, REG> = crate::BitWriter<'a, REG, Mmod>;
        impl<'a, REG> MmodW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Get alpha from ALP field."]
            #[inline(always)]
            pub fn blend_alp(self) -> &'a mut crate::W<REG> {
                self.variant(Mmod::BlendAlp)
            }
            #[doc = "Get alpha from output of Read Circuit 1."]
            #[inline(always)]
            pub fn blend_rc1(self) -> &'a mut crate::W<REG> {
                self.variant(Mmod::BlendRc1)
            }
        }
        #[doc = "Alpha source to CRTMD chosen output.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Amod {
            #[doc = "0: Alpha value from Read Circuit 1 for output selection."]
            Rc1 = 0,
            #[doc = "1: Alpha value from Read Circuit 2 for output selection."]
            Rc2 = 1,
        }
        impl From<Amod> for bool {
            #[inline(always)]
            fn from(variant: Amod) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `AMOD` writer - Alpha source to CRTMD chosen output."]
        pub type AmodW<'a, REG> = crate::BitWriter<'a, REG, Amod>;
        impl<'a, REG> AmodW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Alpha value from Read Circuit 1 for output selection."]
            #[inline(always)]
            pub fn rc1(self) -> &'a mut crate::W<REG> {
                self.variant(Amod::Rc1)
            }
            #[doc = "Alpha value from Read Circuit 2 for output selection."]
            #[inline(always)]
            pub fn rc2(self) -> &'a mut crate::W<REG> {
                self.variant(Amod::Rc2)
            }
        }
        #[doc = "Alpha blending method.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Slbg {
            #[doc = "0: Blend alpha with output of Read Circuit 2."]
            Circuit2 = 0,
            #[doc = "1: Use background color."]
            Bgcolor = 1,
        }
        impl From<Slbg> for bool {
            #[inline(always)]
            fn from(variant: Slbg) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SLBG` writer - Alpha blending method."]
        pub type SlbgW<'a, REG> = crate::BitWriter<'a, REG, Slbg>;
        impl<'a, REG> SlbgW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Blend alpha with output of Read Circuit 2."]
            #[inline(always)]
            pub fn circuit2(self) -> &'a mut crate::W<REG> {
                self.variant(Slbg::Circuit2)
            }
            #[doc = "Use background color."]
            #[inline(always)]
            pub fn bgcolor(self) -> &'a mut crate::W<REG> {
                self.variant(Slbg::Bgcolor)
            }
        }
        #[doc = "Field `ALP` writer - Alpha blending value."]
        pub type AlpW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `ONES` writer - All set to one. Behaviour is undefined according to the GS users manual but advises to set them regardless, so likely related to a hardware bug."]
        pub type OnesW<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            #[doc = "Bit 0 - Enable / disable Read Circuit 1."]
            #[inline(always)]
            pub fn en1(&mut self) -> En1W<PmodeSpec> {
                En1W::new(self, 0)
            }
            #[doc = "Bit 1 - Enable / disable Read Circuit 2."]
            #[inline(always)]
            pub fn en2(&mut self) -> En2W<PmodeSpec> {
                En2W::new(self, 1)
            }
            #[doc = "Bits 2:4 - CRT output switching. Always set to 1."]
            #[inline(always)]
            pub fn crtmd(&mut self) -> CrtmdW<PmodeSpec> {
                CrtmdW::new(self, 2)
            }
            #[doc = "Bit 5 - Alpha blending value source."]
            #[inline(always)]
            pub fn mmod(&mut self) -> MmodW<PmodeSpec> {
                MmodW::new(self, 5)
            }
            #[doc = "Bit 6 - Alpha source to CRTMD chosen output."]
            #[inline(always)]
            pub fn amod(&mut self) -> AmodW<PmodeSpec> {
                AmodW::new(self, 6)
            }
            #[doc = "Bit 7 - Alpha blending method."]
            #[inline(always)]
            pub fn slbg(&mut self) -> SlbgW<PmodeSpec> {
                SlbgW::new(self, 7)
            }
            #[doc = "Bits 8:15 - Alpha blending value."]
            #[inline(always)]
            pub fn alp(&mut self) -> AlpW<PmodeSpec> {
                AlpW::new(self, 8)
            }
            #[doc = "Bit 16 - All set to one. Behaviour is undefined according to the GS users manual but advises to set them regardless, so likely related to a hardware bug."]
            #[inline(always)]
            pub fn ones(&mut self) -> OnesW<PmodeSpec> {
                OnesW::new(self, 16)
            }
        }
        #[doc = "Various PCRTC controls. Accessible via EE.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pmode::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PmodeSpec;
        impl crate::RegisterSpec for PmodeSpec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`pmode::W`](W) writer structure"]
        impl crate::Writable for PmodeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PMODE to value 0"]
        impl crate::Resettable for PmodeSpec {}
    }
    #[doc = "SMODE1 (w) register accessor: Video signal settings. Sync parameters for the PCRTC.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smode1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smode1`] module"]
    #[doc(alias = "SMODE1")]
    pub type Smode1 = crate::Reg<smode1::Smode1Spec>;
    #[doc = "Video signal settings. Sync parameters for the PCRTC."]
    pub mod smode1 {
        #[doc = "Register `SMODE1` writer"]
        pub type W = crate::W<Smode1Spec>;
        #[doc = "Field `RC` writer - Phase Lock Loop (PLL) reference divider."]
        pub type RcW<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        #[doc = "Field `LC` writer - Phase Lock Loop (PLL) loop divider."]
        pub type LcW<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        #[doc = "Field `T128` writer - Phase Lock Loop (PLL) output divider."]
        pub type T128W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "UNKNOWN. Appears to always be set to 0.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Slck {
            #[doc = "0: Only ever seen set to 0."]
            Default = 0,
        }
        impl From<Slck> for bool {
            #[inline(always)]
            fn from(variant: Slck) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SLCK` writer - UNKNOWN. Appears to always be set to 0."]
        pub type SlckW<'a, REG> = crate::BitWriter<'a, REG, Slck>;
        impl<'a, REG> SlckW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Only ever seen set to 0."]
            #[inline(always)]
            pub fn default(self) -> &'a mut crate::W<REG> {
                self.variant(Slck::Default)
            }
        }
        #[doc = "Subcarrier frequency (display mode.)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Cmod {
            #[doc = "0: Output a VESA signal."]
            Vesa = 0,
            #[doc = "2: Output an NTSC signal."]
            Ntsc = 2,
            #[doc = "3: Output a PAL signal."]
            Pal = 3,
        }
        impl From<Cmod> for u8 {
            #[inline(always)]
            fn from(variant: Cmod) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Cmod {
            type Ux = u8;
        }
        impl crate::IsEnum for Cmod {}
        #[doc = "Field `CMOD` writer - Subcarrier frequency (display mode.)"]
        pub type CmodW<'a, REG> = crate::FieldWriter<'a, REG, 2, Cmod>;
        impl<'a, REG> CmodW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Output a VESA signal."]
            #[inline(always)]
            pub fn vesa(self) -> &'a mut crate::W<REG> {
                self.variant(Cmod::Vesa)
            }
            #[doc = "Output an NTSC signal."]
            #[inline(always)]
            pub fn ntsc(self) -> &'a mut crate::W<REG> {
                self.variant(Cmod::Ntsc)
            }
            #[doc = "Output a PAL signal."]
            #[inline(always)]
            pub fn pal(self) -> &'a mut crate::W<REG> {
                self.variant(Cmod::Pal)
            }
        }
        #[doc = "Field `EX` writer - UNKNOWN."]
        pub type ExW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Reset the PCRTC circuit. A special procedure should be followed to use properly (see GS Mode Selector app documentation.)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Prst {
            #[doc = "0: (Initial value) Does not trigger a reset."]
            Nothing = 0,
            #[doc = "1: Trigger a reset."]
            Reset = 1,
        }
        impl From<Prst> for bool {
            #[inline(always)]
            fn from(variant: Prst) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PRST` writer - Reset the PCRTC circuit. A special procedure should be followed to use properly (see GS Mode Selector app documentation.)"]
        pub type PrstW<'a, REG> = crate::BitWriter<'a, REG, Prst>;
        impl<'a, REG> PrstW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "(Initial value) Does not trigger a reset."]
            #[inline(always)]
            pub fn nothing(self) -> &'a mut crate::W<REG> {
                self.variant(Prst::Nothing)
            }
            #[doc = "Trigger a reset."]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(Prst::Reset)
            }
        }
        #[doc = "Activate / Deactivate the Phase Lock Loop (PLL) circuit. A special procedure should be followed to use properly (see GS Mode Selector app documentation.)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sint {
            #[doc = "0: Turn off the PLL."]
            Off = 0,
            #[doc = "1: Turn on the PLL."]
            On = 1,
        }
        impl From<Sint> for bool {
            #[inline(always)]
            fn from(variant: Sint) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SINT` writer - Activate / Deactivate the Phase Lock Loop (PLL) circuit. A special procedure should be followed to use properly (see GS Mode Selector app documentation.)"]
        pub type SintW<'a, REG> = crate::BitWriter<'a, REG, Sint>;
        impl<'a, REG> SintW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Turn off the PLL."]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Sint::Off)
            }
            #[doc = "Turn on the PLL."]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Sint::On)
            }
        }
        #[doc = "Field `XPCK` writer - UNKNOWN."]
        pub type XpckW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PCK2` writer - UNKNOWN."]
        pub type Pck2W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `SPML` writer - Sub-pixel magnification level."]
        pub type SpmlW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Output colour format.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Gcont {
            #[doc = "0: RGBYc format."]
            Rgbyc = 0,
            #[doc = "1: YCrCb format."]
            Ycrcb = 1,
        }
        impl From<Gcont> for bool {
            #[inline(always)]
            fn from(variant: Gcont) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `GCONT` writer - Output colour format."]
        pub type GcontW<'a, REG> = crate::BitWriter<'a, REG, Gcont>;
        impl<'a, REG> GcontW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "RGBYc format."]
            #[inline(always)]
            pub fn rgbyc(self) -> &'a mut crate::W<REG> {
                self.variant(Gcont::Rgbyc)
            }
            #[doc = "YCrCb format."]
            #[inline(always)]
            pub fn ycrcb(self) -> &'a mut crate::W<REG> {
                self.variant(Gcont::Ycrcb)
            }
        }
        #[doc = "Field `PHS` writer - UNKNOWN. Related to HSync output."]
        pub type PhsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PVS` writer - UNKNOWN. Related to VSync output."]
        pub type PvsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PEHS` writer - UNKNOWN."]
        pub type PehsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PEVS` writer - UNKNOWN."]
        pub type PevsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLKSEL` writer - UNKNOWN."]
        pub type ClkselW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `NVCK` writer - UNKNOWN."]
        pub type NvckW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLCK2` writer - UNKNOWN."]
        pub type Slck2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `VCKSEL` writer - UNKNOWN."]
        pub type VckselW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Scan mode.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vhp {
            #[doc = "0: Interlace mode."]
            Interlaced = 0,
            #[doc = "1: Progressive mode."]
            Progressive = 1,
        }
        impl From<Vhp> for bool {
            #[inline(always)]
            fn from(variant: Vhp) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VHP` writer - Scan mode."]
        pub type VhpW<'a, REG> = crate::BitWriter<'a, REG, Vhp>;
        impl<'a, REG> VhpW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Interlace mode."]
            #[inline(always)]
            pub fn interlaced(self) -> &'a mut crate::W<REG> {
                self.variant(Vhp::Interlaced)
            }
            #[doc = "Progressive mode."]
            #[inline(always)]
            pub fn progressive(self) -> &'a mut crate::W<REG> {
                self.variant(Vhp::Progressive)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Phase Lock Loop (PLL) reference divider."]
            #[inline(always)]
            pub fn rc(&mut self) -> RcW<Smode1Spec> {
                RcW::new(self, 0)
            }
            #[doc = "Bits 3:9 - Phase Lock Loop (PLL) loop divider."]
            #[inline(always)]
            pub fn lc(&mut self) -> LcW<Smode1Spec> {
                LcW::new(self, 3)
            }
            #[doc = "Bits 10:11 - Phase Lock Loop (PLL) output divider."]
            #[inline(always)]
            pub fn t128(&mut self) -> T128W<Smode1Spec> {
                T128W::new(self, 10)
            }
            #[doc = "Bit 12 - UNKNOWN. Appears to always be set to 0."]
            #[inline(always)]
            pub fn slck(&mut self) -> SlckW<Smode1Spec> {
                SlckW::new(self, 12)
            }
            #[doc = "Bits 13:14 - Subcarrier frequency (display mode.)"]
            #[inline(always)]
            pub fn cmod(&mut self) -> CmodW<Smode1Spec> {
                CmodW::new(self, 13)
            }
            #[doc = "Bit 15 - UNKNOWN."]
            #[inline(always)]
            pub fn ex(&mut self) -> ExW<Smode1Spec> {
                ExW::new(self, 15)
            }
            #[doc = "Bit 16 - Reset the PCRTC circuit. A special procedure should be followed to use properly (see GS Mode Selector app documentation.)"]
            #[inline(always)]
            pub fn prst(&mut self) -> PrstW<Smode1Spec> {
                PrstW::new(self, 16)
            }
            #[doc = "Bit 17 - Activate / Deactivate the Phase Lock Loop (PLL) circuit. A special procedure should be followed to use properly (see GS Mode Selector app documentation.)"]
            #[inline(always)]
            pub fn sint(&mut self) -> SintW<Smode1Spec> {
                SintW::new(self, 17)
            }
            #[doc = "Bit 18 - UNKNOWN."]
            #[inline(always)]
            pub fn xpck(&mut self) -> XpckW<Smode1Spec> {
                XpckW::new(self, 18)
            }
            #[doc = "Bits 19:20 - UNKNOWN."]
            #[inline(always)]
            pub fn pck2(&mut self) -> Pck2W<Smode1Spec> {
                Pck2W::new(self, 19)
            }
            #[doc = "Bits 21:24 - Sub-pixel magnification level."]
            #[inline(always)]
            pub fn spml(&mut self) -> SpmlW<Smode1Spec> {
                SpmlW::new(self, 21)
            }
            #[doc = "Bit 25 - Output colour format."]
            #[inline(always)]
            pub fn gcont(&mut self) -> GcontW<Smode1Spec> {
                GcontW::new(self, 25)
            }
            #[doc = "Bit 26 - UNKNOWN. Related to HSync output."]
            #[inline(always)]
            pub fn phs(&mut self) -> PhsW<Smode1Spec> {
                PhsW::new(self, 26)
            }
            #[doc = "Bit 27 - UNKNOWN. Related to VSync output."]
            #[inline(always)]
            pub fn pvs(&mut self) -> PvsW<Smode1Spec> {
                PvsW::new(self, 27)
            }
            #[doc = "Bit 28 - UNKNOWN."]
            #[inline(always)]
            pub fn pehs(&mut self) -> PehsW<Smode1Spec> {
                PehsW::new(self, 28)
            }
            #[doc = "Bit 29 - UNKNOWN."]
            #[inline(always)]
            pub fn pevs(&mut self) -> PevsW<Smode1Spec> {
                PevsW::new(self, 29)
            }
            #[doc = "Bits 30:31 - UNKNOWN."]
            #[inline(always)]
            pub fn clksel(&mut self) -> ClkselW<Smode1Spec> {
                ClkselW::new(self, 30)
            }
            #[doc = "Bit 32 - UNKNOWN."]
            #[inline(always)]
            pub fn nvck(&mut self) -> NvckW<Smode1Spec> {
                NvckW::new(self, 32)
            }
            #[doc = "Bit 33 - UNKNOWN."]
            #[inline(always)]
            pub fn slck2(&mut self) -> Slck2W<Smode1Spec> {
                Slck2W::new(self, 33)
            }
            #[doc = "Bits 34:35 - UNKNOWN."]
            #[inline(always)]
            pub fn vcksel(&mut self) -> VckselW<Smode1Spec> {
                VckselW::new(self, 34)
            }
            #[doc = "Bit 36 - Scan mode."]
            #[inline(always)]
            pub fn vhp(&mut self) -> VhpW<Smode1Spec> {
                VhpW::new(self, 36)
            }
        }
        #[doc = "Video signal settings. Sync parameters for the PCRTC.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smode1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Smode1Spec;
        impl crate::RegisterSpec for Smode1Spec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`smode1::W`](W) writer structure"]
        impl crate::Writable for Smode1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SMODE1 to value 0"]
        impl crate::Resettable for Smode1Spec {}
    }
    #[doc = "SMODE2 (w) register accessor: Video mode settings for synchronisation.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smode2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smode2`] module"]
    #[doc(alias = "SMODE2")]
    pub type Smode2 = crate::Reg<smode2::Smode2Spec>;
    #[doc = "Video mode settings for synchronisation."]
    pub mod smode2 {
        #[doc = "Register `SMODE2` writer"]
        pub type W = crate::W<Smode2Spec>;
        #[doc = "Interlace mode.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Int {
            #[doc = "0: Progressive (noninterlace) mode."]
            Progressive = 0,
            #[doc = "1: Interlace mode."]
            Interlace = 1,
        }
        impl From<Int> for bool {
            #[inline(always)]
            fn from(variant: Int) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `INT` writer - Interlace mode."]
        pub type IntW<'a, REG> = crate::BitWriter<'a, REG, Int>;
        impl<'a, REG> IntW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Progressive (noninterlace) mode."]
            #[inline(always)]
            pub fn progressive(self) -> &'a mut crate::W<REG> {
                self.variant(Int::Progressive)
            }
            #[doc = "Interlace mode."]
            #[inline(always)]
            pub fn interlace(self) -> &'a mut crate::W<REG> {
                self.variant(Int::Interlace)
            }
        }
        #[doc = "Field or Frame mode.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ffmd {
            #[doc = "0: Field mode (every other line is read.)"]
            Field = 0,
            #[doc = "1: Frame mode (every line is read.)"]
            Frame = 1,
        }
        impl From<Ffmd> for bool {
            #[inline(always)]
            fn from(variant: Ffmd) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FFMD` writer - Field or Frame mode."]
        pub type FfmdW<'a, REG> = crate::BitWriter<'a, REG, Ffmd>;
        impl<'a, REG> FfmdW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Field mode (every other line is read.)"]
            #[inline(always)]
            pub fn field(self) -> &'a mut crate::W<REG> {
                self.variant(Ffmd::Field)
            }
            #[doc = "Frame mode (every line is read.)"]
            #[inline(always)]
            pub fn frame(self) -> &'a mut crate::W<REG> {
                self.variant(Ffmd::Frame)
            }
        }
        #[doc = "VESA display power management signalling.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Dpms {
            #[doc = "0: In use."]
            On = 0,
            #[doc = "1: Blanked, low power."]
            Standby = 1,
            #[doc = "2: Blanked, lower power."]
            Suspend = 2,
            #[doc = "3: Shut off, awaiting activity."]
            Off = 3,
        }
        impl From<Dpms> for u8 {
            #[inline(always)]
            fn from(variant: Dpms) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Dpms {
            type Ux = u8;
        }
        impl crate::IsEnum for Dpms {}
        #[doc = "Field `DPMS` writer - VESA display power management signalling."]
        pub type DpmsW<'a, REG> = crate::FieldWriter<'a, REG, 2, Dpms, crate::Safe>;
        impl<'a, REG> DpmsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "In use."]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Dpms::On)
            }
            #[doc = "Blanked, low power."]
            #[inline(always)]
            pub fn standby(self) -> &'a mut crate::W<REG> {
                self.variant(Dpms::Standby)
            }
            #[doc = "Blanked, lower power."]
            #[inline(always)]
            pub fn suspend(self) -> &'a mut crate::W<REG> {
                self.variant(Dpms::Suspend)
            }
            #[doc = "Shut off, awaiting activity."]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Dpms::Off)
            }
        }
        impl W {
            #[doc = "Bit 0 - Interlace mode."]
            #[inline(always)]
            pub fn int(&mut self) -> IntW<Smode2Spec> {
                IntW::new(self, 0)
            }
            #[doc = "Bit 1 - Field or Frame mode."]
            #[inline(always)]
            pub fn ffmd(&mut self) -> FfmdW<Smode2Spec> {
                FfmdW::new(self, 1)
            }
            #[doc = "Bits 2:3 - VESA display power management signalling."]
            #[inline(always)]
            pub fn dpms(&mut self) -> DpmsW<Smode2Spec> {
                DpmsW::new(self, 2)
            }
        }
        #[doc = "Video mode settings for synchronisation.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smode2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Smode2Spec;
        impl crate::RegisterSpec for Smode2Spec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`smode2::W`](W) writer structure"]
        impl crate::Writable for Smode2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SMODE2 to value 0"]
        impl crate::Resettable for Smode2Spec {}
    }
    #[doc = "SRFSH (w) register accessor: GS DRAM refresh rate.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srfsh::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@srfsh`] module"]
    #[doc(alias = "SRFSH")]
    pub type Srfsh = crate::Reg<srfsh::SrfshSpec>;
    #[doc = "GS DRAM refresh rate."]
    pub mod srfsh {
        #[doc = "Register `SRFSH` writer"]
        pub type W = crate::W<SrfshSpec>;
        #[doc = "Field `RFSH` writer - GS DRAM refresh rate."]
        pub type RfshW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl W {
            #[doc = "Bits 0:3 - GS DRAM refresh rate."]
            #[inline(always)]
            pub fn rfsh(&mut self) -> RfshW<SrfshSpec> {
                RfshW::new(self, 0)
            }
        }
        #[doc = "GS DRAM refresh rate.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`srfsh::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SrfshSpec;
        impl crate::RegisterSpec for SrfshSpec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`srfsh::W`](W) writer structure"]
        impl crate::Writable for SrfshSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SRFSH to value 0"]
        impl crate::Resettable for SrfshSpec {}
    }
    #[doc = "SYNCH1 (w) register accessor: Sync-related. Specific purpose unknown.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`synch1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@synch1`] module"]
    #[doc(alias = "SYNCH1")]
    pub type Synch1 = crate::Reg<synch1::Synch1Spec>;
    #[doc = "Sync-related. Specific purpose unknown."]
    pub mod synch1 {
        #[doc = "Register `SYNCH1` writer"]
        pub type W = crate::W<Synch1Spec>;
        #[doc = "Field `HFP` writer - Horizonal front porch."]
        pub type HfpW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        #[doc = "Field `HBP` writer - Horizonal back porch."]
        pub type HbpW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        #[doc = "Field `HSEQ` writer - UNKNOWN."]
        pub type HseqW<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        #[doc = "Field `HSVS` writer - UNKNOWN."]
        pub type HsvsW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        #[doc = "Field `HS` writer - UNKNOWN."]
        pub type HsW<'a, REG> = crate::FieldWriter<'a, REG, 21, u32>;
        impl W {
            #[doc = "Bits 0:10 - Horizonal front porch."]
            #[inline(always)]
            pub fn hfp(&mut self) -> HfpW<Synch1Spec> {
                HfpW::new(self, 0)
            }
            #[doc = "Bits 11:21 - Horizonal back porch."]
            #[inline(always)]
            pub fn hbp(&mut self) -> HbpW<Synch1Spec> {
                HbpW::new(self, 11)
            }
            #[doc = "Bits 22:31 - UNKNOWN."]
            #[inline(always)]
            pub fn hseq(&mut self) -> HseqW<Synch1Spec> {
                HseqW::new(self, 22)
            }
            #[doc = "Bits 32:42 - UNKNOWN."]
            #[inline(always)]
            pub fn hsvs(&mut self) -> HsvsW<Synch1Spec> {
                HsvsW::new(self, 32)
            }
            #[doc = "Bits 43:63 - UNKNOWN."]
            #[inline(always)]
            pub fn hs(&mut self) -> HsW<Synch1Spec> {
                HsW::new(self, 43)
            }
        }
        #[doc = "Sync-related. Specific purpose unknown.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`synch1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Synch1Spec;
        impl crate::RegisterSpec for Synch1Spec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`synch1::W`](W) writer structure"]
        impl crate::Writable for Synch1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SYNCH1 to value 0"]
        impl crate::Resettable for Synch1Spec {}
    }
    #[doc = "SYNCH2 (w) register accessor: Sync-related. Specific purpose unknown.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`synch2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@synch2`] module"]
    #[doc(alias = "SYNCH2")]
    pub type Synch2 = crate::Reg<synch2::Synch2Spec>;
    #[doc = "Sync-related. Specific purpose unknown."]
    pub mod synch2 {
        #[doc = "Register `SYNCH2` writer"]
        pub type W = crate::W<Synch2Spec>;
        #[doc = "Field `HF` writer - UNKNOWN."]
        pub type HfW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        #[doc = "Field `HB` writer - UNKNOWN."]
        pub type HbW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        impl W {
            #[doc = "Bits 0:10 - UNKNOWN."]
            #[inline(always)]
            pub fn hf(&mut self) -> HfW<Synch2Spec> {
                HfW::new(self, 0)
            }
            #[doc = "Bits 11:21 - UNKNOWN."]
            #[inline(always)]
            pub fn hb(&mut self) -> HbW<Synch2Spec> {
                HbW::new(self, 11)
            }
        }
        #[doc = "Sync-related. Specific purpose unknown.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`synch2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Synch2Spec;
        impl crate::RegisterSpec for Synch2Spec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`synch2::W`](W) writer structure"]
        impl crate::Writable for Synch2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SYNCH2 to value 0"]
        impl crate::Resettable for Synch2Spec {}
    }
    #[doc = "SYNCV (w) register accessor: VSync-related interval timins (?)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syncv::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@syncv`] module"]
    #[doc(alias = "SYNCV")]
    pub type Syncv = crate::Reg<syncv::SyncvSpec>;
    #[doc = "VSync-related interval timins (?)"]
    pub mod syncv {
        #[doc = "Register `SYNCV` writer"]
        pub type W = crate::W<SyncvSpec>;
        #[doc = "Field `VFP` writer - Vertical front porch interval. Halflines with colour burst after video data."]
        pub type VfpW<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        #[doc = "Field `VFPE` writer - Vertical front porch interval end. Halflines without colour burst after VFP."]
        pub type VfpeW<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        #[doc = "Field `VBP` writer - Vertical back porch interval. Halflines with colour burst after VBPE."]
        pub type VbpW<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        #[doc = "Field `VBPE` writer - Vertical back porch interval end. Halflines without colour burst after VS."]
        pub type VbpeW<'a, REG> = crate::FieldWriter<'a, REG, 10, u16>;
        #[doc = "Field `VDP` writer - Vertical differential phase. Halflines with video data."]
        pub type VdpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `VS` writer - Vertical Synchronisation timing. Halflines with VSYNC."]
        pub type VsW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        impl W {
            #[doc = "Bits 0:9 - Vertical front porch interval. Halflines with colour burst after video data."]
            #[inline(always)]
            pub fn vfp(&mut self) -> VfpW<SyncvSpec> {
                VfpW::new(self, 0)
            }
            #[doc = "Bits 10:19 - Vertical front porch interval end. Halflines without colour burst after VFP."]
            #[inline(always)]
            pub fn vfpe(&mut self) -> VfpeW<SyncvSpec> {
                VfpeW::new(self, 10)
            }
            #[doc = "Bits 20:31 - Vertical back porch interval. Halflines with colour burst after VBPE."]
            #[inline(always)]
            pub fn vbp(&mut self) -> VbpW<SyncvSpec> {
                VbpW::new(self, 20)
            }
            #[doc = "Bits 32:41 - Vertical back porch interval end. Halflines without colour burst after VS."]
            #[inline(always)]
            pub fn vbpe(&mut self) -> VbpeW<SyncvSpec> {
                VbpeW::new(self, 32)
            }
            #[doc = "Bit 42 - Vertical differential phase. Halflines with video data."]
            #[inline(always)]
            pub fn vdp(&mut self) -> VdpW<SyncvSpec> {
                VdpW::new(self, 42)
            }
            #[doc = "Bits 53:63 - Vertical Synchronisation timing. Halflines with VSYNC."]
            #[inline(always)]
            pub fn vs(&mut self) -> VsW<SyncvSpec> {
                VsW::new(self, 53)
            }
        }
        #[doc = "VSync-related interval timins (?)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syncv::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SyncvSpec;
        impl crate::RegisterSpec for SyncvSpec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`syncv::W`](W) writer structure"]
        impl crate::Writable for SyncvSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SYNCV to value 0"]
        impl crate::Resettable for SyncvSpec {}
    }
    #[doc = "DISPFB1 (w) register accessor: Framebuffer register for Output Circuit 1.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dispfb1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dispfb1`] module"]
    #[doc(alias = "DISPFB1")]
    pub type Dispfb1 = crate::Reg<dispfb1::Dispfb1Spec>;
    #[doc = "Framebuffer register for Output Circuit 1."]
    pub mod dispfb1 {
        #[doc = "Register `DISPFB1` writer"]
        pub type W = crate::W<Dispfb1Spec>;
        #[doc = "Field `FBP` writer - Base pointer address / 2048."]
        pub type FbpW<'a, REG> = crate::FieldWriter<'a, REG, 9, u16>;
        #[doc = "Field `FBW` writer - Buffer width / 64."]
        pub type FbwW<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        #[doc = "Field `PSM` writer - Pixel storage format."]
        pub type PsmW<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        #[doc = "Field `DBX` writer - Upper left X position."]
        pub type DbxW<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        #[doc = "Field `DBY` writer - Upper left Y position."]
        pub type DbyW<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        impl W {
            #[doc = "Bits 0:8 - Base pointer address / 2048."]
            #[inline(always)]
            pub fn fbp(&mut self) -> FbpW<Dispfb1Spec> {
                FbpW::new(self, 0)
            }
            #[doc = "Bits 9:14 - Buffer width / 64."]
            #[inline(always)]
            pub fn fbw(&mut self) -> FbwW<Dispfb1Spec> {
                FbwW::new(self, 9)
            }
            #[doc = "Bits 15:19 - Pixel storage format."]
            #[inline(always)]
            pub fn psm(&mut self) -> PsmW<Dispfb1Spec> {
                PsmW::new(self, 15)
            }
            #[doc = "Bits 20:31 - Upper left X position."]
            #[inline(always)]
            pub fn dbx(&mut self) -> DbxW<Dispfb1Spec> {
                DbxW::new(self, 20)
            }
            #[doc = "Bits 32:43 - Upper left Y position."]
            #[inline(always)]
            pub fn dby(&mut self) -> DbyW<Dispfb1Spec> {
                DbyW::new(self, 32)
            }
        }
        #[doc = "Framebuffer register for Output Circuit 1.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dispfb1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Dispfb1Spec;
        impl crate::RegisterSpec for Dispfb1Spec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`dispfb1::W`](W) writer structure"]
        impl crate::Writable for Dispfb1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DISPFB1 to value 0"]
        impl crate::Resettable for Dispfb1Spec {}
    }
    #[doc = "DISPLAY1 (w) register accessor: Rectangular viewport from output of Read Circuit 1.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`display1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@display1`] module"]
    #[doc(alias = "DISPLAY1")]
    pub type Display1 = crate::Reg<display1::Display1Spec>;
    #[doc = "Rectangular viewport from output of Read Circuit 1."]
    pub mod display1 {
        #[doc = "Register `DISPLAY1` writer"]
        pub type W = crate::W<Display1Spec>;
        #[doc = "Field `DX` writer - Display X position (VCK)."]
        pub type DxW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `DY` writer - Display Y position (px)."]
        pub type DyW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        #[doc = "Field `MAGH` writer - Horizontal magnification in VCKs. Magnification = factor -1 (0 = 1x, 1 = 2x, etc.)"]
        pub type MaghW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `MAGV` writer - Vertical magnification in scanlines. Magnification = factor -1 (0 = 1x, 1 = 2x, etc.)"]
        pub type MagvW<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        #[doc = "Field `DW` writer - Display area width - 1 (VCK)."]
        pub type DwW<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        #[doc = "Field `DH` writer - Display area height - 1 (px)."]
        pub type DhW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        impl W {
            #[doc = "Bits 10:11 - Display X position (VCK)."]
            #[inline(always)]
            pub fn dx(&mut self) -> DxW<Display1Spec> {
                DxW::new(self, 10)
            }
            #[doc = "Bits 12:22 - Display Y position (px)."]
            #[inline(always)]
            pub fn dy(&mut self) -> DyW<Display1Spec> {
                DyW::new(self, 12)
            }
            #[doc = "Bits 23:24 - Horizontal magnification in VCKs. Magnification = factor -1 (0 = 1x, 1 = 2x, etc.)"]
            #[inline(always)]
            pub fn magh(&mut self) -> MaghW<Display1Spec> {
                MaghW::new(self, 23)
            }
            #[doc = "Bits 27:38 - Vertical magnification in scanlines. Magnification = factor -1 (0 = 1x, 1 = 2x, etc.)"]
            #[inline(always)]
            pub fn magv(&mut self) -> MagvW<Display1Spec> {
                MagvW::new(self, 27)
            }
            #[doc = "Bits 32:43 - Display area width - 1 (VCK)."]
            #[inline(always)]
            pub fn dw(&mut self) -> DwW<Display1Spec> {
                DwW::new(self, 32)
            }
            #[doc = "Bits 44:54 - Display area height - 1 (px)."]
            #[inline(always)]
            pub fn dh(&mut self) -> DhW<Display1Spec> {
                DhW::new(self, 44)
            }
        }
        #[doc = "Rectangular viewport from output of Read Circuit 1.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`display1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Display1Spec;
        impl crate::RegisterSpec for Display1Spec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`display1::W`](W) writer structure"]
        impl crate::Writable for Display1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DISPLAY1 to value 0"]
        impl crate::Resettable for Display1Spec {}
    }
    pub use dispfb1 as dispfb2;
    pub use display1 as display2;
    pub use Dispfb1 as Dispfb2;
    pub use Display1 as Display2;
    #[doc = "EXTBUF (w) register accessor: Feedback write buffer.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extbuf::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@extbuf`] module"]
    #[doc(alias = "EXTBUF")]
    pub type Extbuf = crate::Reg<extbuf::ExtbufSpec>;
    #[doc = "Feedback write buffer."]
    pub mod extbuf {
        #[doc = "Register `EXTBUF` writer"]
        pub type W = crate::W<ExtbufSpec>;
        #[doc = "Field `EXBP` writer - Buffer base pointer / 64."]
        pub type ExbpW<'a, REG> = crate::FieldWriter<'a, REG, 14, u16>;
        #[doc = "Field `EXBW` writer - Width of buffer / 64."]
        pub type ExbwW<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        #[doc = "Input source selection.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Fbin {
            #[doc = "0: Output from Read Circuit 1."]
            Out1 = 0,
            #[doc = "1: Output from Read Circuit 2."]
            Out2 = 1,
        }
        impl From<Fbin> for u8 {
            #[inline(always)]
            fn from(variant: Fbin) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Fbin {
            type Ux = u8;
        }
        impl crate::IsEnum for Fbin {}
        #[doc = "Field `FBIN` writer - Input source selection."]
        pub type FbinW<'a, REG> = crate::FieldWriter<'a, REG, 2, Fbin>;
        impl<'a, REG> FbinW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Output from Read Circuit 1."]
            #[inline(always)]
            pub fn out1(self) -> &'a mut crate::W<REG> {
                self.variant(Fbin::Out1)
            }
            #[doc = "Output from Read Circuit 2."]
            #[inline(always)]
            pub fn out2(self) -> &'a mut crate::W<REG> {
                self.variant(Fbin::Out2)
            }
        }
        #[doc = "Interlace mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Wffmd {
            #[doc = "0: Write to every other raster."]
            Field = 0,
            #[doc = "1: Write to every raster."]
            Frame = 1,
        }
        impl From<Wffmd> for bool {
            #[inline(always)]
            fn from(variant: Wffmd) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `WFFMD` writer - Interlace mode"]
        pub type WffmdW<'a, REG> = crate::BitWriter<'a, REG, Wffmd>;
        impl<'a, REG> WffmdW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Write to every other raster."]
            #[inline(always)]
            pub fn field(self) -> &'a mut crate::W<REG> {
                self.variant(Wffmd::Field)
            }
            #[doc = "Write to every raster."]
            #[inline(always)]
            pub fn frame(self) -> &'a mut crate::W<REG> {
                self.variant(Wffmd::Frame)
            }
        }
        #[doc = "Processing of input alpha.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Emoda {
            #[doc = "0: Write input alpha as-is from alpha channel."]
            Alpha = 0,
            #[doc = "1: Write input alpha as-is from Y colour channel."]
            Y = 1,
            #[doc = "2: Write input alpha as half of Y colour channel."]
            YHalf = 2,
            #[doc = "3: Alpha is fixed at zero."]
            Zero = 3,
        }
        impl From<Emoda> for u8 {
            #[inline(always)]
            fn from(variant: Emoda) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Emoda {
            type Ux = u8;
        }
        impl crate::IsEnum for Emoda {}
        #[doc = "Field `EMODA` writer - Processing of input alpha."]
        pub type EmodaW<'a, REG> = crate::FieldWriter<'a, REG, 2, Emoda, crate::Safe>;
        impl<'a, REG> EmodaW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Write input alpha as-is from alpha channel."]
            #[inline(always)]
            pub fn alpha(self) -> &'a mut crate::W<REG> {
                self.variant(Emoda::Alpha)
            }
            #[doc = "Write input alpha as-is from Y colour channel."]
            #[inline(always)]
            pub fn y(self) -> &'a mut crate::W<REG> {
                self.variant(Emoda::Y)
            }
            #[doc = "Write input alpha as half of Y colour channel."]
            #[inline(always)]
            pub fn y_half(self) -> &'a mut crate::W<REG> {
                self.variant(Emoda::YHalf)
            }
            #[doc = "Alpha is fixed at zero."]
            #[inline(always)]
            pub fn zero(self) -> &'a mut crate::W<REG> {
                self.variant(Emoda::Zero)
            }
        }
        #[doc = "Processing of input colour.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Emodc {
            #[doc = "0: Read colour from RGB channels."]
            Rgb = 0,
            #[doc = "1: Read colour as Y channel."]
            Y = 1,
            #[doc = "2: Read color from YcBcR channels."]
            Ycbcr = 2,
            #[doc = "3: Read color from alpha channel."]
            Alpha = 3,
        }
        impl From<Emodc> for u8 {
            #[inline(always)]
            fn from(variant: Emodc) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Emodc {
            type Ux = u8;
        }
        impl crate::IsEnum for Emodc {}
        #[doc = "Field `EMODC` writer - Processing of input colour."]
        pub type EmodcW<'a, REG> = crate::FieldWriter<'a, REG, 2, Emodc, crate::Safe>;
        impl<'a, REG> EmodcW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Read colour from RGB channels."]
            #[inline(always)]
            pub fn rgb(self) -> &'a mut crate::W<REG> {
                self.variant(Emodc::Rgb)
            }
            #[doc = "Read colour as Y channel."]
            #[inline(always)]
            pub fn y(self) -> &'a mut crate::W<REG> {
                self.variant(Emodc::Y)
            }
            #[doc = "Read color from YcBcR channels."]
            #[inline(always)]
            pub fn ycbcr(self) -> &'a mut crate::W<REG> {
                self.variant(Emodc::Ycbcr)
            }
            #[doc = "Read color from alpha channel."]
            #[inline(always)]
            pub fn alpha(self) -> &'a mut crate::W<REG> {
                self.variant(Emodc::Alpha)
            }
        }
        #[doc = "Field `WDX` writer - Upper left X position."]
        pub type WdxW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        #[doc = "Field `WDY` writer - Upper left Y position."]
        pub type WdyW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        impl W {
            #[doc = "Bits 0:13 - Buffer base pointer / 64."]
            #[inline(always)]
            pub fn exbp(&mut self) -> ExbpW<ExtbufSpec> {
                ExbpW::new(self, 0)
            }
            #[doc = "Bits 14:19 - Width of buffer / 64."]
            #[inline(always)]
            pub fn exbw(&mut self) -> ExbwW<ExtbufSpec> {
                ExbwW::new(self, 14)
            }
            #[doc = "Bits 20:21 - Input source selection."]
            #[inline(always)]
            pub fn fbin(&mut self) -> FbinW<ExtbufSpec> {
                FbinW::new(self, 20)
            }
            #[doc = "Bit 22 - Interlace mode"]
            #[inline(always)]
            pub fn wffmd(&mut self) -> WffmdW<ExtbufSpec> {
                WffmdW::new(self, 22)
            }
            #[doc = "Bits 23:24 - Processing of input alpha."]
            #[inline(always)]
            pub fn emoda(&mut self) -> EmodaW<ExtbufSpec> {
                EmodaW::new(self, 23)
            }
            #[doc = "Bits 25:26 - Processing of input colour."]
            #[inline(always)]
            pub fn emodc(&mut self) -> EmodcW<ExtbufSpec> {
                EmodcW::new(self, 25)
            }
            #[doc = "Bits 32:42 - Upper left X position."]
            #[inline(always)]
            pub fn wdx(&mut self) -> WdxW<ExtbufSpec> {
                WdxW::new(self, 32)
            }
            #[doc = "Bits 43:53 - Upper left Y position."]
            #[inline(always)]
            pub fn wdy(&mut self) -> WdyW<ExtbufSpec> {
                WdyW::new(self, 43)
            }
        }
        #[doc = "Feedback write buffer.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extbuf::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ExtbufSpec;
        impl crate::RegisterSpec for ExtbufSpec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`extbuf::W`](W) writer structure"]
        impl crate::Writable for ExtbufSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets EXTBUF to value 0"]
        impl crate::Resettable for ExtbufSpec {}
    }
    #[doc = "EXTDATA (w) register accessor: Feedback write setting.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extdata::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@extdata`] module"]
    #[doc(alias = "EXTDATA")]
    pub type Extdata = crate::Reg<extdata::ExtdataSpec>;
    #[doc = "Feedback write setting."]
    pub mod extdata {
        #[doc = "Register `EXTDATA` writer"]
        pub type W = crate::W<ExtdataSpec>;
        #[doc = "Field `SX` writer - Upper left X position (px)."]
        pub type SxW<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        #[doc = "Field `SY` writer - Upper left Y position (px)."]
        pub type SyW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        #[doc = "Field `SMPH` writer - Horizontal sampling rate interval (measured in scanlines)."]
        pub type SmphW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `SMPV` writer - Vertical sampling rate interval (VCK)."]
        pub type SmpvW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `WW` writer - Rectangular area width - 1."]
        pub type WwW<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        #[doc = "Field `WH` writer - Rectangular area height - 1."]
        pub type WhW<'a, REG> = crate::FieldWriter<'a, REG, 11, u16>;
        impl W {
            #[doc = "Bits 0:11 - Upper left X position (px)."]
            #[inline(always)]
            pub fn sx(&mut self) -> SxW<ExtdataSpec> {
                SxW::new(self, 0)
            }
            #[doc = "Bits 12:22 - Upper left Y position (px)."]
            #[inline(always)]
            pub fn sy(&mut self) -> SyW<ExtdataSpec> {
                SyW::new(self, 12)
            }
            #[doc = "Bits 23:26 - Horizontal sampling rate interval (measured in scanlines)."]
            #[inline(always)]
            pub fn smph(&mut self) -> SmphW<ExtdataSpec> {
                SmphW::new(self, 23)
            }
            #[doc = "Bits 27:28 - Vertical sampling rate interval (VCK)."]
            #[inline(always)]
            pub fn smpv(&mut self) -> SmpvW<ExtdataSpec> {
                SmpvW::new(self, 27)
            }
            #[doc = "Bits 32:43 - Rectangular area width - 1."]
            #[inline(always)]
            pub fn ww(&mut self) -> WwW<ExtdataSpec> {
                WwW::new(self, 32)
            }
            #[doc = "Bits 44:54 - Rectangular area height - 1."]
            #[inline(always)]
            pub fn wh(&mut self) -> WhW<ExtdataSpec> {
                WhW::new(self, 44)
            }
        }
        #[doc = "Feedback write setting.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extdata::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ExtdataSpec;
        impl crate::RegisterSpec for ExtdataSpec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`extdata::W`](W) writer structure"]
        impl crate::Writable for ExtdataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets EXTDATA to value 0"]
        impl crate::Resettable for ExtdataSpec {}
    }
    #[doc = "EXTWRITE (w) register accessor: Feedback write function control.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extwrite::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@extwrite`] module"]
    #[doc(alias = "EXTWRITE")]
    pub type Extwrite = crate::Reg<extwrite::ExtwriteSpec>;
    #[doc = "Feedback write function control."]
    pub mod extwrite {
        #[doc = "Register `EXTWRITE` writer"]
        pub type W = crate::W<ExtwriteSpec>;
        #[doc = "Enable feedback write.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Write {
            #[doc = "0: Complete current feedback write."]
            Stop = 0,
            #[doc = "1: Start next feedback write."]
            Start = 1,
        }
        impl From<Write> for bool {
            #[inline(always)]
            fn from(variant: Write) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `WRITE` writer - Enable feedback write."]
        pub type WriteW<'a, REG> = crate::BitWriter<'a, REG, Write>;
        impl<'a, REG> WriteW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Complete current feedback write."]
            #[inline(always)]
            pub fn stop(self) -> &'a mut crate::W<REG> {
                self.variant(Write::Stop)
            }
            #[doc = "Start next feedback write."]
            #[inline(always)]
            pub fn start(self) -> &'a mut crate::W<REG> {
                self.variant(Write::Start)
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable feedback write."]
            #[inline(always)]
            pub fn write(&mut self) -> WriteW<ExtwriteSpec> {
                WriteW::new(self, 0)
            }
        }
        #[doc = "Feedback write function control.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extwrite::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ExtwriteSpec;
        impl crate::RegisterSpec for ExtwriteSpec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`extwrite::W`](W) writer structure"]
        impl crate::Writable for ExtwriteSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets EXTWRITE to value 0"]
        impl crate::Resettable for ExtwriteSpec {}
    }
    #[doc = "BGCOLOR (w) register accessor: Background colour.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bgcolor::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bgcolor`] module"]
    #[doc(alias = "BGCOLOR")]
    pub type Bgcolor = crate::Reg<bgcolor::BgcolorSpec>;
    #[doc = "Background colour."]
    pub mod bgcolor {
        #[doc = "Register `BGCOLOR` writer"]
        pub type W = crate::W<BgcolorSpec>;
        #[doc = "Field `R` writer - Red channel."]
        pub type RW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `G` writer - Green channel."]
        pub type GW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `B` writer - Blue channel."]
        pub type BW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            #[doc = "Bits 0:7 - Red channel."]
            #[inline(always)]
            pub fn r(&mut self) -> RW<BgcolorSpec> {
                RW::new(self, 0)
            }
            #[doc = "Bits 8:15 - Green channel."]
            #[inline(always)]
            pub fn g(&mut self) -> GW<BgcolorSpec> {
                GW::new(self, 8)
            }
            #[doc = "Bits 16:23 - Blue channel."]
            #[inline(always)]
            pub fn b(&mut self) -> BW<BgcolorSpec> {
                BW::new(self, 16)
            }
        }
        #[doc = "Background colour.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bgcolor::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BgcolorSpec;
        impl crate::RegisterSpec for BgcolorSpec {
            type Ux = u64;
        }
        #[doc = "`write(|w| ..)` method takes [`bgcolor::W`](W) writer structure"]
        impl crate::Writable for BgcolorSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BGCOLOR to value 0"]
        impl crate::Resettable for BgcolorSpec {}
    }
    #[doc = "CSR (rw) register accessor: GS system status and control registers.\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@csr`] module"]
    #[doc(alias = "CSR")]
    pub type Csr = crate::Reg<csr::CsrSpec>;
    #[doc = "GS system status and control registers."]
    pub mod csr {
        #[doc = "Register `CSR` reader"]
        pub type R = crate::R<CsrSpec>;
        #[doc = "Register `CSR` writer"]
        pub type W = crate::W<CsrSpec>;
        #[doc = "SIGNAL event control.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Signal {
            #[doc = "0: No SIGNAL pending."]
            NoSignal = 0,
            #[doc = "1: SIGNAL generated."]
            SignalGenerated = 1,
        }
        impl From<Signal> for bool {
            #[inline(always)]
            fn from(variant: Signal) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SIGNAL` reader - SIGNAL event control."]
        pub type SignalR = crate::BitReader<Signal>;
        impl SignalR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Signal {
                match self.bits {
                    false => Signal::NoSignal,
                    true => Signal::SignalGenerated,
                }
            }
            #[doc = "No SIGNAL pending."]
            #[inline(always)]
            pub fn is_no_signal(&self) -> bool {
                *self == Signal::NoSignal
            }
            #[doc = "SIGNAL generated."]
            #[inline(always)]
            pub fn is_signal_generated(&self) -> bool {
                *self == Signal::SignalGenerated
            }
        }
        #[doc = "SIGNAL event control.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SignalWO {
            #[doc = "0: No action."]
            NoAction = 0,
            #[doc = "1: Clear old event and enable new event."]
            Enable = 1,
        }
        impl From<SignalWO> for bool {
            #[inline(always)]
            fn from(variant: SignalWO) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SIGNAL` writer - SIGNAL event control."]
        pub type SignalW<'a, REG> = crate::BitWriter<'a, REG, SignalWO>;
        impl<'a, REG> SignalW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No action."]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut crate::W<REG> {
                self.variant(SignalWO::NoAction)
            }
            #[doc = "Clear old event and enable new event."]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(SignalWO::Enable)
            }
        }
        #[doc = "FINISH event control.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Finish {
            #[doc = "0: No FINISH pending."]
            NoFinish = 0,
            #[doc = "1: FINISH generated."]
            FinishGenerated = 1,
        }
        impl From<Finish> for bool {
            #[inline(always)]
            fn from(variant: Finish) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FINISH` reader - FINISH event control."]
        pub type FinishR = crate::BitReader<Finish>;
        impl FinishR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Finish {
                match self.bits {
                    false => Finish::NoFinish,
                    true => Finish::FinishGenerated,
                }
            }
            #[doc = "No FINISH pending."]
            #[inline(always)]
            pub fn is_no_finish(&self) -> bool {
                *self == Finish::NoFinish
            }
            #[doc = "FINISH generated."]
            #[inline(always)]
            pub fn is_finish_generated(&self) -> bool {
                *self == Finish::FinishGenerated
            }
        }
        #[doc = "FINISH event control.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FinishWO {
            #[doc = "0: No action."]
            NoAction = 0,
            #[doc = "1: FINISH event is enabled."]
            Enable = 1,
        }
        impl From<FinishWO> for bool {
            #[inline(always)]
            fn from(variant: FinishWO) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FINISH` writer - FINISH event control."]
        pub type FinishW<'a, REG> = crate::BitWriter<'a, REG, FinishWO>;
        impl<'a, REG> FinishW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No action."]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut crate::W<REG> {
                self.variant(FinishWO::NoAction)
            }
            #[doc = "FINISH event is enabled."]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(FinishWO::Enable)
            }
        }
        #[doc = "HSync interrupt control.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Hsint {
            #[doc = "0: No Hsync interrupt pending."]
            NoHsync = 0,
            #[doc = "1: Hsync interrupt has been generated."]
            HsyncGenerated = 1,
        }
        impl From<Hsint> for bool {
            #[inline(always)]
            fn from(variant: Hsint) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `HSINT` reader - HSync interrupt control."]
        pub type HsintR = crate::BitReader<Hsint>;
        impl HsintR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Hsint {
                match self.bits {
                    false => Hsint::NoHsync,
                    true => Hsint::HsyncGenerated,
                }
            }
            #[doc = "No Hsync interrupt pending."]
            #[inline(always)]
            pub fn is_no_hsync(&self) -> bool {
                *self == Hsint::NoHsync
            }
            #[doc = "Hsync interrupt has been generated."]
            #[inline(always)]
            pub fn is_hsync_generated(&self) -> bool {
                *self == Hsint::HsyncGenerated
            }
        }
        #[doc = "HSync interrupt control.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HsintWO {
            #[doc = "0: No action."]
            NoAction = 0,
            #[doc = "1: HSync interrupt is enabled."]
            Enable = 1,
        }
        impl From<HsintWO> for bool {
            #[inline(always)]
            fn from(variant: HsintWO) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `HSINT` writer - HSync interrupt control."]
        pub type HsintW<'a, REG> = crate::BitWriter<'a, REG, HsintWO>;
        impl<'a, REG> HsintW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No action."]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut crate::W<REG> {
                self.variant(HsintWO::NoAction)
            }
            #[doc = "HSync interrupt is enabled."]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(HsintWO::Enable)
            }
        }
        #[doc = "VSync interrupt control.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vsint {
            #[doc = "0: No Vsync interrupt pending."]
            NoVsync = 0,
            #[doc = "1: Vsync interrupt has been generated."]
            VsyncGenerated = 1,
        }
        impl From<Vsint> for bool {
            #[inline(always)]
            fn from(variant: Vsint) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VSINT` reader - VSync interrupt control."]
        pub type VsintR = crate::BitReader<Vsint>;
        impl VsintR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vsint {
                match self.bits {
                    false => Vsint::NoVsync,
                    true => Vsint::VsyncGenerated,
                }
            }
            #[doc = "No Vsync interrupt pending."]
            #[inline(always)]
            pub fn is_no_vsync(&self) -> bool {
                *self == Vsint::NoVsync
            }
            #[doc = "Vsync interrupt has been generated."]
            #[inline(always)]
            pub fn is_vsync_generated(&self) -> bool {
                *self == Vsint::VsyncGenerated
            }
        }
        #[doc = "VSync interrupt control.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum VsintWO {
            #[doc = "0: No action."]
            NoAction = 0,
            #[doc = "1: VSync interrupt is enabled."]
            Enable = 1,
        }
        impl From<VsintWO> for bool {
            #[inline(always)]
            fn from(variant: VsintWO) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VSINT` writer - VSync interrupt control."]
        pub type VsintW<'a, REG> = crate::BitWriter<'a, REG, VsintWO>;
        impl<'a, REG> VsintW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No action."]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut crate::W<REG> {
                self.variant(VsintWO::NoAction)
            }
            #[doc = "VSync interrupt is enabled."]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(VsintWO::Enable)
            }
        }
        #[doc = "Rectangular area write termination interrupt control.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Edwint {
            #[doc = "0: No rectangular area write interrupt pending."]
            NoEdwint = 0,
            #[doc = "1: Rectangular area write interrupt has been generated."]
            RawriteGenerated = 1,
        }
        impl From<Edwint> for bool {
            #[inline(always)]
            fn from(variant: Edwint) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EDWINT` reader - Rectangular area write termination interrupt control."]
        pub type EdwintR = crate::BitReader<Edwint>;
        impl EdwintR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Edwint {
                match self.bits {
                    false => Edwint::NoEdwint,
                    true => Edwint::RawriteGenerated,
                }
            }
            #[doc = "No rectangular area write interrupt pending."]
            #[inline(always)]
            pub fn is_no_edwint(&self) -> bool {
                *self == Edwint::NoEdwint
            }
            #[doc = "Rectangular area write interrupt has been generated."]
            #[inline(always)]
            pub fn is_rawrite_generated(&self) -> bool {
                *self == Edwint::RawriteGenerated
            }
        }
        #[doc = "Rectangular area write termination interrupt control.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EdwintWO {
            #[doc = "0: No action."]
            NoAction = 0,
            #[doc = "1: Rectangular area write interrupt is enabled."]
            Enable = 1,
        }
        impl From<EdwintWO> for bool {
            #[inline(always)]
            fn from(variant: EdwintWO) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `EDWINT` writer - Rectangular area write termination interrupt control."]
        pub type EdwintW<'a, REG> = crate::BitWriter<'a, REG, EdwintWO>;
        impl<'a, REG> EdwintW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No action."]
            #[inline(always)]
            pub fn no_action(self) -> &'a mut crate::W<REG> {
                self.variant(EdwintWO::NoAction)
            }
            #[doc = "Rectangular area write interrupt is enabled."]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(EdwintWO::Enable)
            }
        }
        #[doc = "Field `ZERO` reader - Must always be zero."]
        pub type ZeroR = crate::FieldReader;
        #[doc = "Field `ZERO` writer - Must always be zero."]
        pub type ZeroW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Drawing suspend and FIFO clear (enabled during data write).\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Flush {
            #[doc = "0: Resume drawing if suspended (?)"]
            Resume = 0,
            #[doc = "1: Flush the GS FIFO and suspend drawing."]
            Flush = 1,
        }
        impl From<Flush> for bool {
            #[inline(always)]
            fn from(variant: Flush) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FLUSH` writer - Drawing suspend and FIFO clear (enabled during data write)."]
        pub type FlushW<'a, REG> = crate::BitWriter<'a, REG, Flush>;
        impl<'a, REG> FlushW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Resume drawing if suspended (?)"]
            #[inline(always)]
            pub fn resume(self) -> &'a mut crate::W<REG> {
                self.variant(Flush::Resume)
            }
            #[doc = "Flush the GS FIFO and suspend drawing."]
            #[inline(always)]
            pub fn flush(self) -> &'a mut crate::W<REG> {
                self.variant(Flush::Flush)
            }
        }
        #[doc = "GS reset..\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Reset {
            #[doc = "0: Do nothing."]
            DoNothing = 0,
            #[doc = "1: GS soft system reset. Clears FIFOs and resets IMR to all 1's."]
            Reset = 1,
        }
        impl From<Reset> for bool {
            #[inline(always)]
            fn from(variant: Reset) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RESET` reader - GS reset.."]
        pub type ResetR = crate::BitReader<Reset>;
        impl ResetR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Reset {
                match self.bits {
                    false => Reset::DoNothing,
                    true => Reset::Reset,
                }
            }
            #[doc = "Do nothing."]
            #[inline(always)]
            pub fn is_do_nothing(&self) -> bool {
                *self == Reset::DoNothing
            }
            #[doc = "GS soft system reset. Clears FIFOs and resets IMR to all 1's."]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == Reset::Reset
            }
        }
        #[doc = "Field `RESET` writer - GS reset.."]
        pub type ResetW<'a, REG> = crate::BitWriter<'a, REG, Reset>;
        impl<'a, REG> ResetW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Do nothing."]
            #[inline(always)]
            pub fn do_nothing(self) -> &'a mut crate::W<REG> {
                self.variant(Reset::DoNothing)
            }
            #[doc = "GS soft system reset. Clears FIFOs and resets IMR to all 1's."]
            #[inline(always)]
            pub fn reset(self) -> &'a mut crate::W<REG> {
                self.variant(Reset::Reset)
            }
        }
        #[doc = "Field `NFIELD` reader - VSync sampled FIELD."]
        pub type NfieldR = crate::BitReader;
        #[doc = "Field `NFIELD` writer - VSync sampled FIELD."]
        pub type NfieldW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Current Field of display \\[page-flipping\\].\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Field {
            #[doc = "0: Even display buffer."]
            Even = 0,
            #[doc = "1: Odd display buffer."]
            Odd = 1,
        }
        impl From<Field> for bool {
            #[inline(always)]
            fn from(variant: Field) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FIELD` reader - Current Field of display \\[page-flipping\\]."]
        pub type FieldR = crate::BitReader<Field>;
        impl FieldR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Field {
                match self.bits {
                    false => Field::Even,
                    true => Field::Odd,
                }
            }
            #[doc = "Even display buffer."]
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                *self == Field::Even
            }
            #[doc = "Odd display buffer."]
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                *self == Field::Odd
            }
        }
        #[doc = "GS FIFO status.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Fifo {
            #[doc = "0: Not empty but not near-full."]
            Between = 0,
            #[doc = "1: FIFO is empty."]
            Empty = 1,
            #[doc = "2: Almost full."]
            AlmostFull = 2,
            #[doc = "3: Reserved."]
            Unused = 3,
        }
        impl From<Fifo> for u8 {
            #[inline(always)]
            fn from(variant: Fifo) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Fifo {
            type Ux = u8;
        }
        impl crate::IsEnum for Fifo {}
        #[doc = "Field `FIFO` reader - GS FIFO status."]
        pub type FifoR = crate::FieldReader<Fifo>;
        impl FifoR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Fifo {
                match self.bits {
                    0 => Fifo::Between,
                    1 => Fifo::Empty,
                    2 => Fifo::AlmostFull,
                    3 => Fifo::Unused,
                    _ => unreachable!(),
                }
            }
            #[doc = "Not empty but not near-full."]
            #[inline(always)]
            pub fn is_between(&self) -> bool {
                *self == Fifo::Between
            }
            #[doc = "FIFO is empty."]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == Fifo::Empty
            }
            #[doc = "Almost full."]
            #[inline(always)]
            pub fn is_almost_full(&self) -> bool {
                *self == Fifo::AlmostFull
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn is_unused(&self) -> bool {
                *self == Fifo::Unused
            }
        }
        #[doc = "Field `REV` reader - GS revision number."]
        pub type RevR = crate::FieldReader;
        #[doc = "Field `ID` reader - GS Id."]
        pub type IdR = crate::FieldReader;
        impl R {
            #[doc = "Bit 0 - SIGNAL event control."]
            #[inline(always)]
            pub fn signal(&self) -> SignalR {
                SignalR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - FINISH event control."]
            #[inline(always)]
            pub fn finish(&self) -> FinishR {
                FinishR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - HSync interrupt control."]
            #[inline(always)]
            pub fn hsint(&self) -> HsintR {
                HsintR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - VSync interrupt control."]
            #[inline(always)]
            pub fn vsint(&self) -> VsintR {
                VsintR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Rectangular area write termination interrupt control."]
            #[inline(always)]
            pub fn edwint(&self) -> EdwintR {
                EdwintR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 5:6 - Must always be zero."]
            #[inline(always)]
            pub fn zero(&self) -> ZeroR {
                ZeroR::new(((self.bits >> 5) & 3) as u8)
            }
            #[doc = "Bit 9 - GS reset.."]
            #[inline(always)]
            pub fn reset(&self) -> ResetR {
                ResetR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 12 - VSync sampled FIELD."]
            #[inline(always)]
            pub fn nfield(&self) -> NfieldR {
                NfieldR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Current Field of display \\[page-flipping\\]."]
            #[inline(always)]
            pub fn field(&self) -> FieldR {
                FieldR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bits 14:15 - GS FIFO status."]
            #[inline(always)]
            pub fn fifo(&self) -> FifoR {
                FifoR::new(((self.bits >> 14) & 3) as u8)
            }
            #[doc = "Bits 16:23 - GS revision number."]
            #[inline(always)]
            pub fn rev(&self) -> RevR {
                RevR::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - GS Id."]
            #[inline(always)]
            pub fn id(&self) -> IdR {
                IdR::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - SIGNAL event control."]
            #[inline(always)]
            pub fn signal(&mut self) -> SignalW<CsrSpec> {
                SignalW::new(self, 0)
            }
            #[doc = "Bit 1 - FINISH event control."]
            #[inline(always)]
            pub fn finish(&mut self) -> FinishW<CsrSpec> {
                FinishW::new(self, 1)
            }
            #[doc = "Bit 2 - HSync interrupt control."]
            #[inline(always)]
            pub fn hsint(&mut self) -> HsintW<CsrSpec> {
                HsintW::new(self, 2)
            }
            #[doc = "Bit 3 - VSync interrupt control."]
            #[inline(always)]
            pub fn vsint(&mut self) -> VsintW<CsrSpec> {
                VsintW::new(self, 3)
            }
            #[doc = "Bit 4 - Rectangular area write termination interrupt control."]
            #[inline(always)]
            pub fn edwint(&mut self) -> EdwintW<CsrSpec> {
                EdwintW::new(self, 4)
            }
            #[doc = "Bits 5:6 - Must always be zero."]
            #[inline(always)]
            pub fn zero(&mut self) -> ZeroW<CsrSpec> {
                ZeroW::new(self, 5)
            }
            #[doc = "Bit 8 - Drawing suspend and FIFO clear (enabled during data write)."]
            #[inline(always)]
            pub fn flush(&mut self) -> FlushW<CsrSpec> {
                FlushW::new(self, 8)
            }
            #[doc = "Bit 9 - GS reset.."]
            #[inline(always)]
            pub fn reset(&mut self) -> ResetW<CsrSpec> {
                ResetW::new(self, 9)
            }
            #[doc = "Bit 12 - VSync sampled FIELD."]
            #[inline(always)]
            pub fn nfield(&mut self) -> NfieldW<CsrSpec> {
                NfieldW::new(self, 12)
            }
        }
        #[doc = "GS system status and control registers.\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CsrSpec;
        impl crate::RegisterSpec for CsrSpec {
            type Ux = u64;
        }
        #[doc = "`read()` method returns [`csr::R`](R) reader structure"]
        impl crate::Readable for CsrSpec {}
        #[doc = "`write(|w| ..)` method takes [`csr::W`](W) writer structure"]
        impl crate::Writable for CsrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CSR to value 0"]
        impl crate::Resettable for CsrSpec {}
    }
    #[doc = "IMR (r) register accessor: Interrupt mask control.\n\nYou can [`read`](crate::Reg::read) this register and get [`imr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@imr`] module"]
    #[doc(alias = "IMR")]
    pub type Imr = crate::Reg<imr::ImrSpec>;
    #[doc = "Interrupt mask control."]
    pub mod imr {
        #[doc = "Register `IMR` reader"]
        pub type R = crate::R<ImrSpec>;
        #[doc = "Field `SIGMSK` reader - Signal event interrupt mask."]
        pub type SigmskR = crate::BitReader;
        #[doc = "Field `FINISHMSK` reader - Finish event interrupt mask."]
        pub type FinishmskR = crate::BitReader;
        #[doc = "Field `HSMSK` reader - HSync interrupt mask."]
        pub type HsmskR = crate::BitReader;
        #[doc = "Field `VSMSK` reader - VSync interrupt mask."]
        pub type VsmskR = crate::BitReader;
        #[doc = "Field `EDWMSK` reader - Rectangle write termination interrupt mask."]
        pub type EdwmskR = crate::BitReader;
        #[doc = "Field `ONES` reader - All set to one. Behaviour is undefined according to the GS users manual but advises to set them regardless, so likely related to a hardware bug."]
        pub type OnesR = crate::FieldReader;
        impl R {
            #[doc = "Bit 8 - Signal event interrupt mask."]
            #[inline(always)]
            pub fn sigmsk(&self) -> SigmskR {
                SigmskR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Finish event interrupt mask."]
            #[inline(always)]
            pub fn finishmsk(&self) -> FinishmskR {
                FinishmskR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - HSync interrupt mask."]
            #[inline(always)]
            pub fn hsmsk(&self) -> HsmskR {
                HsmskR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - VSync interrupt mask."]
            #[inline(always)]
            pub fn vsmsk(&self) -> VsmskR {
                VsmskR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Rectangle write termination interrupt mask."]
            #[inline(always)]
            pub fn edwmsk(&self) -> EdwmskR {
                EdwmskR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bits 13:14 - All set to one. Behaviour is undefined according to the GS users manual but advises to set them regardless, so likely related to a hardware bug."]
            #[inline(always)]
            pub fn ones(&self) -> OnesR {
                OnesR::new(((self.bits >> 13) & 3) as u8)
            }
        }
        #[doc = "Interrupt mask control.\n\nYou can [`read`](crate::Reg::read) this register and get [`imr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ImrSpec;
        impl crate::RegisterSpec for ImrSpec {
            type Ux = u64;
        }
        #[doc = "`read()` method returns [`imr::R`](R) reader structure"]
        impl crate::Readable for ImrSpec {}
        #[doc = "`reset()` method sets IMR to value 0"]
        impl crate::Resettable for ImrSpec {}
    }
    #[doc = "BUSDIR (r) register accessor: GS bus direction.\n\nYou can [`read`](crate::Reg::read) this register and get [`busdir::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@busdir`] module"]
    #[doc(alias = "BUSDIR")]
    pub type Busdir = crate::Reg<busdir::BusdirSpec>;
    #[doc = "GS bus direction."]
    pub mod busdir {
        #[doc = "Register `BUSDIR` reader"]
        pub type R = crate::R<BusdirSpec>;
        #[doc = "Host to local direction, or vice versa.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Dir {
            #[doc = "0: Host to local bus transfer."]
            HostToLocal = 0,
            #[doc = "1: Local to host bus transfer."]
            LocalToHost = 1,
        }
        impl From<Dir> for bool {
            #[inline(always)]
            fn from(variant: Dir) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DIR` reader - Host to local direction, or vice versa."]
        pub type DirR = crate::BitReader<Dir>;
        impl DirR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Dir {
                match self.bits {
                    false => Dir::HostToLocal,
                    true => Dir::LocalToHost,
                }
            }
            #[doc = "Host to local bus transfer."]
            #[inline(always)]
            pub fn is_host_to_local(&self) -> bool {
                *self == Dir::HostToLocal
            }
            #[doc = "Local to host bus transfer."]
            #[inline(always)]
            pub fn is_local_to_host(&self) -> bool {
                *self == Dir::LocalToHost
            }
        }
        impl R {
            #[doc = "Bit 0 - Host to local direction, or vice versa."]
            #[inline(always)]
            pub fn dir(&self) -> DirR {
                DirR::new((self.bits & 1) != 0)
            }
        }
        #[doc = "GS bus direction.\n\nYou can [`read`](crate::Reg::read) this register and get [`busdir::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BusdirSpec;
        impl crate::RegisterSpec for BusdirSpec {
            type Ux = u64;
        }
        #[doc = "`read()` method returns [`busdir::R`](R) reader structure"]
        impl crate::Readable for BusdirSpec {}
        #[doc = "`reset()` method sets BUSDIR to value 0"]
        impl crate::Resettable for BusdirSpec {}
    }
    #[doc = "SIGLBLID (r) register accessor: Signal Id value.\n\nYou can [`read`](crate::Reg::read) this register and get [`siglblid::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@siglblid`] module"]
    #[doc(alias = "SIGLBLID")]
    pub type Siglblid = crate::Reg<siglblid::SiglblidSpec>;
    #[doc = "Signal Id value."]
    pub mod siglblid {
        #[doc = "Register `SIGLBLID` reader"]
        pub type R = crate::R<SiglblidSpec>;
        #[doc = "Field `SIGID` reader - Id value set by SIGNAL register."]
        pub type SigidR = crate::FieldReader<u32>;
        #[doc = "Field `LBLID` reader - Id value set by LABEL register."]
        pub type LblidR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - Id value set by SIGNAL register."]
            #[inline(always)]
            pub fn sigid(&self) -> SigidR {
                SigidR::new((self.bits & 0xffff_ffff) as u32)
            }
            #[doc = "Bits 32:63 - Id value set by LABEL register."]
            #[inline(always)]
            pub fn lblid(&self) -> LblidR {
                LblidR::new(((self.bits >> 32) & 0xffff_ffff) as u32)
            }
        }
        #[doc = "Signal Id value.\n\nYou can [`read`](crate::Reg::read) this register and get [`siglblid::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SiglblidSpec;
        impl crate::RegisterSpec for SiglblidSpec {
            type Ux = u64;
        }
        #[doc = "`read()` method returns [`siglblid::R`](R) reader structure"]
        impl crate::Readable for SiglblidSpec {}
        #[doc = "`reset()` method sets SIGLBLID to value 0"]
        impl crate::Resettable for SiglblidSpec {}
    }
}
#[doc = "VU Interface. See EE User's Manual, Chapter 6."]
pub type Vif = crate::Periph<vif::RegisterBlock, 0xb000_3800>;
impl core::fmt::Debug for Vif {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vif").finish()
    }
}
#[doc = "VU Interface. See EE User's Manual, Chapter 6."]
pub mod vif {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        vif0_stat: Vif0Stat,
        _reserved1: [u8; 0x0c],
        vif0_fbrst: Vif0Fbrst,
        _reserved2: [u8; 0x0c],
        vif0_err: Vif0Err,
        _reserved3: [u8; 0x0c],
        vif0_mark: Vif0Mark,
        _reserved4: [u8; 0x0c],
        vif0_cycle: Vif0Cycle,
        _reserved5: [u8; 0x0c],
        vif0_mode: Vif0Mode,
        _reserved6: [u8; 0x0c],
        vif0_num: Vif0Num,
        _reserved7: [u8; 0x0c],
        vif0_mask: Vif0Mask,
        _reserved8: [u8; 0x0c],
        vif0_code: Vif0Code,
        _reserved9: [u8; 0x0c],
        vif0_itops: Vif0Itops,
        _reserved10: [u8; 0x3c],
        vif0_itop: Vif0Itop,
        _reserved11: [u8; 0x2c],
        vif0_r0: Vif0R0,
        _reserved12: [u8; 0x0c],
        vif0_r1: Vif0R1,
        _reserved13: [u8; 0x0c],
        vif0_r2: Vif0R2,
        _reserved14: [u8; 0x0c],
        vif0_r3: Vif0R3,
        _reserved15: [u8; 0x0c],
        vif0_c0: Vif0C0,
        _reserved16: [u8; 0x0c],
        vif0_c1: Vif0C1,
        _reserved17: [u8; 0x0c],
        vif0_c2: Vif0C2,
        _reserved18: [u8; 0x0c],
        vif0_c3: Vif0C3,
        _reserved19: [u8; 0x028c],
        vif1_stat: Vif1Stat,
        _reserved20: [u8; 0x0c],
        vif1_fbrst: Vif1Fbrst,
        _reserved21: [u8; 0x0c],
        vif1_err: Vif1Err,
        _reserved22: [u8; 0x0c],
        vif1_mark: Vif1Mark,
        _reserved23: [u8; 0x0c],
        vif1_cycle: Vif1Cycle,
        _reserved24: [u8; 0x0c],
        vif1_mode: Vif1Mode,
        _reserved25: [u8; 0x0c],
        vif1_num: Vif1Num,
        _reserved26: [u8; 0x0c],
        vif1_mask: Vif1Mask,
        _reserved27: [u8; 0x0c],
        vif1_code: Vif1Code,
        _reserved28: [u8; 0x0c],
        vif1_itops: Vif1Itops,
        _reserved29: [u8; 0x0c],
        vif1_base: Vif1Base,
        _reserved30: [u8; 0x0c],
        vif1_ofst: Vif1Ofst,
        _reserved31: [u8; 0x0c],
        vif1_tops: Vif1Tops,
        _reserved32: [u8; 0x0c],
        vif1_itop: Vif1Itop,
        _reserved33: [u8; 0x2c],
        vif1_r0: Vif1R0,
        _reserved34: [u8; 0x0c],
        vif1_r1: Vif1R1,
        _reserved35: [u8; 0x0c],
        vif1_r2: Vif1R2,
        _reserved36: [u8; 0x0c],
        vif1_r3: Vif1R3,
        _reserved37: [u8; 0x0c],
        vif1_c0: Vif1C0,
        _reserved38: [u8; 0x0c],
        vif1_c1: Vif1C1,
        _reserved39: [u8; 0x0c],
        vif1_c2: Vif1C2,
        _reserved40: [u8; 0x0c],
        vif1_c3: Vif1C3,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Status"]
        #[inline(always)]
        pub const fn vif0_stat(&self) -> &Vif0Stat {
            &self.vif0_stat
        }
        #[doc = "0x10 - Operation control"]
        #[inline(always)]
        pub const fn vif0_fbrst(&self) -> &Vif0Fbrst {
            &self.vif0_fbrst
        }
        #[doc = "0x20 - Error status"]
        #[inline(always)]
        pub const fn vif0_err(&self) -> &Vif0Err {
            &self.vif0_err
        }
        #[doc = "0x30 - Mark value"]
        #[inline(always)]
        pub const fn vif0_mark(&self) -> &Vif0Mark {
            &self.vif0_mark
        }
        #[doc = "0x40 - Data write cycle"]
        #[inline(always)]
        pub const fn vif0_cycle(&self) -> &Vif0Cycle {
            &self.vif0_cycle
        }
        #[doc = "0x50 - ADD mode"]
        #[inline(always)]
        pub const fn vif0_mode(&self) -> &Vif0Mode {
            &self.vif0_mode
        }
        #[doc = "0x60 - Amount of non-transferred data"]
        #[inline(always)]
        pub const fn vif0_num(&self) -> &Vif0Num {
            &self.vif0_num
        }
        #[doc = "0x70 - Write mask pattern"]
        #[inline(always)]
        pub const fn vif0_mask(&self) -> &Vif0Mask {
            &self.vif0_mask
        }
        #[doc = "0x80 - Last processed VIFcode"]
        #[inline(always)]
        pub const fn vif0_code(&self) -> &Vif0Code {
            &self.vif0_code
        }
        #[doc = "0x90 - Next ITOP value"]
        #[inline(always)]
        pub const fn vif0_itops(&self) -> &Vif0Itops {
            &self.vif0_itops
        }
        #[doc = "0xd0 - ITOP value"]
        #[inline(always)]
        pub const fn vif0_itop(&self) -> &Vif0Itop {
            &self.vif0_itop
        }
        #[doc = "0x100 - Filling data R0 (Row register)"]
        #[inline(always)]
        pub const fn vif0_r0(&self) -> &Vif0R0 {
            &self.vif0_r0
        }
        #[doc = "0x110 - Filling data R1 (Row register)"]
        #[inline(always)]
        pub const fn vif0_r1(&self) -> &Vif0R1 {
            &self.vif0_r1
        }
        #[doc = "0x120 - Filling data R2 (Row register)"]
        #[inline(always)]
        pub const fn vif0_r2(&self) -> &Vif0R2 {
            &self.vif0_r2
        }
        #[doc = "0x130 - Filling data R3 (Row register)"]
        #[inline(always)]
        pub const fn vif0_r3(&self) -> &Vif0R3 {
            &self.vif0_r3
        }
        #[doc = "0x140 - Filling data C0 (Col register)"]
        #[inline(always)]
        pub const fn vif0_c0(&self) -> &Vif0C0 {
            &self.vif0_c0
        }
        #[doc = "0x150 - Filling data C1 (Col register)"]
        #[inline(always)]
        pub const fn vif0_c1(&self) -> &Vif0C1 {
            &self.vif0_c1
        }
        #[doc = "0x160 - Filling data C2 (Col register)"]
        #[inline(always)]
        pub const fn vif0_c2(&self) -> &Vif0C2 {
            &self.vif0_c2
        }
        #[doc = "0x170 - Filling data C3 (Col register)"]
        #[inline(always)]
        pub const fn vif0_c3(&self) -> &Vif0C3 {
            &self.vif0_c3
        }
        #[doc = "0x400 - Status"]
        #[inline(always)]
        pub const fn vif1_stat(&self) -> &Vif1Stat {
            &self.vif1_stat
        }
        #[doc = "0x410 - Operation control"]
        #[inline(always)]
        pub const fn vif1_fbrst(&self) -> &Vif1Fbrst {
            &self.vif1_fbrst
        }
        #[doc = "0x420 - Error status"]
        #[inline(always)]
        pub const fn vif1_err(&self) -> &Vif1Err {
            &self.vif1_err
        }
        #[doc = "0x430 - Mark value"]
        #[inline(always)]
        pub const fn vif1_mark(&self) -> &Vif1Mark {
            &self.vif1_mark
        }
        #[doc = "0x440 - Data write cycle"]
        #[inline(always)]
        pub const fn vif1_cycle(&self) -> &Vif1Cycle {
            &self.vif1_cycle
        }
        #[doc = "0x450 - ADD mode"]
        #[inline(always)]
        pub const fn vif1_mode(&self) -> &Vif1Mode {
            &self.vif1_mode
        }
        #[doc = "0x460 - Amount of non-transferred data"]
        #[inline(always)]
        pub const fn vif1_num(&self) -> &Vif1Num {
            &self.vif1_num
        }
        #[doc = "0x470 - Write mask pattern"]
        #[inline(always)]
        pub const fn vif1_mask(&self) -> &Vif1Mask {
            &self.vif1_mask
        }
        #[doc = "0x480 - Last processed VIFcode"]
        #[inline(always)]
        pub const fn vif1_code(&self) -> &Vif1Code {
            &self.vif1_code
        }
        #[doc = "0x490 - Next ITOP value"]
        #[inline(always)]
        pub const fn vif1_itops(&self) -> &Vif1Itops {
            &self.vif1_itops
        }
        #[doc = "0x4a0 - Base address of double buffer"]
        #[inline(always)]
        pub const fn vif1_base(&self) -> &Vif1Base {
            &self.vif1_base
        }
        #[doc = "0x4b0 - Offset of double buffer"]
        #[inline(always)]
        pub const fn vif1_ofst(&self) -> &Vif1Ofst {
            &self.vif1_ofst
        }
        #[doc = "0x4c0 - Next TOP value/data write address"]
        #[inline(always)]
        pub const fn vif1_tops(&self) -> &Vif1Tops {
            &self.vif1_tops
        }
        #[doc = "0x4d0 - ITOP value"]
        #[inline(always)]
        pub const fn vif1_itop(&self) -> &Vif1Itop {
            &self.vif1_itop
        }
        #[doc = "0x500 - Filling data R0 (Row register)"]
        #[inline(always)]
        pub const fn vif1_r0(&self) -> &Vif1R0 {
            &self.vif1_r0
        }
        #[doc = "0x510 - Filling data R1 (Row register)"]
        #[inline(always)]
        pub const fn vif1_r1(&self) -> &Vif1R1 {
            &self.vif1_r1
        }
        #[doc = "0x520 - Filling data R2 (Row register)"]
        #[inline(always)]
        pub const fn vif1_r2(&self) -> &Vif1R2 {
            &self.vif1_r2
        }
        #[doc = "0x530 - Filling data R3 (Row register)"]
        #[inline(always)]
        pub const fn vif1_r3(&self) -> &Vif1R3 {
            &self.vif1_r3
        }
        #[doc = "0x540 - Filling data C0 (Col register)"]
        #[inline(always)]
        pub const fn vif1_c0(&self) -> &Vif1C0 {
            &self.vif1_c0
        }
        #[doc = "0x550 - Filling data C1 (Col register)"]
        #[inline(always)]
        pub const fn vif1_c1(&self) -> &Vif1C1 {
            &self.vif1_c1
        }
        #[doc = "0x560 - Filling data C2 (Col register)"]
        #[inline(always)]
        pub const fn vif1_c2(&self) -> &Vif1C2 {
            &self.vif1_c2
        }
        #[doc = "0x570 - Filling data C3 (Col register)"]
        #[inline(always)]
        pub const fn vif1_c3(&self) -> &Vif1C3 {
            &self.vif1_c3
        }
    }
    #[doc = "VIF0_STAT (r) register accessor: Status\n\nYou can [`read`](crate::Reg::read) this register and get [`vif0_stat::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif0_stat`] module"]
    #[doc(alias = "VIF0_STAT")]
    pub type Vif0Stat = crate::Reg<vif0_stat::Vif0StatSpec>;
    #[doc = "Status"]
    pub mod vif0_stat {
        #[doc = "Register `VIF0_STAT` reader"]
        pub type R = crate::R<Vif0StatSpec>;
        #[doc = "VIF Status\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Vps {
            #[doc = "0: Idle"]
            Idle = 0,
            #[doc = "1: Waits for data following the VIFcode"]
            Waiting = 1,
            #[doc = "2: Decoding the VIFcode"]
            Decoding = 2,
            #[doc = "3: Decompressing/Transferring the data following the VIFcode"]
            Processing = 3,
        }
        impl From<Vps> for u8 {
            #[inline(always)]
            fn from(variant: Vps) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Vps {
            type Ux = u8;
        }
        impl crate::IsEnum for Vps {}
        #[doc = "Field `VPS` reader - VIF Status"]
        pub type VpsR = crate::FieldReader<Vps>;
        impl VpsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vps {
                match self.bits {
                    0 => Vps::Idle,
                    1 => Vps::Waiting,
                    2 => Vps::Decoding,
                    3 => Vps::Processing,
                    _ => unreachable!(),
                }
            }
            #[doc = "Idle"]
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == Vps::Idle
            }
            #[doc = "Waits for data following the VIFcode"]
            #[inline(always)]
            pub fn is_waiting(&self) -> bool {
                *self == Vps::Waiting
            }
            #[doc = "Decoding the VIFcode"]
            #[inline(always)]
            pub fn is_decoding(&self) -> bool {
                *self == Vps::Decoding
            }
            #[doc = "Decompressing/Transferring the data following the VIFcode"]
            #[inline(always)]
            pub fn is_processing(&self) -> bool {
                *self == Vps::Processing
            }
        }
        #[doc = "VIF E-bit Wait\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vew {
            #[doc = "0: Not-wait"]
            Notwait = 0,
            #[doc = "1: Wait (VU is executing a microprogram)"]
            Wait = 1,
        }
        impl From<Vew> for bool {
            #[inline(always)]
            fn from(variant: Vew) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VEW` reader - VIF E-bit Wait"]
        pub type VewR = crate::BitReader<Vew>;
        impl VewR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vew {
                match self.bits {
                    false => Vew::Notwait,
                    true => Vew::Wait,
                }
            }
            #[doc = "Not-wait"]
            #[inline(always)]
            pub fn is_notwait(&self) -> bool {
                *self == Vew::Notwait
            }
            #[doc = "Wait (VU is executing a microprogram)"]
            #[inline(always)]
            pub fn is_wait(&self) -> bool {
                *self == Vew::Wait
            }
        }
        #[doc = "VIF MARK detect\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Mrk {
            #[doc = "0: Not-detect"]
            Notdetect = 0,
            #[doc = "1: Detect"]
            Detect = 1,
        }
        impl From<Mrk> for bool {
            #[inline(always)]
            fn from(variant: Mrk) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MRK` reader - VIF MARK detect"]
        pub type MrkR = crate::BitReader<Mrk>;
        impl MrkR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Mrk {
                match self.bits {
                    false => Mrk::Notdetect,
                    true => Mrk::Detect,
                }
            }
            #[doc = "Not-detect"]
            #[inline(always)]
            pub fn is_notdetect(&self) -> bool {
                *self == Mrk::Notdetect
            }
            #[doc = "Detect"]
            #[inline(always)]
            pub fn is_detect(&self) -> bool {
                *self == Mrk::Detect
            }
        }
        #[doc = "Stop by STOP\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vss {
            #[doc = "0: Not-stall"]
            Notstall = 0,
            #[doc = "1: Stall"]
            Stall = 1,
        }
        impl From<Vss> for bool {
            #[inline(always)]
            fn from(variant: Vss) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VSS` reader - Stop by STOP"]
        pub type VssR = crate::BitReader<Vss>;
        impl VssR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vss {
                match self.bits {
                    false => Vss::Notstall,
                    true => Vss::Stall,
                }
            }
            #[doc = "Not-stall"]
            #[inline(always)]
            pub fn is_notstall(&self) -> bool {
                *self == Vss::Notstall
            }
            #[doc = "Stall"]
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == Vss::Stall
            }
        }
        #[doc = "Stop by ForceBreak\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vfs {
            #[doc = "0: Not-stall"]
            Notstall = 0,
            #[doc = "1: Stall"]
            Stall = 1,
        }
        impl From<Vfs> for bool {
            #[inline(always)]
            fn from(variant: Vfs) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VFS` reader - Stop by ForceBreak"]
        pub type VfsR = crate::BitReader<Vfs>;
        impl VfsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vfs {
                match self.bits {
                    false => Vfs::Notstall,
                    true => Vfs::Stall,
                }
            }
            #[doc = "Not-stall"]
            #[inline(always)]
            pub fn is_notstall(&self) -> bool {
                *self == Vfs::Notstall
            }
            #[doc = "Stall"]
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == Vfs::Stall
            }
        }
        #[doc = "VIF interrupt stall\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vis {
            #[doc = "0: Not-stall"]
            Notstall = 0,
            #[doc = "1: Stall"]
            Stall = 1,
        }
        impl From<Vis> for bool {
            #[inline(always)]
            fn from(variant: Vis) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VIS` reader - VIF interrupt stall"]
        pub type VisR = crate::BitReader<Vis>;
        impl VisR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vis {
                match self.bits {
                    false => Vis::Notstall,
                    true => Vis::Stall,
                }
            }
            #[doc = "Not-stall"]
            #[inline(always)]
            pub fn is_notstall(&self) -> bool {
                *self == Vis::Notstall
            }
            #[doc = "Stall"]
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == Vis::Stall
            }
        }
        #[doc = "Interrupt by the i bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Int {
            #[doc = "0: Not-detect"]
            Notdetect = 0,
            #[doc = "1: Detect"]
            Detect = 1,
        }
        impl From<Int> for bool {
            #[inline(always)]
            fn from(variant: Int) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `INT` reader - Interrupt by the i bit"]
        pub type IntR = crate::BitReader<Int>;
        impl IntR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Int {
                match self.bits {
                    false => Int::Notdetect,
                    true => Int::Detect,
                }
            }
            #[doc = "Not-detect"]
            #[inline(always)]
            pub fn is_notdetect(&self) -> bool {
                *self == Int::Notdetect
            }
            #[doc = "Detect"]
            #[inline(always)]
            pub fn is_detect(&self) -> bool {
                *self == Int::Detect
            }
        }
        #[doc = "DMAtag Mismatch error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Er0 {
            #[doc = "0: No error"]
            Noerror = 0,
            #[doc = "1: Error (DMAtag has been detected in the VIF packet.)"]
            Error = 1,
        }
        impl From<Er0> for bool {
            #[inline(always)]
            fn from(variant: Er0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ER0` reader - DMAtag Mismatch error"]
        pub type Er0R = crate::BitReader<Er0>;
        impl Er0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Er0 {
                match self.bits {
                    false => Er0::Noerror,
                    true => Er0::Error,
                }
            }
            #[doc = "No error"]
            #[inline(always)]
            pub fn is_noerror(&self) -> bool {
                *self == Er0::Noerror
            }
            #[doc = "Error (DMAtag has been detected in the VIF packet.)"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == Er0::Error
            }
        }
        #[doc = "VIFcode error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Er1 {
            #[doc = "0: Not-detect"]
            Notdetect = 0,
            #[doc = "1: Detect (Undefined VIFcode has been detected.)"]
            Detect = 1,
        }
        impl From<Er1> for bool {
            #[inline(always)]
            fn from(variant: Er1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ER1` reader - VIFcode error"]
        pub type Er1R = crate::BitReader<Er1>;
        impl Er1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Er1 {
                match self.bits {
                    false => Er1::Notdetect,
                    true => Er1::Detect,
                }
            }
            #[doc = "Not-detect"]
            #[inline(always)]
            pub fn is_notdetect(&self) -> bool {
                *self == Er1::Notdetect
            }
            #[doc = "Detect (Undefined VIFcode has been detected.)"]
            #[inline(always)]
            pub fn is_detect(&self) -> bool {
                *self == Er1::Detect
            }
        }
        #[doc = "Field `FQC` reader - Amount of effective data in the VIF-FIFO"]
        pub type FqcR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:1 - VIF Status"]
            #[inline(always)]
            pub fn vps(&self) -> VpsR {
                VpsR::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - VIF E-bit Wait"]
            #[inline(always)]
            pub fn vew(&self) -> VewR {
                VewR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 6 - VIF MARK detect"]
            #[inline(always)]
            pub fn mrk(&self) -> MrkR {
                MrkR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 8 - Stop by STOP"]
            #[inline(always)]
            pub fn vss(&self) -> VssR {
                VssR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Stop by ForceBreak"]
            #[inline(always)]
            pub fn vfs(&self) -> VfsR {
                VfsR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - VIF interrupt stall"]
            #[inline(always)]
            pub fn vis(&self) -> VisR {
                VisR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Interrupt by the i bit"]
            #[inline(always)]
            pub fn int(&self) -> IntR {
                IntR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - DMAtag Mismatch error"]
            #[inline(always)]
            pub fn er0(&self) -> Er0R {
                Er0R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - VIFcode error"]
            #[inline(always)]
            pub fn er1(&self) -> Er1R {
                Er1R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bits 24:27 - Amount of effective data in the VIF-FIFO"]
            #[inline(always)]
            pub fn fqc(&self) -> FqcR {
                FqcR::new(((self.bits >> 24) & 0x0f) as u8)
            }
        }
        #[doc = "Status\n\nYou can [`read`](crate::Reg::read) this register and get [`vif0_stat::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif0StatSpec;
        impl crate::RegisterSpec for Vif0StatSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif0_stat::R`](R) reader structure"]
        impl crate::Readable for Vif0StatSpec {}
        #[doc = "`reset()` method sets VIF0_STAT to value 0"]
        impl crate::Resettable for Vif0StatSpec {}
    }
    pub use vif1_c0 as vif0_c0;
    pub use vif1_c0 as vif0_c1;
    pub use vif1_c0 as vif0_c2;
    pub use vif1_c0 as vif0_c3;
    pub use vif1_code as vif0_code;
    pub use vif1_cycle as vif0_cycle;
    pub use vif1_err as vif0_err;
    pub use vif1_fbrst as vif0_fbrst;
    pub use vif1_itop as vif0_itop;
    pub use vif1_itops as vif0_itops;
    pub use vif1_mark as vif0_mark;
    pub use vif1_mask as vif0_mask;
    pub use vif1_mode as vif0_mode;
    pub use vif1_num as vif0_num;
    pub use vif1_r0 as vif0_r0;
    pub use vif1_r0 as vif0_r1;
    pub use vif1_r0 as vif0_r2;
    pub use vif1_r0 as vif0_r3;
    pub use Vif1C0 as Vif0C0;
    pub use Vif1C0 as Vif0C1;
    pub use Vif1C0 as Vif0C2;
    pub use Vif1C0 as Vif0C3;
    pub use Vif1Code as Vif0Code;
    pub use Vif1Cycle as Vif0Cycle;
    pub use Vif1Err as Vif0Err;
    pub use Vif1Fbrst as Vif0Fbrst;
    pub use Vif1Itop as Vif0Itop;
    pub use Vif1Itops as Vif0Itops;
    pub use Vif1Mark as Vif0Mark;
    pub use Vif1Mask as Vif0Mask;
    pub use Vif1Mode as Vif0Mode;
    pub use Vif1Num as Vif0Num;
    pub use Vif1R0 as Vif0R0;
    pub use Vif1R0 as Vif0R1;
    pub use Vif1R0 as Vif0R2;
    pub use Vif1R0 as Vif0R3;
    #[doc = "VIF1_STAT (rw) register accessor: Status\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_stat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vif1_stat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_stat`] module"]
    #[doc(alias = "VIF1_STAT")]
    pub type Vif1Stat = crate::Reg<vif1_stat::Vif1StatSpec>;
    #[doc = "Status"]
    pub mod vif1_stat {
        #[doc = "Register `VIF1_STAT` reader"]
        pub type R = crate::R<Vif1StatSpec>;
        #[doc = "Register `VIF1_STAT` writer"]
        pub type W = crate::W<Vif1StatSpec>;
        #[doc = "VIF Status\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Vps {
            #[doc = "0: Idle"]
            Idle = 0,
            #[doc = "1: Waits for data following the VIFcode"]
            Waiting = 1,
            #[doc = "2: Decoding the VIFcode"]
            Decoding = 2,
            #[doc = "3: Decompressing/Transferring the data following the VIFcode"]
            Processing = 3,
        }
        impl From<Vps> for u8 {
            #[inline(always)]
            fn from(variant: Vps) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Vps {
            type Ux = u8;
        }
        impl crate::IsEnum for Vps {}
        #[doc = "Field `VPS` reader - VIF Status"]
        pub type VpsR = crate::FieldReader<Vps>;
        impl VpsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vps {
                match self.bits {
                    0 => Vps::Idle,
                    1 => Vps::Waiting,
                    2 => Vps::Decoding,
                    3 => Vps::Processing,
                    _ => unreachable!(),
                }
            }
            #[doc = "Idle"]
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == Vps::Idle
            }
            #[doc = "Waits for data following the VIFcode"]
            #[inline(always)]
            pub fn is_waiting(&self) -> bool {
                *self == Vps::Waiting
            }
            #[doc = "Decoding the VIFcode"]
            #[inline(always)]
            pub fn is_decoding(&self) -> bool {
                *self == Vps::Decoding
            }
            #[doc = "Decompressing/Transferring the data following the VIFcode"]
            #[inline(always)]
            pub fn is_processing(&self) -> bool {
                *self == Vps::Processing
            }
        }
        #[doc = "VIF E-bit Wait\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vew {
            #[doc = "0: Not-wait"]
            Notwait = 0,
            #[doc = "1: Wait (VU is executing a microprogram)"]
            Wait = 1,
        }
        impl From<Vew> for bool {
            #[inline(always)]
            fn from(variant: Vew) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VEW` reader - VIF E-bit Wait"]
        pub type VewR = crate::BitReader<Vew>;
        impl VewR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vew {
                match self.bits {
                    false => Vew::Notwait,
                    true => Vew::Wait,
                }
            }
            #[doc = "Not-wait"]
            #[inline(always)]
            pub fn is_notwait(&self) -> bool {
                *self == Vew::Notwait
            }
            #[doc = "Wait (VU is executing a microprogram)"]
            #[inline(always)]
            pub fn is_wait(&self) -> bool {
                *self == Vew::Wait
            }
        }
        #[doc = "Status waiting for end of GIF transfer\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vgw {
            #[doc = "0: Not-wait"]
            Notwait = 0,
            #[doc = "1: Wait (Stopped status with one of FLUSH/FLUSHA, DIRECT/DIRECTHL and MSCALF commands when GIF != idle.)"]
            Wait = 1,
        }
        impl From<Vgw> for bool {
            #[inline(always)]
            fn from(variant: Vgw) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VGW` reader - Status waiting for end of GIF transfer"]
        pub type VgwR = crate::BitReader<Vgw>;
        impl VgwR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vgw {
                match self.bits {
                    false => Vgw::Notwait,
                    true => Vgw::Wait,
                }
            }
            #[doc = "Not-wait"]
            #[inline(always)]
            pub fn is_notwait(&self) -> bool {
                *self == Vgw::Notwait
            }
            #[doc = "Wait (Stopped status with one of FLUSH/FLUSHA, DIRECT/DIRECTHL and MSCALF commands when GIF != idle.)"]
            #[inline(always)]
            pub fn is_wait(&self) -> bool {
                *self == Vgw::Wait
            }
        }
        #[doc = "VIF MARK detect\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Mrk {
            #[doc = "0: Not-detect"]
            Notdetect = 0,
            #[doc = "1: Detect"]
            Detect = 1,
        }
        impl From<Mrk> for bool {
            #[inline(always)]
            fn from(variant: Mrk) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MRK` reader - VIF MARK detect"]
        pub type MrkR = crate::BitReader<Mrk>;
        impl MrkR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Mrk {
                match self.bits {
                    false => Mrk::Notdetect,
                    true => Mrk::Detect,
                }
            }
            #[doc = "Not-detect"]
            #[inline(always)]
            pub fn is_notdetect(&self) -> bool {
                *self == Mrk::Notdetect
            }
            #[doc = "Detect"]
            #[inline(always)]
            pub fn is_detect(&self) -> bool {
                *self == Mrk::Detect
            }
        }
        #[doc = "Double buffer flag. Cleared to 0 by OFFSET and reversed by MSCAL/MSCALF/MSCNT.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Dbf {
            #[doc = "0: TOPS=BASE"]
            Base = 0,
            #[doc = "1: TOPS=BASE+OFFSET"]
            Baseplusoffset = 1,
        }
        impl From<Dbf> for bool {
            #[inline(always)]
            fn from(variant: Dbf) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DBF` reader - Double buffer flag. Cleared to 0 by OFFSET and reversed by MSCAL/MSCALF/MSCNT."]
        pub type DbfR = crate::BitReader<Dbf>;
        impl DbfR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Dbf {
                match self.bits {
                    false => Dbf::Base,
                    true => Dbf::Baseplusoffset,
                }
            }
            #[doc = "TOPS=BASE"]
            #[inline(always)]
            pub fn is_base(&self) -> bool {
                *self == Dbf::Base
            }
            #[doc = "TOPS=BASE+OFFSET"]
            #[inline(always)]
            pub fn is_baseplusoffset(&self) -> bool {
                *self == Dbf::Baseplusoffset
            }
        }
        #[doc = "Stop by STOP\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vss {
            #[doc = "0: Not-stall"]
            Notstall = 0,
            #[doc = "1: Stall"]
            Stall = 1,
        }
        impl From<Vss> for bool {
            #[inline(always)]
            fn from(variant: Vss) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VSS` reader - Stop by STOP"]
        pub type VssR = crate::BitReader<Vss>;
        impl VssR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vss {
                match self.bits {
                    false => Vss::Notstall,
                    true => Vss::Stall,
                }
            }
            #[doc = "Not-stall"]
            #[inline(always)]
            pub fn is_notstall(&self) -> bool {
                *self == Vss::Notstall
            }
            #[doc = "Stall"]
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == Vss::Stall
            }
        }
        #[doc = "Stop by ForceBreak\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vfs {
            #[doc = "0: Not-stall"]
            Notstall = 0,
            #[doc = "1: Stall"]
            Stall = 1,
        }
        impl From<Vfs> for bool {
            #[inline(always)]
            fn from(variant: Vfs) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VFS` reader - Stop by ForceBreak"]
        pub type VfsR = crate::BitReader<Vfs>;
        impl VfsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vfs {
                match self.bits {
                    false => Vfs::Notstall,
                    true => Vfs::Stall,
                }
            }
            #[doc = "Not-stall"]
            #[inline(always)]
            pub fn is_notstall(&self) -> bool {
                *self == Vfs::Notstall
            }
            #[doc = "Stall"]
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == Vfs::Stall
            }
        }
        #[doc = "VIF interrupt stall\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vis {
            #[doc = "0: Not-stall"]
            Notstall = 0,
            #[doc = "1: Stall"]
            Stall = 1,
        }
        impl From<Vis> for bool {
            #[inline(always)]
            fn from(variant: Vis) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VIS` reader - VIF interrupt stall"]
        pub type VisR = crate::BitReader<Vis>;
        impl VisR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vis {
                match self.bits {
                    false => Vis::Notstall,
                    true => Vis::Stall,
                }
            }
            #[doc = "Not-stall"]
            #[inline(always)]
            pub fn is_notstall(&self) -> bool {
                *self == Vis::Notstall
            }
            #[doc = "Stall"]
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == Vis::Stall
            }
        }
        #[doc = "Interrupt by the i bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Int {
            #[doc = "0: Not-detect"]
            Notdetect = 0,
            #[doc = "1: Detect"]
            Detect = 1,
        }
        impl From<Int> for bool {
            #[inline(always)]
            fn from(variant: Int) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `INT` reader - Interrupt by the i bit"]
        pub type IntR = crate::BitReader<Int>;
        impl IntR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Int {
                match self.bits {
                    false => Int::Notdetect,
                    true => Int::Detect,
                }
            }
            #[doc = "Not-detect"]
            #[inline(always)]
            pub fn is_notdetect(&self) -> bool {
                *self == Int::Notdetect
            }
            #[doc = "Detect"]
            #[inline(always)]
            pub fn is_detect(&self) -> bool {
                *self == Int::Detect
            }
        }
        #[doc = "DMAtag Mismatch error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Er0 {
            #[doc = "0: No error"]
            Noerror = 0,
            #[doc = "1: Error (DMAtag has been detected in the VIF packet.)"]
            Error = 1,
        }
        impl From<Er0> for bool {
            #[inline(always)]
            fn from(variant: Er0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ER0` reader - DMAtag Mismatch error"]
        pub type Er0R = crate::BitReader<Er0>;
        impl Er0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Er0 {
                match self.bits {
                    false => Er0::Noerror,
                    true => Er0::Error,
                }
            }
            #[doc = "No error"]
            #[inline(always)]
            pub fn is_noerror(&self) -> bool {
                *self == Er0::Noerror
            }
            #[doc = "Error (DMAtag has been detected in the VIF packet.)"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == Er0::Error
            }
        }
        #[doc = "VIFcode error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Er1 {
            #[doc = "0: Not-detect"]
            Notdetect = 0,
            #[doc = "1: Detect (Undefined VIFcode has been detected.)"]
            Detect = 1,
        }
        impl From<Er1> for bool {
            #[inline(always)]
            fn from(variant: Er1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ER1` reader - VIFcode error"]
        pub type Er1R = crate::BitReader<Er1>;
        impl Er1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Er1 {
                match self.bits {
                    false => Er1::Notdetect,
                    true => Er1::Detect,
                }
            }
            #[doc = "Not-detect"]
            #[inline(always)]
            pub fn is_notdetect(&self) -> bool {
                *self == Er1::Notdetect
            }
            #[doc = "Detect (Undefined VIFcode has been detected.)"]
            #[inline(always)]
            pub fn is_detect(&self) -> bool {
                *self == Er1::Detect
            }
        }
        #[doc = "VIF-FIFO transfer direction\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Fdr {
            #[doc = "0: Main memory/SPRAM -> VIF"]
            Intovif = 0,
            #[doc = "1: VIF -> Main memory/SPRAM"]
            Fromvif = 1,
        }
        impl From<Fdr> for bool {
            #[inline(always)]
            fn from(variant: Fdr) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `FDR` reader - VIF-FIFO transfer direction"]
        pub type FdrR = crate::BitReader<Fdr>;
        impl FdrR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Fdr {
                match self.bits {
                    false => Fdr::Intovif,
                    true => Fdr::Fromvif,
                }
            }
            #[doc = "Main memory/SPRAM -> VIF"]
            #[inline(always)]
            pub fn is_intovif(&self) -> bool {
                *self == Fdr::Intovif
            }
            #[doc = "VIF -> Main memory/SPRAM"]
            #[inline(always)]
            pub fn is_fromvif(&self) -> bool {
                *self == Fdr::Fromvif
            }
        }
        #[doc = "Field `FDR` writer - VIF-FIFO transfer direction"]
        pub type FdrW<'a, REG> = crate::BitWriter<'a, REG, Fdr>;
        impl<'a, REG> FdrW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Main memory/SPRAM -> VIF"]
            #[inline(always)]
            pub fn intovif(self) -> &'a mut crate::W<REG> {
                self.variant(Fdr::Intovif)
            }
            #[doc = "VIF -> Main memory/SPRAM"]
            #[inline(always)]
            pub fn fromvif(self) -> &'a mut crate::W<REG> {
                self.variant(Fdr::Fromvif)
            }
        }
        #[doc = "Field `FQC` reader - Amount of effective data in the VIF-FIFO"]
        pub type FqcR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:1 - VIF Status"]
            #[inline(always)]
            pub fn vps(&self) -> VpsR {
                VpsR::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - VIF E-bit Wait"]
            #[inline(always)]
            pub fn vew(&self) -> VewR {
                VewR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Status waiting for end of GIF transfer"]
            #[inline(always)]
            pub fn vgw(&self) -> VgwR {
                VgwR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 6 - VIF MARK detect"]
            #[inline(always)]
            pub fn mrk(&self) -> MrkR {
                MrkR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Double buffer flag. Cleared to 0 by OFFSET and reversed by MSCAL/MSCALF/MSCNT."]
            #[inline(always)]
            pub fn dbf(&self) -> DbfR {
                DbfR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Stop by STOP"]
            #[inline(always)]
            pub fn vss(&self) -> VssR {
                VssR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Stop by ForceBreak"]
            #[inline(always)]
            pub fn vfs(&self) -> VfsR {
                VfsR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - VIF interrupt stall"]
            #[inline(always)]
            pub fn vis(&self) -> VisR {
                VisR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Interrupt by the i bit"]
            #[inline(always)]
            pub fn int(&self) -> IntR {
                IntR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - DMAtag Mismatch error"]
            #[inline(always)]
            pub fn er0(&self) -> Er0R {
                Er0R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - VIFcode error"]
            #[inline(always)]
            pub fn er1(&self) -> Er1R {
                Er1R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 23 - VIF-FIFO transfer direction"]
            #[inline(always)]
            pub fn fdr(&self) -> FdrR {
                FdrR::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bits 24:28 - Amount of effective data in the VIF-FIFO"]
            #[inline(always)]
            pub fn fqc(&self) -> FqcR {
                FqcR::new(((self.bits >> 24) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 23 - VIF-FIFO transfer direction"]
            #[inline(always)]
            pub fn fdr(&mut self) -> FdrW<Vif1StatSpec> {
                FdrW::new(self, 23)
            }
        }
        #[doc = "Status\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_stat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vif1_stat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1StatSpec;
        impl crate::RegisterSpec for Vif1StatSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_stat::R`](R) reader structure"]
        impl crate::Readable for Vif1StatSpec {}
        #[doc = "`write(|w| ..)` method takes [`vif1_stat::W`](W) writer structure"]
        impl crate::Writable for Vif1StatSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets VIF1_STAT to value 0"]
        impl crate::Resettable for Vif1StatSpec {}
    }
    #[doc = "VIF1_FBRST (w) register accessor: Operation control\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vif1_fbrst::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_fbrst`] module"]
    #[doc(alias = "VIF1_FBRST")]
    pub type Vif1Fbrst = crate::Reg<vif1_fbrst::Vif1FbrstSpec>;
    #[doc = "Operation control"]
    pub mod vif1_fbrst {
        #[doc = "Register `VIF1_FBRST` writer"]
        pub type W = crate::W<Vif1FbrstSpec>;
        #[doc = "Field `RST` writer - Reset. Resets the whole VIF (including VIF FIFO) when 1 is written."]
        pub type RstW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FBK` writer - ForceBreak. Causes a ForceBreak to the VIF when 1 is written. (Stall occurrence)"]
        pub type FbkW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STP` writer - Stop. Stops after end of VIDcode in process when 1 is written. (Stall occurrence)"]
        pub type StpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STC` writer - Stall Cancel. Cancels the VIF stall and clears the VSS, VFS, VIS, INT, ER0 and ER1 of the VIF_STAT register to 0 when 1 is written"]
        pub type StcW<'a, REG> = crate::BitWriter<'a, REG>;
        impl W {
            #[doc = "Bit 0 - Reset. Resets the whole VIF (including VIF FIFO) when 1 is written."]
            #[inline(always)]
            pub fn rst(&mut self) -> RstW<Vif1FbrstSpec> {
                RstW::new(self, 0)
            }
            #[doc = "Bit 1 - ForceBreak. Causes a ForceBreak to the VIF when 1 is written. (Stall occurrence)"]
            #[inline(always)]
            pub fn fbk(&mut self) -> FbkW<Vif1FbrstSpec> {
                FbkW::new(self, 1)
            }
            #[doc = "Bit 2 - Stop. Stops after end of VIDcode in process when 1 is written. (Stall occurrence)"]
            #[inline(always)]
            pub fn stp(&mut self) -> StpW<Vif1FbrstSpec> {
                StpW::new(self, 2)
            }
            #[doc = "Bit 3 - Stall Cancel. Cancels the VIF stall and clears the VSS, VFS, VIS, INT, ER0 and ER1 of the VIF_STAT register to 0 when 1 is written"]
            #[inline(always)]
            pub fn stc(&mut self) -> StcW<Vif1FbrstSpec> {
                StcW::new(self, 3)
            }
        }
        #[doc = "Operation control\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vif1_fbrst::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1FbrstSpec;
        impl crate::RegisterSpec for Vif1FbrstSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`vif1_fbrst::W`](W) writer structure"]
        impl crate::Writable for Vif1FbrstSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets VIF1_FBRST to value 0"]
        impl crate::Resettable for Vif1FbrstSpec {}
    }
    #[doc = "VIF1_ERR (rw) register accessor: Error status\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_err::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vif1_err::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_err`] module"]
    #[doc(alias = "VIF1_ERR")]
    pub type Vif1Err = crate::Reg<vif1_err::Vif1ErrSpec>;
    #[doc = "Error status"]
    pub mod vif1_err {
        #[doc = "Register `VIF1_ERR` reader"]
        pub type R = crate::R<Vif1ErrSpec>;
        #[doc = "Register `VIF1_ERR` writer"]
        pub type W = crate::W<Vif1ErrSpec>;
        #[doc = "Masks an interrupt by the i bit of the VIFcode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Mii {
            #[doc = "0: Unmask (i bit interrupt enable)"]
            Unmask = 0,
            #[doc = "1: Mask (i bit interrupt disable)"]
            Mask = 1,
        }
        impl From<Mii> for bool {
            #[inline(always)]
            fn from(variant: Mii) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MII` reader - Masks an interrupt by the i bit of the VIFcode"]
        pub type MiiR = crate::BitReader<Mii>;
        impl MiiR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Mii {
                match self.bits {
                    false => Mii::Unmask,
                    true => Mii::Mask,
                }
            }
            #[doc = "Unmask (i bit interrupt enable)"]
            #[inline(always)]
            pub fn is_unmask(&self) -> bool {
                *self == Mii::Unmask
            }
            #[doc = "Mask (i bit interrupt disable)"]
            #[inline(always)]
            pub fn is_mask(&self) -> bool {
                *self == Mii::Mask
            }
        }
        #[doc = "Field `MII` writer - Masks an interrupt by the i bit of the VIFcode"]
        pub type MiiW<'a, REG> = crate::BitWriter<'a, REG, Mii>;
        impl<'a, REG> MiiW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unmask (i bit interrupt enable)"]
            #[inline(always)]
            pub fn unmask(self) -> &'a mut crate::W<REG> {
                self.variant(Mii::Unmask)
            }
            #[doc = "Mask (i bit interrupt disable)"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut crate::W<REG> {
                self.variant(Mii::Mask)
            }
        }
        #[doc = "DMAtag Mismatch error mask\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Me0 {
            #[doc = "0: Unmask (stalls when an error occurs.)"]
            Unmask = 0,
            #[doc = "1: Mask (ignores a DMAtag Mismatch error.)"]
            Mask = 1,
        }
        impl From<Me0> for bool {
            #[inline(always)]
            fn from(variant: Me0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ME0` reader - DMAtag Mismatch error mask"]
        pub type Me0R = crate::BitReader<Me0>;
        impl Me0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Me0 {
                match self.bits {
                    false => Me0::Unmask,
                    true => Me0::Mask,
                }
            }
            #[doc = "Unmask (stalls when an error occurs.)"]
            #[inline(always)]
            pub fn is_unmask(&self) -> bool {
                *self == Me0::Unmask
            }
            #[doc = "Mask (ignores a DMAtag Mismatch error.)"]
            #[inline(always)]
            pub fn is_mask(&self) -> bool {
                *self == Me0::Mask
            }
        }
        #[doc = "Field `ME0` writer - DMAtag Mismatch error mask"]
        pub type Me0W<'a, REG> = crate::BitWriter<'a, REG, Me0>;
        impl<'a, REG> Me0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unmask (stalls when an error occurs.)"]
            #[inline(always)]
            pub fn unmask(self) -> &'a mut crate::W<REG> {
                self.variant(Me0::Unmask)
            }
            #[doc = "Mask (ignores a DMAtag Mismatch error.)"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut crate::W<REG> {
                self.variant(Me0::Mask)
            }
        }
        #[doc = "VIFcode error mask\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Me1 {
            #[doc = "0: Unmask (stalls when an error occurs.)"]
            Unmask = 0,
            #[doc = "1: Mask (considered as VIFcode NOP)"]
            Mask = 1,
        }
        impl From<Me1> for bool {
            #[inline(always)]
            fn from(variant: Me1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `ME1` reader - VIFcode error mask"]
        pub type Me1R = crate::BitReader<Me1>;
        impl Me1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Me1 {
                match self.bits {
                    false => Me1::Unmask,
                    true => Me1::Mask,
                }
            }
            #[doc = "Unmask (stalls when an error occurs.)"]
            #[inline(always)]
            pub fn is_unmask(&self) -> bool {
                *self == Me1::Unmask
            }
            #[doc = "Mask (considered as VIFcode NOP)"]
            #[inline(always)]
            pub fn is_mask(&self) -> bool {
                *self == Me1::Mask
            }
        }
        #[doc = "Field `ME1` writer - VIFcode error mask"]
        pub type Me1W<'a, REG> = crate::BitWriter<'a, REG, Me1>;
        impl<'a, REG> Me1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Unmask (stalls when an error occurs.)"]
            #[inline(always)]
            pub fn unmask(self) -> &'a mut crate::W<REG> {
                self.variant(Me1::Unmask)
            }
            #[doc = "Mask (considered as VIFcode NOP)"]
            #[inline(always)]
            pub fn mask(self) -> &'a mut crate::W<REG> {
                self.variant(Me1::Mask)
            }
        }
        impl R {
            #[doc = "Bit 0 - Masks an interrupt by the i bit of the VIFcode"]
            #[inline(always)]
            pub fn mii(&self) -> MiiR {
                MiiR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - DMAtag Mismatch error mask"]
            #[inline(always)]
            pub fn me0(&self) -> Me0R {
                Me0R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - VIFcode error mask"]
            #[inline(always)]
            pub fn me1(&self) -> Me1R {
                Me1R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Masks an interrupt by the i bit of the VIFcode"]
            #[inline(always)]
            pub fn mii(&mut self) -> MiiW<Vif1ErrSpec> {
                MiiW::new(self, 0)
            }
            #[doc = "Bit 1 - DMAtag Mismatch error mask"]
            #[inline(always)]
            pub fn me0(&mut self) -> Me0W<Vif1ErrSpec> {
                Me0W::new(self, 1)
            }
            #[doc = "Bit 2 - VIFcode error mask"]
            #[inline(always)]
            pub fn me1(&mut self) -> Me1W<Vif1ErrSpec> {
                Me1W::new(self, 2)
            }
        }
        #[doc = "Error status\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_err::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vif1_err::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1ErrSpec;
        impl crate::RegisterSpec for Vif1ErrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_err::R`](R) reader structure"]
        impl crate::Readable for Vif1ErrSpec {}
        #[doc = "`write(|w| ..)` method takes [`vif1_err::W`](W) writer structure"]
        impl crate::Writable for Vif1ErrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets VIF1_ERR to value 0"]
        impl crate::Resettable for Vif1ErrSpec {}
    }
    #[doc = "VIF1_MARK (rw) register accessor: Mark value\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_mark::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vif1_mark::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_mark`] module"]
    #[doc(alias = "VIF1_MARK")]
    pub type Vif1Mark = crate::Reg<vif1_mark::Vif1MarkSpec>;
    #[doc = "Mark value"]
    pub mod vif1_mark {
        #[doc = "Register `VIF1_MARK` reader"]
        pub type R = crate::R<Vif1MarkSpec>;
        #[doc = "Register `VIF1_MARK` writer"]
        pub type W = crate::W<Vif1MarkSpec>;
        #[doc = "Field `MARK` reader - Mark value most recently set"]
        pub type MarkR = crate::FieldReader<u16>;
        #[doc = "Field `MARK` writer - Mark value most recently set"]
        pub type MarkW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - Mark value most recently set"]
            #[inline(always)]
            pub fn mark(&self) -> MarkR {
                MarkR::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Mark value most recently set"]
            #[inline(always)]
            pub fn mark(&mut self) -> MarkW<Vif1MarkSpec> {
                MarkW::new(self, 0)
            }
        }
        #[doc = "Mark value\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_mark::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vif1_mark::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1MarkSpec;
        impl crate::RegisterSpec for Vif1MarkSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_mark::R`](R) reader structure"]
        impl crate::Readable for Vif1MarkSpec {}
        #[doc = "`write(|w| ..)` method takes [`vif1_mark::W`](W) writer structure"]
        impl crate::Writable for Vif1MarkSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets VIF1_MARK to value 0"]
        impl crate::Resettable for Vif1MarkSpec {}
    }
    #[doc = "VIF1_CYCLE (r) register accessor: Data write cycle\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_cycle::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_cycle`] module"]
    #[doc(alias = "VIF1_CYCLE")]
    pub type Vif1Cycle = crate::Reg<vif1_cycle::Vif1CycleSpec>;
    #[doc = "Data write cycle"]
    pub mod vif1_cycle {
        #[doc = "Register `VIF1_CYCLE` reader"]
        pub type R = crate::R<Vif1CycleSpec>;
        #[doc = "Field `CL` reader - Cycle length, cycle/block size"]
        pub type ClR = crate::FieldReader;
        #[doc = "Field `WL` reader - Write cycle length, Block size/cycle"]
        pub type WlR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Cycle length, cycle/block size"]
            #[inline(always)]
            pub fn cl(&self) -> ClR {
                ClR::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - Write cycle length, Block size/cycle"]
            #[inline(always)]
            pub fn wl(&self) -> WlR {
                WlR::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        #[doc = "Data write cycle\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_cycle::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1CycleSpec;
        impl crate::RegisterSpec for Vif1CycleSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_cycle::R`](R) reader structure"]
        impl crate::Readable for Vif1CycleSpec {}
        #[doc = "`reset()` method sets VIF1_CYCLE to value 0"]
        impl crate::Resettable for Vif1CycleSpec {}
    }
    #[doc = "VIF1_MODE (r) register accessor: ADD mode\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_mode::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_mode`] module"]
    #[doc(alias = "VIF1_MODE")]
    pub type Vif1Mode = crate::Reg<vif1_mode::Vif1ModeSpec>;
    #[doc = "ADD mode"]
    pub mod vif1_mode {
        #[doc = "Register `VIF1_MODE` reader"]
        pub type R = crate::R<Vif1ModeSpec>;
        #[doc = "Addition mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Mod {
            #[doc = "0: No addition processing"]
            Noaddition = 0,
            #[doc = "1: Offset mode (Row+dV -> VU Mem)"]
            Offset = 1,
            #[doc = "2: Difference mode (Row+dV -> Row -> VU Mem)"]
            Difference = 2,
        }
        impl From<Mod> for u8 {
            #[inline(always)]
            fn from(variant: Mod) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Mod {
            type Ux = u8;
        }
        impl crate::IsEnum for Mod {}
        #[doc = "Field `MOD` reader - Addition mode"]
        pub type ModR = crate::FieldReader<Mod>;
        impl ModR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Mod> {
                match self.bits {
                    0 => Some(Mod::Noaddition),
                    1 => Some(Mod::Offset),
                    2 => Some(Mod::Difference),
                    _ => None,
                }
            }
            #[doc = "No addition processing"]
            #[inline(always)]
            pub fn is_noaddition(&self) -> bool {
                *self == Mod::Noaddition
            }
            #[doc = "Offset mode (Row+dV -> VU Mem)"]
            #[inline(always)]
            pub fn is_offset(&self) -> bool {
                *self == Mod::Offset
            }
            #[doc = "Difference mode (Row+dV -> Row -> VU Mem)"]
            #[inline(always)]
            pub fn is_difference(&self) -> bool {
                *self == Mod::Difference
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Addition mode"]
            #[inline(always)]
            pub fn mod_(&self) -> ModR {
                ModR::new((self.bits & 3) as u8)
            }
        }
        #[doc = "ADD mode\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_mode::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1ModeSpec;
        impl crate::RegisterSpec for Vif1ModeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_mode::R`](R) reader structure"]
        impl crate::Readable for Vif1ModeSpec {}
        #[doc = "`reset()` method sets VIF1_MODE to value 0"]
        impl crate::Resettable for Vif1ModeSpec {}
    }
    #[doc = "VIF1_NUM (r) register accessor: Amount of non-transferred data\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_num::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_num`] module"]
    #[doc(alias = "VIF1_NUM")]
    pub type Vif1Num = crate::Reg<vif1_num::Vif1NumSpec>;
    #[doc = "Amount of non-transferred data"]
    pub mod vif1_num {
        #[doc = "Register `VIF1_NUM` reader"]
        pub type R = crate::R<Vif1NumSpec>;
        #[doc = "Field `NUM` reader - Amount of untransferred data"]
        pub type NumR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - Amount of untransferred data"]
            #[inline(always)]
            pub fn num(&self) -> NumR {
                NumR::new((self.bits & 0xff) as u8)
            }
        }
        #[doc = "Amount of non-transferred data\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_num::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1NumSpec;
        impl crate::RegisterSpec for Vif1NumSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_num::R`](R) reader structure"]
        impl crate::Readable for Vif1NumSpec {}
        #[doc = "`reset()` method sets VIF1_NUM to value 0"]
        impl crate::Resettable for Vif1NumSpec {}
    }
    #[doc = "VIF1_MASK (r) register accessor: Write mask pattern\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_mask::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_mask`] module"]
    #[doc(alias = "VIF1_MASK")]
    pub type Vif1Mask = crate::Reg<vif1_mask::Vif1MaskSpec>;
    #[doc = "Write mask pattern"]
    pub mod vif1_mask {
        #[doc = "Register `VIF1_MASK` reader"]
        pub type R = crate::R<Vif1MaskSpec>;
        #[doc = "Field `M0` reader - Decompressed data"]
        pub type M0R = crate::FieldReader;
        #[doc = "Field `M1` reader - Row register value corresponding to the field"]
        pub type M1R = crate::FieldReader;
        #[doc = "Field `M2` reader - Col register value corresponding to the write cycle"]
        pub type M2R = crate::FieldReader;
        #[doc = "Field `M3` reader - Write protect (Mask)"]
        pub type M3R = crate::FieldReader;
        #[doc = "Field `M4` reader - Decompressed data"]
        pub type M4R = crate::FieldReader;
        #[doc = "Field `M5` reader - Row register value corresponding to the field"]
        pub type M5R = crate::FieldReader;
        #[doc = "Field `M6` reader - Col register value corresponding to the write cycle"]
        pub type M6R = crate::FieldReader;
        #[doc = "Field `M7` reader - Write protect (Mask)"]
        pub type M7R = crate::FieldReader;
        #[doc = "Field `M8` reader - Decompressed data"]
        pub type M8R = crate::FieldReader;
        #[doc = "Field `M9` reader - Row register value corresponding to the field"]
        pub type M9R = crate::FieldReader;
        #[doc = "Field `M10` reader - Col register value corresponding to the write cycle"]
        pub type M10R = crate::FieldReader;
        #[doc = "Field `M11` reader - Write protect (Mask)"]
        pub type M11R = crate::FieldReader;
        #[doc = "Field `M12` reader - Decompressed data"]
        pub type M12R = crate::FieldReader;
        #[doc = "Field `M13` reader - Row register value corresponding to the field"]
        pub type M13R = crate::FieldReader;
        #[doc = "Field `M14` reader - Col register value corresponding to the write cycle"]
        pub type M14R = crate::FieldReader;
        #[doc = "Field `M15` reader - Write protect (Mask)"]
        pub type M15R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:1 - Decompressed data"]
            #[inline(always)]
            pub fn m0(&self) -> M0R {
                M0R::new((self.bits & 3) as u8)
            }
            #[doc = "Bits 2:3 - Row register value corresponding to the field"]
            #[inline(always)]
            pub fn m1(&self) -> M1R {
                M1R::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Col register value corresponding to the write cycle"]
            #[inline(always)]
            pub fn m2(&self) -> M2R {
                M2R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Write protect (Mask)"]
            #[inline(always)]
            pub fn m3(&self) -> M3R {
                M3R::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Decompressed data"]
            #[inline(always)]
            pub fn m4(&self) -> M4R {
                M4R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bits 10:11 - Row register value corresponding to the field"]
            #[inline(always)]
            pub fn m5(&self) -> M5R {
                M5R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:13 - Col register value corresponding to the write cycle"]
            #[inline(always)]
            pub fn m6(&self) -> M6R {
                M6R::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Write protect (Mask)"]
            #[inline(always)]
            pub fn m7(&self) -> M7R {
                M7R::new(((self.bits >> 14) & 3) as u8)
            }
            #[doc = "Bits 16:17 - Decompressed data"]
            #[inline(always)]
            pub fn m8(&self) -> M8R {
                M8R::new(((self.bits >> 16) & 3) as u8)
            }
            #[doc = "Bits 18:19 - Row register value corresponding to the field"]
            #[inline(always)]
            pub fn m9(&self) -> M9R {
                M9R::new(((self.bits >> 18) & 3) as u8)
            }
            #[doc = "Bits 20:21 - Col register value corresponding to the write cycle"]
            #[inline(always)]
            pub fn m10(&self) -> M10R {
                M10R::new(((self.bits >> 20) & 3) as u8)
            }
            #[doc = "Bits 22:23 - Write protect (Mask)"]
            #[inline(always)]
            pub fn m11(&self) -> M11R {
                M11R::new(((self.bits >> 22) & 3) as u8)
            }
            #[doc = "Bits 24:25 - Decompressed data"]
            #[inline(always)]
            pub fn m12(&self) -> M12R {
                M12R::new(((self.bits >> 24) & 3) as u8)
            }
            #[doc = "Bits 26:27 - Row register value corresponding to the field"]
            #[inline(always)]
            pub fn m13(&self) -> M13R {
                M13R::new(((self.bits >> 26) & 3) as u8)
            }
            #[doc = "Bits 28:29 - Col register value corresponding to the write cycle"]
            #[inline(always)]
            pub fn m14(&self) -> M14R {
                M14R::new(((self.bits >> 28) & 3) as u8)
            }
            #[doc = "Bits 30:31 - Write protect (Mask)"]
            #[inline(always)]
            pub fn m15(&self) -> M15R {
                M15R::new(((self.bits >> 30) & 3) as u8)
            }
        }
        #[doc = "Write mask pattern\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_mask::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1MaskSpec;
        impl crate::RegisterSpec for Vif1MaskSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_mask::R`](R) reader structure"]
        impl crate::Readable for Vif1MaskSpec {}
        #[doc = "`reset()` method sets VIF1_MASK to value 0"]
        impl crate::Resettable for Vif1MaskSpec {}
    }
    #[doc = "VIF1_CODE (r) register accessor: Last processed VIFcode\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_code::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_code`] module"]
    #[doc(alias = "VIF1_CODE")]
    pub type Vif1Code = crate::Reg<vif1_code::Vif1CodeSpec>;
    #[doc = "Last processed VIFcode"]
    pub mod vif1_code {
        #[doc = "Register `VIF1_CODE` reader"]
        pub type R = crate::R<Vif1CodeSpec>;
        #[doc = "Field `IMMEDIATE` reader - VIFcode IMMEDIATE processed most recently"]
        pub type ImmediateR = crate::FieldReader<u16>;
        #[doc = "Field `NUM` reader - VIFcode NUM processed most recently"]
        pub type NumR = crate::FieldReader;
        #[doc = "Field `CMD` reader - VIFcode CMD processed most recently"]
        pub type CmdR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:15 - VIFcode IMMEDIATE processed most recently"]
            #[inline(always)]
            pub fn immediate(&self) -> ImmediateR {
                ImmediateR::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:23 - VIFcode NUM processed most recently"]
            #[inline(always)]
            pub fn num(&self) -> NumR {
                NumR::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - VIFcode CMD processed most recently"]
            #[inline(always)]
            pub fn cmd(&self) -> CmdR {
                CmdR::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        #[doc = "Last processed VIFcode\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_code::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1CodeSpec;
        impl crate::RegisterSpec for Vif1CodeSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_code::R`](R) reader structure"]
        impl crate::Readable for Vif1CodeSpec {}
        #[doc = "`reset()` method sets VIF1_CODE to value 0"]
        impl crate::Resettable for Vif1CodeSpec {}
    }
    #[doc = "VIF1_ITOPS (r) register accessor: Next ITOP value\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_itops::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_itops`] module"]
    #[doc(alias = "VIF1_ITOPS")]
    pub type Vif1Itops = crate::Reg<vif1_itops::Vif1ItopsSpec>;
    #[doc = "Next ITOP value"]
    pub mod vif1_itops {
        #[doc = "Register `VIF1_ITOPS` reader"]
        pub type R = crate::R<Vif1ItopsSpec>;
        #[doc = "Field `ITOPS` reader - ITOPS value"]
        pub type ItopsR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:9 - ITOPS value"]
            #[inline(always)]
            pub fn itops(&self) -> ItopsR {
                ItopsR::new((self.bits & 0x03ff) as u16)
            }
        }
        #[doc = "Next ITOP value\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_itops::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1ItopsSpec;
        impl crate::RegisterSpec for Vif1ItopsSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_itops::R`](R) reader structure"]
        impl crate::Readable for Vif1ItopsSpec {}
        #[doc = "`reset()` method sets VIF1_ITOPS to value 0"]
        impl crate::Resettable for Vif1ItopsSpec {}
    }
    #[doc = "VIF1_BASE (r) register accessor: Base address of double buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_base::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_base`] module"]
    #[doc(alias = "VIF1_BASE")]
    pub type Vif1Base = crate::Reg<vif1_base::Vif1BaseSpec>;
    #[doc = "Base address of double buffer"]
    pub mod vif1_base {
        #[doc = "Register `VIF1_BASE` reader"]
        pub type R = crate::R<Vif1BaseSpec>;
        #[doc = "Field `BASE` reader - Data buffer base address"]
        pub type BaseR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:9 - Data buffer base address"]
            #[inline(always)]
            pub fn base(&self) -> BaseR {
                BaseR::new((self.bits & 0x03ff) as u16)
            }
        }
        #[doc = "Base address of double buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_base::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1BaseSpec;
        impl crate::RegisterSpec for Vif1BaseSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_base::R`](R) reader structure"]
        impl crate::Readable for Vif1BaseSpec {}
        #[doc = "`reset()` method sets VIF1_BASE to value 0"]
        impl crate::Resettable for Vif1BaseSpec {}
    }
    #[doc = "VIF1_OFST (r) register accessor: Offset of double buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_ofst::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_ofst`] module"]
    #[doc(alias = "VIF1_OFST")]
    pub type Vif1Ofst = crate::Reg<vif1_ofst::Vif1OfstSpec>;
    #[doc = "Offset of double buffer"]
    pub mod vif1_ofst {
        #[doc = "Register `VIF1_OFST` reader"]
        pub type R = crate::R<Vif1OfstSpec>;
        #[doc = "Field `OFFSET` reader - Data buffer offset"]
        pub type OffsetR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:9 - Data buffer offset"]
            #[inline(always)]
            pub fn offset(&self) -> OffsetR {
                OffsetR::new((self.bits & 0x03ff) as u16)
            }
        }
        #[doc = "Offset of double buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_ofst::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1OfstSpec;
        impl crate::RegisterSpec for Vif1OfstSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_ofst::R`](R) reader structure"]
        impl crate::Readable for Vif1OfstSpec {}
        #[doc = "`reset()` method sets VIF1_OFST to value 0"]
        impl crate::Resettable for Vif1OfstSpec {}
    }
    #[doc = "VIF1_TOPS (r) register accessor: Next TOP value/data write address\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_tops::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_tops`] module"]
    #[doc(alias = "VIF1_TOPS")]
    pub type Vif1Tops = crate::Reg<vif1_tops::Vif1TopsSpec>;
    #[doc = "Next TOP value/data write address"]
    pub mod vif1_tops {
        #[doc = "Register `VIF1_TOPS` reader"]
        pub type R = crate::R<Vif1TopsSpec>;
        #[doc = "Field `TOPS` reader - Data decompression buffer address"]
        pub type TopsR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:9 - Data decompression buffer address"]
            #[inline(always)]
            pub fn tops(&self) -> TopsR {
                TopsR::new((self.bits & 0x03ff) as u16)
            }
        }
        #[doc = "Next TOP value/data write address\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_tops::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1TopsSpec;
        impl crate::RegisterSpec for Vif1TopsSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_tops::R`](R) reader structure"]
        impl crate::Readable for Vif1TopsSpec {}
        #[doc = "`reset()` method sets VIF1_TOPS to value 0"]
        impl crate::Resettable for Vif1TopsSpec {}
    }
    #[doc = "VIF1_ITOP (r) register accessor: ITOP value\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_itop::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_itop`] module"]
    #[doc(alias = "VIF1_ITOP")]
    pub type Vif1Itop = crate::Reg<vif1_itop::Vif1ItopSpec>;
    #[doc = "ITOP value"]
    pub mod vif1_itop {
        #[doc = "Register `VIF1_ITOP` reader"]
        pub type R = crate::R<Vif1ItopSpec>;
        #[doc = "Field `ITOP` reader - ITOP value"]
        pub type ItopR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:9 - ITOP value"]
            #[inline(always)]
            pub fn itop(&self) -> ItopR {
                ItopR::new((self.bits & 0x03ff) as u16)
            }
        }
        #[doc = "ITOP value\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_itop::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1ItopSpec;
        impl crate::RegisterSpec for Vif1ItopSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_itop::R`](R) reader structure"]
        impl crate::Readable for Vif1ItopSpec {}
        #[doc = "`reset()` method sets VIF1_ITOP to value 0"]
        impl crate::Resettable for Vif1ItopSpec {}
    }
    #[doc = "VIF1_R0 (r) register accessor: Filling data R0 (Row register)\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_r0::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_r0`] module"]
    #[doc(alias = "VIF1_R0")]
    pub type Vif1R0 = crate::Reg<vif1_r0::Vif1R0Spec>;
    #[doc = "Filling data R0 (Row register)"]
    pub mod vif1_r0 {
        #[doc = "Register `VIF1_R0` reader"]
        pub type R = crate::R<Vif1R0Spec>;
        #[doc = "Field `R` reader - Row data for filling when decompressing"]
        pub type RR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - Row data for filling when decompressing"]
            #[inline(always)]
            pub fn r(&self) -> RR {
                RR::new(self.bits)
            }
        }
        #[doc = "Filling data R0 (Row register)\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_r0::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1R0Spec;
        impl crate::RegisterSpec for Vif1R0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_r0::R`](R) reader structure"]
        impl crate::Readable for Vif1R0Spec {}
        #[doc = "`reset()` method sets VIF1_R0 to value 0"]
        impl crate::Resettable for Vif1R0Spec {}
    }
    pub use vif1_r0 as vif1_r1;
    pub use vif1_r0 as vif1_r2;
    pub use vif1_r0 as vif1_r3;
    pub use Vif1R0 as Vif1R1;
    pub use Vif1R0 as Vif1R2;
    pub use Vif1R0 as Vif1R3;
    #[doc = "VIF1_C0 (rw) register accessor: Filling data C0 (Col register)\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_c0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vif1_c0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@vif1_c0`] module"]
    #[doc(alias = "VIF1_C0")]
    pub type Vif1C0 = crate::Reg<vif1_c0::Vif1C0Spec>;
    #[doc = "Filling data C0 (Col register)"]
    pub mod vif1_c0 {
        #[doc = "Register `VIF1_C0` reader"]
        pub type R = crate::R<Vif1C0Spec>;
        #[doc = "Register `VIF1_C0` writer"]
        pub type W = crate::W<Vif1C0Spec>;
        #[doc = "Field `C` reader - Column data for filling when decompressing"]
        pub type CR = crate::FieldReader<u32>;
        #[doc = "Field `C` writer - Column data for filling when decompressing"]
        pub type CW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Column data for filling when decompressing"]
            #[inline(always)]
            pub fn c(&self) -> CR {
                CR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Column data for filling when decompressing"]
            #[inline(always)]
            pub fn c(&mut self) -> CW<Vif1C0Spec> {
                CW::new(self, 0)
            }
        }
        #[doc = "Filling data C0 (Col register)\n\nYou can [`read`](crate::Reg::read) this register and get [`vif1_c0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`vif1_c0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Vif1C0Spec;
        impl crate::RegisterSpec for Vif1C0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`vif1_c0::R`](R) reader structure"]
        impl crate::Readable for Vif1C0Spec {}
        #[doc = "`write(|w| ..)` method takes [`vif1_c0::W`](W) writer structure"]
        impl crate::Writable for Vif1C0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets VIF1_C0 to value 0"]
        impl crate::Resettable for Vif1C0Spec {}
    }
    pub use vif1_c0 as vif1_c1;
    pub use vif1_c0 as vif1_c2;
    pub use vif1_c0 as vif1_c3;
    pub use Vif1C0 as Vif1C1;
    pub use Vif1C0 as Vif1C2;
    pub use Vif1C0 as Vif1C3;
}
#[doc = "DMA Controller. See EE User's Manual, Chapter 5."]
pub type Dmac = crate::Periph<dmac::RegisterBlock, 0xb000_8000>;
impl core::fmt::Debug for Dmac {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmac").finish()
    }
}
#[doc = "DMA Controller. See EE User's Manual, Chapter 5."]
pub mod dmac {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        d0_chcr: D0Chcr,
        _reserved1: [u8; 0x0c],
        d0_madr: D0Madr,
        _reserved2: [u8; 0x0c],
        d0_qwc: D0Qwc,
        _reserved3: [u8; 0x0c],
        d0_tadr: D0Tadr,
        _reserved4: [u8; 0x0c],
        d0_asr0: D0Asr0,
        _reserved5: [u8; 0x0c],
        d0_asr1: D0Asr1,
        _reserved6: [u8; 0x0fac],
        d1_chcr: D1Chcr,
        _reserved7: [u8; 0x0c],
        d1_madr: D1Madr,
        _reserved8: [u8; 0x0c],
        d1_qwc: D1Qwc,
        _reserved9: [u8; 0x0c],
        d1_tadr: D1Tadr,
        _reserved10: [u8; 0x0c],
        d1_asr0: D1Asr0,
        _reserved11: [u8; 0x0c],
        d1_asr1: D1Asr1,
        _reserved12: [u8; 0x0fac],
        d2_chcr: D2Chcr,
        _reserved13: [u8; 0x0c],
        d2_madr: D2Madr,
        _reserved14: [u8; 0x0c],
        d2_qwc: D2Qwc,
        _reserved15: [u8; 0x0c],
        d2_tadr: D2Tadr,
        _reserved16: [u8; 0x0c],
        d2_asr0: D2Asr0,
        _reserved17: [u8; 0x0c],
        d2_asr1: D2Asr1,
        _reserved18: [u8; 0x0fac],
        d3_chcr: D3Chcr,
        _reserved19: [u8; 0x0c],
        d3_madr: D3Madr,
        _reserved20: [u8; 0x0c],
        d3_qwc: D3Qwc,
        _reserved21: [u8; 0x03dc],
        d4_chcr: D4Chcr,
        _reserved22: [u8; 0x0c],
        d4_madr: D4Madr,
        _reserved23: [u8; 0x0c],
        d4_qwc: D4Qwc,
        _reserved24: [u8; 0x0c],
        d4_tadr: D4Tadr,
        _reserved25: [u8; 0x0bcc],
        d5_chcr: D5Chcr,
        _reserved26: [u8; 0x0c],
        d5_madr: D5Madr,
        _reserved27: [u8; 0x0c],
        d5_qwc: D5Qwc,
        _reserved28: [u8; 0x03dc],
        d6_chcr: D6Chcr,
        _reserved29: [u8; 0x0c],
        d6_madr: D6Madr,
        _reserved30: [u8; 0x0c],
        d6_qwc: D6Qwc,
        _reserved31: [u8; 0x0c],
        d6_tadr: D6Tadr,
        _reserved32: [u8; 0x03cc],
        d7_chcr: D7Chcr,
        _reserved33: [u8; 0x0c],
        d7_madr: D7Madr,
        _reserved34: [u8; 0x0c],
        d7_qwc: D7Qwc,
        _reserved35: [u8; 0x07dc],
        d8_chcr: D8Chcr,
        _reserved36: [u8; 0x0c],
        d8_madr: D8Madr,
        _reserved37: [u8; 0x0c],
        d8_qwc: D8Qwc,
        _reserved38: [u8; 0x5c],
        d8_sadr: D8Sadr,
        _reserved39: [u8; 0x037c],
        d9_chcr: D9Chcr,
        _reserved40: [u8; 0x0c],
        d9_madr: D9Madr,
        _reserved41: [u8; 0x0c],
        d9_qwc: D9Qwc,
        _reserved42: [u8; 0x5c],
        d9_sadr: D9Sadr,
        _reserved43: [u8; 0x0b7c],
        d_ctrl: DCtrl,
        _reserved44: [u8; 0x0c],
        d_stat: DStat,
        _reserved45: [u8; 0x0c],
        d_pcr: DPcr,
        _reserved46: [u8; 0x0c],
        d_sqwc: DSqwc,
        _reserved47: [u8; 0x0c],
        d_rbsr: DRbsr,
        _reserved48: [u8; 0x0c],
        d_rbor: DRbor,
        _reserved49: [u8; 0x0c],
        d_stadr: DStadr,
        _reserved50: [u8; 0x14bc],
        d_enabler: DEnabler,
        _reserved51: [u8; 0x6c],
        d_enablew: DEnablew,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Ch0 channel control"]
        #[inline(always)]
        pub const fn d0_chcr(&self) -> &D0Chcr {
            &self.d0_chcr
        }
        #[doc = "0x10 - Ch0 memory address"]
        #[inline(always)]
        pub const fn d0_madr(&self) -> &D0Madr {
            &self.d0_madr
        }
        #[doc = "0x20 - Ch0 quad word count"]
        #[inline(always)]
        pub const fn d0_qwc(&self) -> &D0Qwc {
            &self.d0_qwc
        }
        #[doc = "0x30 - Ch0 tag address"]
        #[inline(always)]
        pub const fn d0_tadr(&self) -> &D0Tadr {
            &self.d0_tadr
        }
        #[doc = "0x40 - Ch0 address stack 0"]
        #[inline(always)]
        pub const fn d0_asr0(&self) -> &D0Asr0 {
            &self.d0_asr0
        }
        #[doc = "0x50 - Ch0 address stack 1"]
        #[inline(always)]
        pub const fn d0_asr1(&self) -> &D0Asr1 {
            &self.d0_asr1
        }
        #[doc = "0x1000 - Ch1 channel control"]
        #[inline(always)]
        pub const fn d1_chcr(&self) -> &D1Chcr {
            &self.d1_chcr
        }
        #[doc = "0x1010 - Ch1 memory address"]
        #[inline(always)]
        pub const fn d1_madr(&self) -> &D1Madr {
            &self.d1_madr
        }
        #[doc = "0x1020 - Ch1 quad word count"]
        #[inline(always)]
        pub const fn d1_qwc(&self) -> &D1Qwc {
            &self.d1_qwc
        }
        #[doc = "0x1030 - Ch1 tag address"]
        #[inline(always)]
        pub const fn d1_tadr(&self) -> &D1Tadr {
            &self.d1_tadr
        }
        #[doc = "0x1040 - Ch1 address stack 0"]
        #[inline(always)]
        pub const fn d1_asr0(&self) -> &D1Asr0 {
            &self.d1_asr0
        }
        #[doc = "0x1050 - Ch1 address stack 1"]
        #[inline(always)]
        pub const fn d1_asr1(&self) -> &D1Asr1 {
            &self.d1_asr1
        }
        #[doc = "0x2000 - Ch2 channel control"]
        #[inline(always)]
        pub const fn d2_chcr(&self) -> &D2Chcr {
            &self.d2_chcr
        }
        #[doc = "0x2010 - Ch2 memory address"]
        #[inline(always)]
        pub const fn d2_madr(&self) -> &D2Madr {
            &self.d2_madr
        }
        #[doc = "0x2020 - Ch2 quad word count"]
        #[inline(always)]
        pub const fn d2_qwc(&self) -> &D2Qwc {
            &self.d2_qwc
        }
        #[doc = "0x2030 - Ch2 tag address"]
        #[inline(always)]
        pub const fn d2_tadr(&self) -> &D2Tadr {
            &self.d2_tadr
        }
        #[doc = "0x2040 - Ch2 address stack 0"]
        #[inline(always)]
        pub const fn d2_asr0(&self) -> &D2Asr0 {
            &self.d2_asr0
        }
        #[doc = "0x2050 - Ch2 address stack 1"]
        #[inline(always)]
        pub const fn d2_asr1(&self) -> &D2Asr1 {
            &self.d2_asr1
        }
        #[doc = "0x3000 - Ch3 channel control"]
        #[inline(always)]
        pub const fn d3_chcr(&self) -> &D3Chcr {
            &self.d3_chcr
        }
        #[doc = "0x3010 - Ch3 memory address"]
        #[inline(always)]
        pub const fn d3_madr(&self) -> &D3Madr {
            &self.d3_madr
        }
        #[doc = "0x3020 - Ch3 quad word count"]
        #[inline(always)]
        pub const fn d3_qwc(&self) -> &D3Qwc {
            &self.d3_qwc
        }
        #[doc = "0x3400 - Ch4 channel control"]
        #[inline(always)]
        pub const fn d4_chcr(&self) -> &D4Chcr {
            &self.d4_chcr
        }
        #[doc = "0x3410 - Ch4 memory address"]
        #[inline(always)]
        pub const fn d4_madr(&self) -> &D4Madr {
            &self.d4_madr
        }
        #[doc = "0x3420 - Ch4 quad word count"]
        #[inline(always)]
        pub const fn d4_qwc(&self) -> &D4Qwc {
            &self.d4_qwc
        }
        #[doc = "0x3430 - Ch4 tag address"]
        #[inline(always)]
        pub const fn d4_tadr(&self) -> &D4Tadr {
            &self.d4_tadr
        }
        #[doc = "0x4000 - Ch5 channel control"]
        #[inline(always)]
        pub const fn d5_chcr(&self) -> &D5Chcr {
            &self.d5_chcr
        }
        #[doc = "0x4010 - Ch5 memory address"]
        #[inline(always)]
        pub const fn d5_madr(&self) -> &D5Madr {
            &self.d5_madr
        }
        #[doc = "0x4020 - Ch5 quad word count"]
        #[inline(always)]
        pub const fn d5_qwc(&self) -> &D5Qwc {
            &self.d5_qwc
        }
        #[doc = "0x4400 - Ch6 channel control"]
        #[inline(always)]
        pub const fn d6_chcr(&self) -> &D6Chcr {
            &self.d6_chcr
        }
        #[doc = "0x4410 - Ch6 memory address"]
        #[inline(always)]
        pub const fn d6_madr(&self) -> &D6Madr {
            &self.d6_madr
        }
        #[doc = "0x4420 - Ch6 quad word count"]
        #[inline(always)]
        pub const fn d6_qwc(&self) -> &D6Qwc {
            &self.d6_qwc
        }
        #[doc = "0x4430 - Ch6 tag address"]
        #[inline(always)]
        pub const fn d6_tadr(&self) -> &D6Tadr {
            &self.d6_tadr
        }
        #[doc = "0x4800 - Ch7 channel control"]
        #[inline(always)]
        pub const fn d7_chcr(&self) -> &D7Chcr {
            &self.d7_chcr
        }
        #[doc = "0x4810 - Ch7 memory address"]
        #[inline(always)]
        pub const fn d7_madr(&self) -> &D7Madr {
            &self.d7_madr
        }
        #[doc = "0x4820 - Ch7 quad word count"]
        #[inline(always)]
        pub const fn d7_qwc(&self) -> &D7Qwc {
            &self.d7_qwc
        }
        #[doc = "0x5000 - Ch8 channel control"]
        #[inline(always)]
        pub const fn d8_chcr(&self) -> &D8Chcr {
            &self.d8_chcr
        }
        #[doc = "0x5010 - Ch8 memory address"]
        #[inline(always)]
        pub const fn d8_madr(&self) -> &D8Madr {
            &self.d8_madr
        }
        #[doc = "0x5020 - Ch8 quad word count"]
        #[inline(always)]
        pub const fn d8_qwc(&self) -> &D8Qwc {
            &self.d8_qwc
        }
        #[doc = "0x5080 - Ch8 SPR address"]
        #[inline(always)]
        pub const fn d8_sadr(&self) -> &D8Sadr {
            &self.d8_sadr
        }
        #[doc = "0x5400 - Ch9 channel control"]
        #[inline(always)]
        pub const fn d9_chcr(&self) -> &D9Chcr {
            &self.d9_chcr
        }
        #[doc = "0x5410 - Ch9 memory address"]
        #[inline(always)]
        pub const fn d9_madr(&self) -> &D9Madr {
            &self.d9_madr
        }
        #[doc = "0x5420 - Ch9 quad word count"]
        #[inline(always)]
        pub const fn d9_qwc(&self) -> &D9Qwc {
            &self.d9_qwc
        }
        #[doc = "0x5480 - Ch9 SPR address"]
        #[inline(always)]
        pub const fn d9_sadr(&self) -> &D9Sadr {
            &self.d9_sadr
        }
        #[doc = "0x6000 - DMAC control"]
        #[inline(always)]
        pub const fn d_ctrl(&self) -> &DCtrl {
            &self.d_ctrl
        }
        #[doc = "0x6010 - DMAC status"]
        #[inline(always)]
        pub const fn d_stat(&self) -> &DStat {
            &self.d_stat
        }
        #[doc = "0x6020 - DMAC priority control"]
        #[inline(always)]
        pub const fn d_pcr(&self) -> &DPcr {
            &self.d_pcr
        }
        #[doc = "0x6030 - DMAC skip quad word"]
        #[inline(always)]
        pub const fn d_sqwc(&self) -> &DSqwc {
            &self.d_sqwc
        }
        #[doc = "0x6040 - DMAC ring buffer size"]
        #[inline(always)]
        pub const fn d_rbsr(&self) -> &DRbsr {
            &self.d_rbsr
        }
        #[doc = "0x6050 - DMAC ring buffer offset"]
        #[inline(always)]
        pub const fn d_rbor(&self) -> &DRbor {
            &self.d_rbor
        }
        #[doc = "0x6060 - DMAC stall address"]
        #[inline(always)]
        pub const fn d_stadr(&self) -> &DStadr {
            &self.d_stadr
        }
        #[doc = "0x7520 - Acquistion of DMA suspend status"]
        #[inline(always)]
        pub const fn d_enabler(&self) -> &DEnabler {
            &self.d_enabler
        }
        #[doc = "0x7590 - DMA suspend control"]
        #[inline(always)]
        pub const fn d_enablew(&self) -> &DEnablew {
            &self.d_enablew
        }
    }
    #[doc = "D0_CHCR (rw) register accessor: Ch0 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_chcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_chcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d0_chcr`] module"]
    #[doc(alias = "D0_CHCR")]
    pub type D0Chcr = crate::Reg<d0_chcr::D0ChcrSpec>;
    #[doc = "Ch0 channel control"]
    pub mod d0_chcr {
        #[doc = "Register `D0_CHCR` reader"]
        pub type R = crate::R<D0ChcrSpec>;
        #[doc = "Register `D0_CHCR` writer"]
        pub type W = crate::W<D0ChcrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch0 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_chcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_chcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D0ChcrSpec;
        impl crate::RegisterSpec for D0ChcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d0_chcr::R`](R) reader structure"]
        impl crate::Readable for D0ChcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d0_chcr::W`](W) writer structure"]
        impl crate::Writable for D0ChcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D0_CHCR to value 0"]
        impl crate::Resettable for D0ChcrSpec {}
    }
    #[doc = "D0_MADR (rw) register accessor: Ch0 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_madr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_madr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d0_madr`] module"]
    #[doc(alias = "D0_MADR")]
    pub type D0Madr = crate::Reg<d0_madr::D0MadrSpec>;
    #[doc = "Ch0 memory address"]
    pub mod d0_madr {
        #[doc = "Register `D0_MADR` reader"]
        pub type R = crate::R<D0MadrSpec>;
        #[doc = "Register `D0_MADR` writer"]
        pub type W = crate::W<D0MadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch0 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_madr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_madr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D0MadrSpec;
        impl crate::RegisterSpec for D0MadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d0_madr::R`](R) reader structure"]
        impl crate::Readable for D0MadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d0_madr::W`](W) writer structure"]
        impl crate::Writable for D0MadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D0_MADR to value 0"]
        impl crate::Resettable for D0MadrSpec {}
    }
    #[doc = "D0_QWC (rw) register accessor: Ch0 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_qwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_qwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d0_qwc`] module"]
    #[doc(alias = "D0_QWC")]
    pub type D0Qwc = crate::Reg<d0_qwc::D0QwcSpec>;
    #[doc = "Ch0 quad word count"]
    pub mod d0_qwc {
        #[doc = "Register `D0_QWC` reader"]
        pub type R = crate::R<D0QwcSpec>;
        #[doc = "Register `D0_QWC` writer"]
        pub type W = crate::W<D0QwcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch0 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_qwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_qwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D0QwcSpec;
        impl crate::RegisterSpec for D0QwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d0_qwc::R`](R) reader structure"]
        impl crate::Readable for D0QwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d0_qwc::W`](W) writer structure"]
        impl crate::Writable for D0QwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D0_QWC to value 0"]
        impl crate::Resettable for D0QwcSpec {}
    }
    #[doc = "D0_TADR (rw) register accessor: Ch0 tag address\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_tadr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_tadr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d0_tadr`] module"]
    #[doc(alias = "D0_TADR")]
    pub type D0Tadr = crate::Reg<d0_tadr::D0TadrSpec>;
    #[doc = "Ch0 tag address"]
    pub mod d0_tadr {
        #[doc = "Register `D0_TADR` reader"]
        pub type R = crate::R<D0TadrSpec>;
        #[doc = "Register `D0_TADR` writer"]
        pub type W = crate::W<D0TadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch0 tag address\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_tadr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_tadr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D0TadrSpec;
        impl crate::RegisterSpec for D0TadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d0_tadr::R`](R) reader structure"]
        impl crate::Readable for D0TadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d0_tadr::W`](W) writer structure"]
        impl crate::Writable for D0TadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D0_TADR to value 0"]
        impl crate::Resettable for D0TadrSpec {}
    }
    #[doc = "D0_ASR0 (rw) register accessor: Ch0 address stack 0\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_asr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_asr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d0_asr0`] module"]
    #[doc(alias = "D0_ASR0")]
    pub type D0Asr0 = crate::Reg<d0_asr0::D0Asr0Spec>;
    #[doc = "Ch0 address stack 0"]
    pub mod d0_asr0 {
        #[doc = "Register `D0_ASR0` reader"]
        pub type R = crate::R<D0Asr0Spec>;
        #[doc = "Register `D0_ASR0` writer"]
        pub type W = crate::W<D0Asr0Spec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch0 address stack 0\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_asr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_asr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D0Asr0Spec;
        impl crate::RegisterSpec for D0Asr0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d0_asr0::R`](R) reader structure"]
        impl crate::Readable for D0Asr0Spec {}
        #[doc = "`write(|w| ..)` method takes [`d0_asr0::W`](W) writer structure"]
        impl crate::Writable for D0Asr0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D0_ASR0 to value 0"]
        impl crate::Resettable for D0Asr0Spec {}
    }
    #[doc = "D0_ASR1 (rw) register accessor: Ch0 address stack 1\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_asr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_asr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d0_asr1`] module"]
    #[doc(alias = "D0_ASR1")]
    pub type D0Asr1 = crate::Reg<d0_asr1::D0Asr1Spec>;
    #[doc = "Ch0 address stack 1"]
    pub mod d0_asr1 {
        #[doc = "Register `D0_ASR1` reader"]
        pub type R = crate::R<D0Asr1Spec>;
        #[doc = "Register `D0_ASR1` writer"]
        pub type W = crate::W<D0Asr1Spec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch0 address stack 1\n\nYou can [`read`](crate::Reg::read) this register and get [`d0_asr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d0_asr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D0Asr1Spec;
        impl crate::RegisterSpec for D0Asr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d0_asr1::R`](R) reader structure"]
        impl crate::Readable for D0Asr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`d0_asr1::W`](W) writer structure"]
        impl crate::Writable for D0Asr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D0_ASR1 to value 0"]
        impl crate::Resettable for D0Asr1Spec {}
    }
    #[doc = "D1_CHCR (rw) register accessor: Ch1 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_chcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_chcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d1_chcr`] module"]
    #[doc(alias = "D1_CHCR")]
    pub type D1Chcr = crate::Reg<d1_chcr::D1ChcrSpec>;
    #[doc = "Ch1 channel control"]
    pub mod d1_chcr {
        #[doc = "Register `D1_CHCR` reader"]
        pub type R = crate::R<D1ChcrSpec>;
        #[doc = "Register `D1_CHCR` writer"]
        pub type W = crate::W<D1ChcrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch1 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_chcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_chcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D1ChcrSpec;
        impl crate::RegisterSpec for D1ChcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d1_chcr::R`](R) reader structure"]
        impl crate::Readable for D1ChcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d1_chcr::W`](W) writer structure"]
        impl crate::Writable for D1ChcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D1_CHCR to value 0"]
        impl crate::Resettable for D1ChcrSpec {}
    }
    #[doc = "D1_MADR (rw) register accessor: Ch1 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_madr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_madr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d1_madr`] module"]
    #[doc(alias = "D1_MADR")]
    pub type D1Madr = crate::Reg<d1_madr::D1MadrSpec>;
    #[doc = "Ch1 memory address"]
    pub mod d1_madr {
        #[doc = "Register `D1_MADR` reader"]
        pub type R = crate::R<D1MadrSpec>;
        #[doc = "Register `D1_MADR` writer"]
        pub type W = crate::W<D1MadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch1 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_madr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_madr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D1MadrSpec;
        impl crate::RegisterSpec for D1MadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d1_madr::R`](R) reader structure"]
        impl crate::Readable for D1MadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d1_madr::W`](W) writer structure"]
        impl crate::Writable for D1MadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D1_MADR to value 0"]
        impl crate::Resettable for D1MadrSpec {}
    }
    #[doc = "D1_QWC (rw) register accessor: Ch1 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_qwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_qwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d1_qwc`] module"]
    #[doc(alias = "D1_QWC")]
    pub type D1Qwc = crate::Reg<d1_qwc::D1QwcSpec>;
    #[doc = "Ch1 quad word count"]
    pub mod d1_qwc {
        #[doc = "Register `D1_QWC` reader"]
        pub type R = crate::R<D1QwcSpec>;
        #[doc = "Register `D1_QWC` writer"]
        pub type W = crate::W<D1QwcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch1 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_qwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_qwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D1QwcSpec;
        impl crate::RegisterSpec for D1QwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d1_qwc::R`](R) reader structure"]
        impl crate::Readable for D1QwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d1_qwc::W`](W) writer structure"]
        impl crate::Writable for D1QwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D1_QWC to value 0"]
        impl crate::Resettable for D1QwcSpec {}
    }
    #[doc = "D1_TADR (rw) register accessor: Ch1 tag address\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_tadr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_tadr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d1_tadr`] module"]
    #[doc(alias = "D1_TADR")]
    pub type D1Tadr = crate::Reg<d1_tadr::D1TadrSpec>;
    #[doc = "Ch1 tag address"]
    pub mod d1_tadr {
        #[doc = "Register `D1_TADR` reader"]
        pub type R = crate::R<D1TadrSpec>;
        #[doc = "Register `D1_TADR` writer"]
        pub type W = crate::W<D1TadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch1 tag address\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_tadr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_tadr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D1TadrSpec;
        impl crate::RegisterSpec for D1TadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d1_tadr::R`](R) reader structure"]
        impl crate::Readable for D1TadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d1_tadr::W`](W) writer structure"]
        impl crate::Writable for D1TadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D1_TADR to value 0"]
        impl crate::Resettable for D1TadrSpec {}
    }
    #[doc = "D1_ASR0 (rw) register accessor: Ch1 address stack 0\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_asr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_asr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d1_asr0`] module"]
    #[doc(alias = "D1_ASR0")]
    pub type D1Asr0 = crate::Reg<d1_asr0::D1Asr0Spec>;
    #[doc = "Ch1 address stack 0"]
    pub mod d1_asr0 {
        #[doc = "Register `D1_ASR0` reader"]
        pub type R = crate::R<D1Asr0Spec>;
        #[doc = "Register `D1_ASR0` writer"]
        pub type W = crate::W<D1Asr0Spec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch1 address stack 0\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_asr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_asr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D1Asr0Spec;
        impl crate::RegisterSpec for D1Asr0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d1_asr0::R`](R) reader structure"]
        impl crate::Readable for D1Asr0Spec {}
        #[doc = "`write(|w| ..)` method takes [`d1_asr0::W`](W) writer structure"]
        impl crate::Writable for D1Asr0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D1_ASR0 to value 0"]
        impl crate::Resettable for D1Asr0Spec {}
    }
    #[doc = "D1_ASR1 (rw) register accessor: Ch1 address stack 1\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_asr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_asr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d1_asr1`] module"]
    #[doc(alias = "D1_ASR1")]
    pub type D1Asr1 = crate::Reg<d1_asr1::D1Asr1Spec>;
    #[doc = "Ch1 address stack 1"]
    pub mod d1_asr1 {
        #[doc = "Register `D1_ASR1` reader"]
        pub type R = crate::R<D1Asr1Spec>;
        #[doc = "Register `D1_ASR1` writer"]
        pub type W = crate::W<D1Asr1Spec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch1 address stack 1\n\nYou can [`read`](crate::Reg::read) this register and get [`d1_asr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d1_asr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D1Asr1Spec;
        impl crate::RegisterSpec for D1Asr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d1_asr1::R`](R) reader structure"]
        impl crate::Readable for D1Asr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`d1_asr1::W`](W) writer structure"]
        impl crate::Writable for D1Asr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D1_ASR1 to value 0"]
        impl crate::Resettable for D1Asr1Spec {}
    }
    #[doc = "D2_CHCR (rw) register accessor: Ch2 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_chcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_chcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d2_chcr`] module"]
    #[doc(alias = "D2_CHCR")]
    pub type D2Chcr = crate::Reg<d2_chcr::D2ChcrSpec>;
    #[doc = "Ch2 channel control"]
    pub mod d2_chcr {
        #[doc = "Register `D2_CHCR` reader"]
        pub type R = crate::R<D2ChcrSpec>;
        #[doc = "Register `D2_CHCR` writer"]
        pub type W = crate::W<D2ChcrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch2 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_chcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_chcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D2ChcrSpec;
        impl crate::RegisterSpec for D2ChcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d2_chcr::R`](R) reader structure"]
        impl crate::Readable for D2ChcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d2_chcr::W`](W) writer structure"]
        impl crate::Writable for D2ChcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D2_CHCR to value 0"]
        impl crate::Resettable for D2ChcrSpec {}
    }
    #[doc = "D2_MADR (rw) register accessor: Ch2 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_madr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_madr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d2_madr`] module"]
    #[doc(alias = "D2_MADR")]
    pub type D2Madr = crate::Reg<d2_madr::D2MadrSpec>;
    #[doc = "Ch2 memory address"]
    pub mod d2_madr {
        #[doc = "Register `D2_MADR` reader"]
        pub type R = crate::R<D2MadrSpec>;
        #[doc = "Register `D2_MADR` writer"]
        pub type W = crate::W<D2MadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch2 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_madr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_madr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D2MadrSpec;
        impl crate::RegisterSpec for D2MadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d2_madr::R`](R) reader structure"]
        impl crate::Readable for D2MadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d2_madr::W`](W) writer structure"]
        impl crate::Writable for D2MadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D2_MADR to value 0"]
        impl crate::Resettable for D2MadrSpec {}
    }
    #[doc = "D2_QWC (rw) register accessor: Ch2 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_qwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_qwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d2_qwc`] module"]
    #[doc(alias = "D2_QWC")]
    pub type D2Qwc = crate::Reg<d2_qwc::D2QwcSpec>;
    #[doc = "Ch2 quad word count"]
    pub mod d2_qwc {
        #[doc = "Register `D2_QWC` reader"]
        pub type R = crate::R<D2QwcSpec>;
        #[doc = "Register `D2_QWC` writer"]
        pub type W = crate::W<D2QwcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch2 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_qwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_qwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D2QwcSpec;
        impl crate::RegisterSpec for D2QwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d2_qwc::R`](R) reader structure"]
        impl crate::Readable for D2QwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d2_qwc::W`](W) writer structure"]
        impl crate::Writable for D2QwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D2_QWC to value 0"]
        impl crate::Resettable for D2QwcSpec {}
    }
    #[doc = "D2_TADR (rw) register accessor: Ch2 tag address\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_tadr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_tadr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d2_tadr`] module"]
    #[doc(alias = "D2_TADR")]
    pub type D2Tadr = crate::Reg<d2_tadr::D2TadrSpec>;
    #[doc = "Ch2 tag address"]
    pub mod d2_tadr {
        #[doc = "Register `D2_TADR` reader"]
        pub type R = crate::R<D2TadrSpec>;
        #[doc = "Register `D2_TADR` writer"]
        pub type W = crate::W<D2TadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch2 tag address\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_tadr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_tadr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D2TadrSpec;
        impl crate::RegisterSpec for D2TadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d2_tadr::R`](R) reader structure"]
        impl crate::Readable for D2TadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d2_tadr::W`](W) writer structure"]
        impl crate::Writable for D2TadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D2_TADR to value 0"]
        impl crate::Resettable for D2TadrSpec {}
    }
    #[doc = "D2_ASR0 (rw) register accessor: Ch2 address stack 0\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_asr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_asr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d2_asr0`] module"]
    #[doc(alias = "D2_ASR0")]
    pub type D2Asr0 = crate::Reg<d2_asr0::D2Asr0Spec>;
    #[doc = "Ch2 address stack 0"]
    pub mod d2_asr0 {
        #[doc = "Register `D2_ASR0` reader"]
        pub type R = crate::R<D2Asr0Spec>;
        #[doc = "Register `D2_ASR0` writer"]
        pub type W = crate::W<D2Asr0Spec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch2 address stack 0\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_asr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_asr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D2Asr0Spec;
        impl crate::RegisterSpec for D2Asr0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d2_asr0::R`](R) reader structure"]
        impl crate::Readable for D2Asr0Spec {}
        #[doc = "`write(|w| ..)` method takes [`d2_asr0::W`](W) writer structure"]
        impl crate::Writable for D2Asr0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D2_ASR0 to value 0"]
        impl crate::Resettable for D2Asr0Spec {}
    }
    #[doc = "D2_ASR1 (rw) register accessor: Ch2 address stack 1\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_asr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_asr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d2_asr1`] module"]
    #[doc(alias = "D2_ASR1")]
    pub type D2Asr1 = crate::Reg<d2_asr1::D2Asr1Spec>;
    #[doc = "Ch2 address stack 1"]
    pub mod d2_asr1 {
        #[doc = "Register `D2_ASR1` reader"]
        pub type R = crate::R<D2Asr1Spec>;
        #[doc = "Register `D2_ASR1` writer"]
        pub type W = crate::W<D2Asr1Spec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch2 address stack 1\n\nYou can [`read`](crate::Reg::read) this register and get [`d2_asr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d2_asr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D2Asr1Spec;
        impl crate::RegisterSpec for D2Asr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d2_asr1::R`](R) reader structure"]
        impl crate::Readable for D2Asr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`d2_asr1::W`](W) writer structure"]
        impl crate::Writable for D2Asr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D2_ASR1 to value 0"]
        impl crate::Resettable for D2Asr1Spec {}
    }
    #[doc = "D3_CHCR (rw) register accessor: Ch3 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d3_chcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d3_chcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d3_chcr`] module"]
    #[doc(alias = "D3_CHCR")]
    pub type D3Chcr = crate::Reg<d3_chcr::D3ChcrSpec>;
    #[doc = "Ch3 channel control"]
    pub mod d3_chcr {
        #[doc = "Register `D3_CHCR` reader"]
        pub type R = crate::R<D3ChcrSpec>;
        #[doc = "Register `D3_CHCR` writer"]
        pub type W = crate::W<D3ChcrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch3 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d3_chcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d3_chcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D3ChcrSpec;
        impl crate::RegisterSpec for D3ChcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d3_chcr::R`](R) reader structure"]
        impl crate::Readable for D3ChcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d3_chcr::W`](W) writer structure"]
        impl crate::Writable for D3ChcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D3_CHCR to value 0"]
        impl crate::Resettable for D3ChcrSpec {}
    }
    #[doc = "D3_MADR (rw) register accessor: Ch3 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d3_madr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d3_madr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d3_madr`] module"]
    #[doc(alias = "D3_MADR")]
    pub type D3Madr = crate::Reg<d3_madr::D3MadrSpec>;
    #[doc = "Ch3 memory address"]
    pub mod d3_madr {
        #[doc = "Register `D3_MADR` reader"]
        pub type R = crate::R<D3MadrSpec>;
        #[doc = "Register `D3_MADR` writer"]
        pub type W = crate::W<D3MadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch3 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d3_madr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d3_madr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D3MadrSpec;
        impl crate::RegisterSpec for D3MadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d3_madr::R`](R) reader structure"]
        impl crate::Readable for D3MadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d3_madr::W`](W) writer structure"]
        impl crate::Writable for D3MadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D3_MADR to value 0"]
        impl crate::Resettable for D3MadrSpec {}
    }
    #[doc = "D3_QWC (rw) register accessor: Ch3 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d3_qwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d3_qwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d3_qwc`] module"]
    #[doc(alias = "D3_QWC")]
    pub type D3Qwc = crate::Reg<d3_qwc::D3QwcSpec>;
    #[doc = "Ch3 quad word count"]
    pub mod d3_qwc {
        #[doc = "Register `D3_QWC` reader"]
        pub type R = crate::R<D3QwcSpec>;
        #[doc = "Register `D3_QWC` writer"]
        pub type W = crate::W<D3QwcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch3 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d3_qwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d3_qwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D3QwcSpec;
        impl crate::RegisterSpec for D3QwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d3_qwc::R`](R) reader structure"]
        impl crate::Readable for D3QwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d3_qwc::W`](W) writer structure"]
        impl crate::Writable for D3QwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D3_QWC to value 0"]
        impl crate::Resettable for D3QwcSpec {}
    }
    #[doc = "D4_CHCR (rw) register accessor: Ch4 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d4_chcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d4_chcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d4_chcr`] module"]
    #[doc(alias = "D4_CHCR")]
    pub type D4Chcr = crate::Reg<d4_chcr::D4ChcrSpec>;
    #[doc = "Ch4 channel control"]
    pub mod d4_chcr {
        #[doc = "Register `D4_CHCR` reader"]
        pub type R = crate::R<D4ChcrSpec>;
        #[doc = "Register `D4_CHCR` writer"]
        pub type W = crate::W<D4ChcrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch4 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d4_chcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d4_chcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D4ChcrSpec;
        impl crate::RegisterSpec for D4ChcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d4_chcr::R`](R) reader structure"]
        impl crate::Readable for D4ChcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d4_chcr::W`](W) writer structure"]
        impl crate::Writable for D4ChcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D4_CHCR to value 0"]
        impl crate::Resettable for D4ChcrSpec {}
    }
    #[doc = "D4_MADR (rw) register accessor: Ch4 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d4_madr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d4_madr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d4_madr`] module"]
    #[doc(alias = "D4_MADR")]
    pub type D4Madr = crate::Reg<d4_madr::D4MadrSpec>;
    #[doc = "Ch4 memory address"]
    pub mod d4_madr {
        #[doc = "Register `D4_MADR` reader"]
        pub type R = crate::R<D4MadrSpec>;
        #[doc = "Register `D4_MADR` writer"]
        pub type W = crate::W<D4MadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch4 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d4_madr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d4_madr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D4MadrSpec;
        impl crate::RegisterSpec for D4MadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d4_madr::R`](R) reader structure"]
        impl crate::Readable for D4MadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d4_madr::W`](W) writer structure"]
        impl crate::Writable for D4MadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D4_MADR to value 0"]
        impl crate::Resettable for D4MadrSpec {}
    }
    #[doc = "D4_QWC (rw) register accessor: Ch4 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d4_qwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d4_qwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d4_qwc`] module"]
    #[doc(alias = "D4_QWC")]
    pub type D4Qwc = crate::Reg<d4_qwc::D4QwcSpec>;
    #[doc = "Ch4 quad word count"]
    pub mod d4_qwc {
        #[doc = "Register `D4_QWC` reader"]
        pub type R = crate::R<D4QwcSpec>;
        #[doc = "Register `D4_QWC` writer"]
        pub type W = crate::W<D4QwcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch4 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d4_qwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d4_qwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D4QwcSpec;
        impl crate::RegisterSpec for D4QwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d4_qwc::R`](R) reader structure"]
        impl crate::Readable for D4QwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d4_qwc::W`](W) writer structure"]
        impl crate::Writable for D4QwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D4_QWC to value 0"]
        impl crate::Resettable for D4QwcSpec {}
    }
    #[doc = "D4_TADR (rw) register accessor: Ch4 tag address\n\nYou can [`read`](crate::Reg::read) this register and get [`d4_tadr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d4_tadr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d4_tadr`] module"]
    #[doc(alias = "D4_TADR")]
    pub type D4Tadr = crate::Reg<d4_tadr::D4TadrSpec>;
    #[doc = "Ch4 tag address"]
    pub mod d4_tadr {
        #[doc = "Register `D4_TADR` reader"]
        pub type R = crate::R<D4TadrSpec>;
        #[doc = "Register `D4_TADR` writer"]
        pub type W = crate::W<D4TadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch4 tag address\n\nYou can [`read`](crate::Reg::read) this register and get [`d4_tadr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d4_tadr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D4TadrSpec;
        impl crate::RegisterSpec for D4TadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d4_tadr::R`](R) reader structure"]
        impl crate::Readable for D4TadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d4_tadr::W`](W) writer structure"]
        impl crate::Writable for D4TadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D4_TADR to value 0"]
        impl crate::Resettable for D4TadrSpec {}
    }
    #[doc = "D5_CHCR (rw) register accessor: Ch5 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d5_chcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d5_chcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d5_chcr`] module"]
    #[doc(alias = "D5_CHCR")]
    pub type D5Chcr = crate::Reg<d5_chcr::D5ChcrSpec>;
    #[doc = "Ch5 channel control"]
    pub mod d5_chcr {
        #[doc = "Register `D5_CHCR` reader"]
        pub type R = crate::R<D5ChcrSpec>;
        #[doc = "Register `D5_CHCR` writer"]
        pub type W = crate::W<D5ChcrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch5 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d5_chcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d5_chcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D5ChcrSpec;
        impl crate::RegisterSpec for D5ChcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d5_chcr::R`](R) reader structure"]
        impl crate::Readable for D5ChcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d5_chcr::W`](W) writer structure"]
        impl crate::Writable for D5ChcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D5_CHCR to value 0"]
        impl crate::Resettable for D5ChcrSpec {}
    }
    #[doc = "D5_MADR (rw) register accessor: Ch5 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d5_madr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d5_madr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d5_madr`] module"]
    #[doc(alias = "D5_MADR")]
    pub type D5Madr = crate::Reg<d5_madr::D5MadrSpec>;
    #[doc = "Ch5 memory address"]
    pub mod d5_madr {
        #[doc = "Register `D5_MADR` reader"]
        pub type R = crate::R<D5MadrSpec>;
        #[doc = "Register `D5_MADR` writer"]
        pub type W = crate::W<D5MadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch5 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d5_madr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d5_madr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D5MadrSpec;
        impl crate::RegisterSpec for D5MadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d5_madr::R`](R) reader structure"]
        impl crate::Readable for D5MadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d5_madr::W`](W) writer structure"]
        impl crate::Writable for D5MadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D5_MADR to value 0"]
        impl crate::Resettable for D5MadrSpec {}
    }
    #[doc = "D5_QWC (rw) register accessor: Ch5 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d5_qwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d5_qwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d5_qwc`] module"]
    #[doc(alias = "D5_QWC")]
    pub type D5Qwc = crate::Reg<d5_qwc::D5QwcSpec>;
    #[doc = "Ch5 quad word count"]
    pub mod d5_qwc {
        #[doc = "Register `D5_QWC` reader"]
        pub type R = crate::R<D5QwcSpec>;
        #[doc = "Register `D5_QWC` writer"]
        pub type W = crate::W<D5QwcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch5 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d5_qwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d5_qwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D5QwcSpec;
        impl crate::RegisterSpec for D5QwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d5_qwc::R`](R) reader structure"]
        impl crate::Readable for D5QwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d5_qwc::W`](W) writer structure"]
        impl crate::Writable for D5QwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D5_QWC to value 0"]
        impl crate::Resettable for D5QwcSpec {}
    }
    #[doc = "D6_CHCR (rw) register accessor: Ch6 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d6_chcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d6_chcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d6_chcr`] module"]
    #[doc(alias = "D6_CHCR")]
    pub type D6Chcr = crate::Reg<d6_chcr::D6ChcrSpec>;
    #[doc = "Ch6 channel control"]
    pub mod d6_chcr {
        #[doc = "Register `D6_CHCR` reader"]
        pub type R = crate::R<D6ChcrSpec>;
        #[doc = "Register `D6_CHCR` writer"]
        pub type W = crate::W<D6ChcrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch6 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d6_chcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d6_chcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D6ChcrSpec;
        impl crate::RegisterSpec for D6ChcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d6_chcr::R`](R) reader structure"]
        impl crate::Readable for D6ChcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d6_chcr::W`](W) writer structure"]
        impl crate::Writable for D6ChcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D6_CHCR to value 0"]
        impl crate::Resettable for D6ChcrSpec {}
    }
    #[doc = "D6_MADR (rw) register accessor: Ch6 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d6_madr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d6_madr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d6_madr`] module"]
    #[doc(alias = "D6_MADR")]
    pub type D6Madr = crate::Reg<d6_madr::D6MadrSpec>;
    #[doc = "Ch6 memory address"]
    pub mod d6_madr {
        #[doc = "Register `D6_MADR` reader"]
        pub type R = crate::R<D6MadrSpec>;
        #[doc = "Register `D6_MADR` writer"]
        pub type W = crate::W<D6MadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch6 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d6_madr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d6_madr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D6MadrSpec;
        impl crate::RegisterSpec for D6MadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d6_madr::R`](R) reader structure"]
        impl crate::Readable for D6MadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d6_madr::W`](W) writer structure"]
        impl crate::Writable for D6MadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D6_MADR to value 0"]
        impl crate::Resettable for D6MadrSpec {}
    }
    #[doc = "D6_QWC (rw) register accessor: Ch6 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d6_qwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d6_qwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d6_qwc`] module"]
    #[doc(alias = "D6_QWC")]
    pub type D6Qwc = crate::Reg<d6_qwc::D6QwcSpec>;
    #[doc = "Ch6 quad word count"]
    pub mod d6_qwc {
        #[doc = "Register `D6_QWC` reader"]
        pub type R = crate::R<D6QwcSpec>;
        #[doc = "Register `D6_QWC` writer"]
        pub type W = crate::W<D6QwcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch6 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d6_qwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d6_qwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D6QwcSpec;
        impl crate::RegisterSpec for D6QwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d6_qwc::R`](R) reader structure"]
        impl crate::Readable for D6QwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d6_qwc::W`](W) writer structure"]
        impl crate::Writable for D6QwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D6_QWC to value 0"]
        impl crate::Resettable for D6QwcSpec {}
    }
    #[doc = "D6_TADR (rw) register accessor: Ch6 tag address\n\nYou can [`read`](crate::Reg::read) this register and get [`d6_tadr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d6_tadr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d6_tadr`] module"]
    #[doc(alias = "D6_TADR")]
    pub type D6Tadr = crate::Reg<d6_tadr::D6TadrSpec>;
    #[doc = "Ch6 tag address"]
    pub mod d6_tadr {
        #[doc = "Register `D6_TADR` reader"]
        pub type R = crate::R<D6TadrSpec>;
        #[doc = "Register `D6_TADR` writer"]
        pub type W = crate::W<D6TadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch6 tag address\n\nYou can [`read`](crate::Reg::read) this register and get [`d6_tadr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d6_tadr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D6TadrSpec;
        impl crate::RegisterSpec for D6TadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d6_tadr::R`](R) reader structure"]
        impl crate::Readable for D6TadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d6_tadr::W`](W) writer structure"]
        impl crate::Writable for D6TadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D6_TADR to value 0"]
        impl crate::Resettable for D6TadrSpec {}
    }
    #[doc = "D7_CHCR (rw) register accessor: Ch7 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d7_chcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d7_chcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d7_chcr`] module"]
    #[doc(alias = "D7_CHCR")]
    pub type D7Chcr = crate::Reg<d7_chcr::D7ChcrSpec>;
    #[doc = "Ch7 channel control"]
    pub mod d7_chcr {
        #[doc = "Register `D7_CHCR` reader"]
        pub type R = crate::R<D7ChcrSpec>;
        #[doc = "Register `D7_CHCR` writer"]
        pub type W = crate::W<D7ChcrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch7 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d7_chcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d7_chcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D7ChcrSpec;
        impl crate::RegisterSpec for D7ChcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d7_chcr::R`](R) reader structure"]
        impl crate::Readable for D7ChcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d7_chcr::W`](W) writer structure"]
        impl crate::Writable for D7ChcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D7_CHCR to value 0"]
        impl crate::Resettable for D7ChcrSpec {}
    }
    #[doc = "D7_MADR (rw) register accessor: Ch7 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d7_madr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d7_madr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d7_madr`] module"]
    #[doc(alias = "D7_MADR")]
    pub type D7Madr = crate::Reg<d7_madr::D7MadrSpec>;
    #[doc = "Ch7 memory address"]
    pub mod d7_madr {
        #[doc = "Register `D7_MADR` reader"]
        pub type R = crate::R<D7MadrSpec>;
        #[doc = "Register `D7_MADR` writer"]
        pub type W = crate::W<D7MadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch7 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d7_madr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d7_madr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D7MadrSpec;
        impl crate::RegisterSpec for D7MadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d7_madr::R`](R) reader structure"]
        impl crate::Readable for D7MadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d7_madr::W`](W) writer structure"]
        impl crate::Writable for D7MadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D7_MADR to value 0"]
        impl crate::Resettable for D7MadrSpec {}
    }
    #[doc = "D7_QWC (rw) register accessor: Ch7 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d7_qwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d7_qwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d7_qwc`] module"]
    #[doc(alias = "D7_QWC")]
    pub type D7Qwc = crate::Reg<d7_qwc::D7QwcSpec>;
    #[doc = "Ch7 quad word count"]
    pub mod d7_qwc {
        #[doc = "Register `D7_QWC` reader"]
        pub type R = crate::R<D7QwcSpec>;
        #[doc = "Register `D7_QWC` writer"]
        pub type W = crate::W<D7QwcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch7 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d7_qwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d7_qwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D7QwcSpec;
        impl crate::RegisterSpec for D7QwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d7_qwc::R`](R) reader structure"]
        impl crate::Readable for D7QwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d7_qwc::W`](W) writer structure"]
        impl crate::Writable for D7QwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D7_QWC to value 0"]
        impl crate::Resettable for D7QwcSpec {}
    }
    #[doc = "D8_CHCR (rw) register accessor: Ch8 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d8_chcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d8_chcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d8_chcr`] module"]
    #[doc(alias = "D8_CHCR")]
    pub type D8Chcr = crate::Reg<d8_chcr::D8ChcrSpec>;
    #[doc = "Ch8 channel control"]
    pub mod d8_chcr {
        #[doc = "Register `D8_CHCR` reader"]
        pub type R = crate::R<D8ChcrSpec>;
        #[doc = "Register `D8_CHCR` writer"]
        pub type W = crate::W<D8ChcrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch8 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d8_chcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d8_chcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D8ChcrSpec;
        impl crate::RegisterSpec for D8ChcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d8_chcr::R`](R) reader structure"]
        impl crate::Readable for D8ChcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d8_chcr::W`](W) writer structure"]
        impl crate::Writable for D8ChcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D8_CHCR to value 0"]
        impl crate::Resettable for D8ChcrSpec {}
    }
    #[doc = "D8_MADR (rw) register accessor: Ch8 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d8_madr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d8_madr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d8_madr`] module"]
    #[doc(alias = "D8_MADR")]
    pub type D8Madr = crate::Reg<d8_madr::D8MadrSpec>;
    #[doc = "Ch8 memory address"]
    pub mod d8_madr {
        #[doc = "Register `D8_MADR` reader"]
        pub type R = crate::R<D8MadrSpec>;
        #[doc = "Register `D8_MADR` writer"]
        pub type W = crate::W<D8MadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch8 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d8_madr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d8_madr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D8MadrSpec;
        impl crate::RegisterSpec for D8MadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d8_madr::R`](R) reader structure"]
        impl crate::Readable for D8MadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d8_madr::W`](W) writer structure"]
        impl crate::Writable for D8MadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D8_MADR to value 0"]
        impl crate::Resettable for D8MadrSpec {}
    }
    #[doc = "D8_QWC (rw) register accessor: Ch8 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d8_qwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d8_qwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d8_qwc`] module"]
    #[doc(alias = "D8_QWC")]
    pub type D8Qwc = crate::Reg<d8_qwc::D8QwcSpec>;
    #[doc = "Ch8 quad word count"]
    pub mod d8_qwc {
        #[doc = "Register `D8_QWC` reader"]
        pub type R = crate::R<D8QwcSpec>;
        #[doc = "Register `D8_QWC` writer"]
        pub type W = crate::W<D8QwcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch8 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d8_qwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d8_qwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D8QwcSpec;
        impl crate::RegisterSpec for D8QwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d8_qwc::R`](R) reader structure"]
        impl crate::Readable for D8QwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d8_qwc::W`](W) writer structure"]
        impl crate::Writable for D8QwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D8_QWC to value 0"]
        impl crate::Resettable for D8QwcSpec {}
    }
    #[doc = "D8_SADR (rw) register accessor: Ch8 SPR address\n\nYou can [`read`](crate::Reg::read) this register and get [`d8_sadr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d8_sadr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d8_sadr`] module"]
    #[doc(alias = "D8_SADR")]
    pub type D8Sadr = crate::Reg<d8_sadr::D8SadrSpec>;
    #[doc = "Ch8 SPR address"]
    pub mod d8_sadr {
        #[doc = "Register `D8_SADR` reader"]
        pub type R = crate::R<D8SadrSpec>;
        #[doc = "Register `D8_SADR` writer"]
        pub type W = crate::W<D8SadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch8 SPR address\n\nYou can [`read`](crate::Reg::read) this register and get [`d8_sadr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d8_sadr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D8SadrSpec;
        impl crate::RegisterSpec for D8SadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d8_sadr::R`](R) reader structure"]
        impl crate::Readable for D8SadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d8_sadr::W`](W) writer structure"]
        impl crate::Writable for D8SadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D8_SADR to value 0"]
        impl crate::Resettable for D8SadrSpec {}
    }
    #[doc = "D9_CHCR (rw) register accessor: Ch9 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d9_chcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d9_chcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d9_chcr`] module"]
    #[doc(alias = "D9_CHCR")]
    pub type D9Chcr = crate::Reg<d9_chcr::D9ChcrSpec>;
    #[doc = "Ch9 channel control"]
    pub mod d9_chcr {
        #[doc = "Register `D9_CHCR` reader"]
        pub type R = crate::R<D9ChcrSpec>;
        #[doc = "Register `D9_CHCR` writer"]
        pub type W = crate::W<D9ChcrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch9 channel control\n\nYou can [`read`](crate::Reg::read) this register and get [`d9_chcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d9_chcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D9ChcrSpec;
        impl crate::RegisterSpec for D9ChcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d9_chcr::R`](R) reader structure"]
        impl crate::Readable for D9ChcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d9_chcr::W`](W) writer structure"]
        impl crate::Writable for D9ChcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D9_CHCR to value 0"]
        impl crate::Resettable for D9ChcrSpec {}
    }
    #[doc = "D9_MADR (rw) register accessor: Ch9 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d9_madr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d9_madr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d9_madr`] module"]
    #[doc(alias = "D9_MADR")]
    pub type D9Madr = crate::Reg<d9_madr::D9MadrSpec>;
    #[doc = "Ch9 memory address"]
    pub mod d9_madr {
        #[doc = "Register `D9_MADR` reader"]
        pub type R = crate::R<D9MadrSpec>;
        #[doc = "Register `D9_MADR` writer"]
        pub type W = crate::W<D9MadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch9 memory address\n\nYou can [`read`](crate::Reg::read) this register and get [`d9_madr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d9_madr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D9MadrSpec;
        impl crate::RegisterSpec for D9MadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d9_madr::R`](R) reader structure"]
        impl crate::Readable for D9MadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d9_madr::W`](W) writer structure"]
        impl crate::Writable for D9MadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D9_MADR to value 0"]
        impl crate::Resettable for D9MadrSpec {}
    }
    #[doc = "D9_QWC (rw) register accessor: Ch9 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d9_qwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d9_qwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d9_qwc`] module"]
    #[doc(alias = "D9_QWC")]
    pub type D9Qwc = crate::Reg<d9_qwc::D9QwcSpec>;
    #[doc = "Ch9 quad word count"]
    pub mod d9_qwc {
        #[doc = "Register `D9_QWC` reader"]
        pub type R = crate::R<D9QwcSpec>;
        #[doc = "Register `D9_QWC` writer"]
        pub type W = crate::W<D9QwcSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch9 quad word count\n\nYou can [`read`](crate::Reg::read) this register and get [`d9_qwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d9_qwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D9QwcSpec;
        impl crate::RegisterSpec for D9QwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d9_qwc::R`](R) reader structure"]
        impl crate::Readable for D9QwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d9_qwc::W`](W) writer structure"]
        impl crate::Writable for D9QwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D9_QWC to value 0"]
        impl crate::Resettable for D9QwcSpec {}
    }
    #[doc = "D9_SADR (rw) register accessor: Ch9 SPR address\n\nYou can [`read`](crate::Reg::read) this register and get [`d9_sadr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d9_sadr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d9_sadr`] module"]
    #[doc(alias = "D9_SADR")]
    pub type D9Sadr = crate::Reg<d9_sadr::D9SadrSpec>;
    #[doc = "Ch9 SPR address"]
    pub mod d9_sadr {
        #[doc = "Register `D9_SADR` reader"]
        pub type R = crate::R<D9SadrSpec>;
        #[doc = "Register `D9_SADR` writer"]
        pub type W = crate::W<D9SadrSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Ch9 SPR address\n\nYou can [`read`](crate::Reg::read) this register and get [`d9_sadr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d9_sadr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct D9SadrSpec;
        impl crate::RegisterSpec for D9SadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d9_sadr::R`](R) reader structure"]
        impl crate::Readable for D9SadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d9_sadr::W`](W) writer structure"]
        impl crate::Writable for D9SadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D9_SADR to value 0"]
        impl crate::Resettable for D9SadrSpec {}
    }
    #[doc = "D_CTRL (rw) register accessor: DMAC control\n\nYou can [`read`](crate::Reg::read) this register and get [`d_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d_ctrl`] module"]
    #[doc(alias = "D_CTRL")]
    pub type DCtrl = crate::Reg<d_ctrl::DCtrlSpec>;
    #[doc = "DMAC control"]
    pub mod d_ctrl {
        #[doc = "Register `D_CTRL` reader"]
        pub type R = crate::R<DCtrlSpec>;
        #[doc = "Register `D_CTRL` writer"]
        pub type W = crate::W<DCtrlSpec>;
        #[doc = "DMA Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Dmae {
            #[doc = "0: Disables all DMAs"]
            Disable = 0,
            #[doc = "1: Enables all DMAs"]
            Enable = 1,
        }
        impl From<Dmae> for bool {
            #[inline(always)]
            fn from(variant: Dmae) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `DMAE` reader - DMA Enable"]
        pub type DmaeR = crate::BitReader<Dmae>;
        impl DmaeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Dmae {
                match self.bits {
                    false => Dmae::Disable,
                    true => Dmae::Enable,
                }
            }
            #[doc = "Disables all DMAs"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Dmae::Disable
            }
            #[doc = "Enables all DMAs"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Dmae::Enable
            }
        }
        #[doc = "Field `DMAE` writer - DMA Enable"]
        pub type DmaeW<'a, REG> = crate::BitWriter<'a, REG, Dmae>;
        impl<'a, REG> DmaeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disables all DMAs"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Dmae::Disable)
            }
            #[doc = "Enables all DMAs"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Dmae::Enable)
            }
        }
        #[doc = "Release signal enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Rele {
            #[doc = "0: Cycle stealing off"]
            Off = 0,
            #[doc = "1: Cycle stealing on"]
            On = 1,
        }
        impl From<Rele> for bool {
            #[inline(always)]
            fn from(variant: Rele) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RELE` reader - Release signal enable"]
        pub type ReleR = crate::BitReader<Rele>;
        impl ReleR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Rele {
                match self.bits {
                    false => Rele::Off,
                    true => Rele::On,
                }
            }
            #[doc = "Cycle stealing off"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Rele::Off
            }
            #[doc = "Cycle stealing on"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Rele::On
            }
        }
        #[doc = "Field `RELE` writer - Release signal enable"]
        pub type ReleW<'a, REG> = crate::BitWriter<'a, REG, Rele>;
        impl<'a, REG> ReleW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Cycle stealing off"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Rele::Off)
            }
            #[doc = "Cycle stealing on"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Rele::On)
            }
        }
        #[doc = "Memory FIFO drain channel\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Mfd {
            #[doc = "0: Does not use MFIFO function."]
            Off = 0,
            #[doc = "2: VIF1 channel (ch-1)"]
            Vif1 = 2,
            #[doc = "3: GIF channel (ch-2)"]
            Gif = 3,
        }
        impl From<Mfd> for u8 {
            #[inline(always)]
            fn from(variant: Mfd) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Mfd {
            type Ux = u8;
        }
        impl crate::IsEnum for Mfd {}
        #[doc = "Field `MFD` reader - Memory FIFO drain channel"]
        pub type MfdR = crate::FieldReader<Mfd>;
        impl MfdR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Mfd> {
                match self.bits {
                    0 => Some(Mfd::Off),
                    2 => Some(Mfd::Vif1),
                    3 => Some(Mfd::Gif),
                    _ => None,
                }
            }
            #[doc = "Does not use MFIFO function."]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Mfd::Off
            }
            #[doc = "VIF1 channel (ch-1)"]
            #[inline(always)]
            pub fn is_vif1(&self) -> bool {
                *self == Mfd::Vif1
            }
            #[doc = "GIF channel (ch-2)"]
            #[inline(always)]
            pub fn is_gif(&self) -> bool {
                *self == Mfd::Gif
            }
        }
        #[doc = "Field `MFD` writer - Memory FIFO drain channel"]
        pub type MfdW<'a, REG> = crate::FieldWriter<'a, REG, 2, Mfd>;
        impl<'a, REG> MfdW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Does not use MFIFO function."]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Mfd::Off)
            }
            #[doc = "VIF1 channel (ch-1)"]
            #[inline(always)]
            pub fn vif1(self) -> &'a mut crate::W<REG> {
                self.variant(Mfd::Vif1)
            }
            #[doc = "GIF channel (ch-2)"]
            #[inline(always)]
            pub fn gif(self) -> &'a mut crate::W<REG> {
                self.variant(Mfd::Gif)
            }
        }
        #[doc = "Stall Control source channel\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Sts {
            #[doc = "0: Non-specified (Does not update D_STADR)"]
            None = 0,
            #[doc = "1: SIF0 channel (ch-5)"]
            Sif0 = 1,
            #[doc = "2: fromSPR channel (ch-8)"]
            FromSpr = 2,
            #[doc = "3: fromIPU channel (ch-3)"]
            FromIpu = 3,
        }
        impl From<Sts> for u8 {
            #[inline(always)]
            fn from(variant: Sts) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Sts {
            type Ux = u8;
        }
        impl crate::IsEnum for Sts {}
        #[doc = "Field `STS` reader - Stall Control source channel"]
        pub type StsR = crate::FieldReader<Sts>;
        impl StsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sts {
                match self.bits {
                    0 => Sts::None,
                    1 => Sts::Sif0,
                    2 => Sts::FromSpr,
                    3 => Sts::FromIpu,
                    _ => unreachable!(),
                }
            }
            #[doc = "Non-specified (Does not update D_STADR)"]
            #[inline(always)]
            pub fn is_none(&self) -> bool {
                *self == Sts::None
            }
            #[doc = "SIF0 channel (ch-5)"]
            #[inline(always)]
            pub fn is_sif0(&self) -> bool {
                *self == Sts::Sif0
            }
            #[doc = "fromSPR channel (ch-8)"]
            #[inline(always)]
            pub fn is_from_spr(&self) -> bool {
                *self == Sts::FromSpr
            }
            #[doc = "fromIPU channel (ch-3)"]
            #[inline(always)]
            pub fn is_from_ipu(&self) -> bool {
                *self == Sts::FromIpu
            }
        }
        #[doc = "Field `STS` writer - Stall Control source channel"]
        pub type StsW<'a, REG> = crate::FieldWriter<'a, REG, 2, Sts, crate::Safe>;
        impl<'a, REG> StsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Non-specified (Does not update D_STADR)"]
            #[inline(always)]
            pub fn none(self) -> &'a mut crate::W<REG> {
                self.variant(Sts::None)
            }
            #[doc = "SIF0 channel (ch-5)"]
            #[inline(always)]
            pub fn sif0(self) -> &'a mut crate::W<REG> {
                self.variant(Sts::Sif0)
            }
            #[doc = "fromSPR channel (ch-8)"]
            #[inline(always)]
            pub fn from_spr(self) -> &'a mut crate::W<REG> {
                self.variant(Sts::FromSpr)
            }
            #[doc = "fromIPU channel (ch-3)"]
            #[inline(always)]
            pub fn from_ipu(self) -> &'a mut crate::W<REG> {
                self.variant(Sts::FromIpu)
            }
        }
        #[doc = "Stall Control drain channel\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Std {
            #[doc = "0: Does not perform stall control"]
            Off = 0,
            #[doc = "1: VIF1 channel (ch-1)"]
            Vif1 = 1,
            #[doc = "2: GIF channel (ch-2)"]
            Gif = 2,
            #[doc = "3: SIF1 channel (ch-6)"]
            Sif1 = 3,
        }
        impl From<Std> for u8 {
            #[inline(always)]
            fn from(variant: Std) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Std {
            type Ux = u8;
        }
        impl crate::IsEnum for Std {}
        #[doc = "Field `STD` reader - Stall Control drain channel"]
        pub type StdR = crate::FieldReader<Std>;
        impl StdR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Std {
                match self.bits {
                    0 => Std::Off,
                    1 => Std::Vif1,
                    2 => Std::Gif,
                    3 => Std::Sif1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Does not perform stall control"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Std::Off
            }
            #[doc = "VIF1 channel (ch-1)"]
            #[inline(always)]
            pub fn is_vif1(&self) -> bool {
                *self == Std::Vif1
            }
            #[doc = "GIF channel (ch-2)"]
            #[inline(always)]
            pub fn is_gif(&self) -> bool {
                *self == Std::Gif
            }
            #[doc = "SIF1 channel (ch-6)"]
            #[inline(always)]
            pub fn is_sif1(&self) -> bool {
                *self == Std::Sif1
            }
        }
        #[doc = "Field `STD` writer - Stall Control drain channel"]
        pub type StdW<'a, REG> = crate::FieldWriter<'a, REG, 2, Std, crate::Safe>;
        impl<'a, REG> StdW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Does not perform stall control"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Std::Off)
            }
            #[doc = "VIF1 channel (ch-1)"]
            #[inline(always)]
            pub fn vif1(self) -> &'a mut crate::W<REG> {
                self.variant(Std::Vif1)
            }
            #[doc = "GIF channel (ch-2)"]
            #[inline(always)]
            pub fn gif(self) -> &'a mut crate::W<REG> {
                self.variant(Std::Gif)
            }
            #[doc = "SIF1 channel (ch-6)"]
            #[inline(always)]
            pub fn sif1(self) -> &'a mut crate::W<REG> {
                self.variant(Std::Sif1)
            }
        }
        #[doc = "Release cycle\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Rcyc {
            #[doc = "0: Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            Cycle8 = 0,
            #[doc = "1: Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            Cycle16 = 1,
            #[doc = "2: Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            Cycle32 = 2,
            #[doc = "3: Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            Cycle64 = 3,
            #[doc = "4: Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            Cycle128 = 4,
            #[doc = "5: Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            Cycle256 = 5,
        }
        impl From<Rcyc> for u8 {
            #[inline(always)]
            fn from(variant: Rcyc) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Rcyc {
            type Ux = u8;
        }
        impl crate::IsEnum for Rcyc {}
        #[doc = "Field `RCYC` reader - Release cycle"]
        pub type RcycR = crate::FieldReader<Rcyc>;
        impl RcycR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<Rcyc> {
                match self.bits {
                    0 => Some(Rcyc::Cycle8),
                    1 => Some(Rcyc::Cycle16),
                    2 => Some(Rcyc::Cycle32),
                    3 => Some(Rcyc::Cycle64),
                    4 => Some(Rcyc::Cycle128),
                    5 => Some(Rcyc::Cycle256),
                    _ => None,
                }
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn is_cycle_8(&self) -> bool {
                *self == Rcyc::Cycle8
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn is_cycle_16(&self) -> bool {
                *self == Rcyc::Cycle16
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn is_cycle_32(&self) -> bool {
                *self == Rcyc::Cycle32
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn is_cycle_64(&self) -> bool {
                *self == Rcyc::Cycle64
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn is_cycle_128(&self) -> bool {
                *self == Rcyc::Cycle128
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn is_cycle_256(&self) -> bool {
                *self == Rcyc::Cycle256
            }
        }
        #[doc = "Field `RCYC` writer - Release cycle"]
        pub type RcycW<'a, REG> = crate::FieldWriter<'a, REG, 3, Rcyc>;
        impl<'a, REG> RcycW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn cycle_8(self) -> &'a mut crate::W<REG> {
                self.variant(Rcyc::Cycle8)
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn cycle_16(self) -> &'a mut crate::W<REG> {
                self.variant(Rcyc::Cycle16)
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn cycle_32(self) -> &'a mut crate::W<REG> {
                self.variant(Rcyc::Cycle32)
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn cycle_64(self) -> &'a mut crate::W<REG> {
                self.variant(Rcyc::Cycle64)
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn cycle_128(self) -> &'a mut crate::W<REG> {
                self.variant(Rcyc::Cycle128)
            }
            #[doc = "Number of cycles to release the bbus to EE core when Cycle Stealing is on"]
            #[inline(always)]
            pub fn cycle_256(self) -> &'a mut crate::W<REG> {
                self.variant(Rcyc::Cycle256)
            }
        }
        impl R {
            #[doc = "Bit 0 - DMA Enable"]
            #[inline(always)]
            pub fn dmae(&self) -> DmaeR {
                DmaeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Release signal enable"]
            #[inline(always)]
            pub fn rele(&self) -> ReleR {
                ReleR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:3 - Memory FIFO drain channel"]
            #[inline(always)]
            pub fn mfd(&self) -> MfdR {
                MfdR::new(((self.bits >> 2) & 3) as u8)
            }
            #[doc = "Bits 4:5 - Stall Control source channel"]
            #[inline(always)]
            pub fn sts(&self) -> StsR {
                StsR::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Stall Control drain channel"]
            #[inline(always)]
            pub fn std(&self) -> StdR {
                StdR::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:10 - Release cycle"]
            #[inline(always)]
            pub fn rcyc(&self) -> RcycR {
                RcycR::new(((self.bits >> 8) & 7) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - DMA Enable"]
            #[inline(always)]
            pub fn dmae(&mut self) -> DmaeW<DCtrlSpec> {
                DmaeW::new(self, 0)
            }
            #[doc = "Bit 1 - Release signal enable"]
            #[inline(always)]
            pub fn rele(&mut self) -> ReleW<DCtrlSpec> {
                ReleW::new(self, 1)
            }
            #[doc = "Bits 2:3 - Memory FIFO drain channel"]
            #[inline(always)]
            pub fn mfd(&mut self) -> MfdW<DCtrlSpec> {
                MfdW::new(self, 2)
            }
            #[doc = "Bits 4:5 - Stall Control source channel"]
            #[inline(always)]
            pub fn sts(&mut self) -> StsW<DCtrlSpec> {
                StsW::new(self, 4)
            }
            #[doc = "Bits 6:7 - Stall Control drain channel"]
            #[inline(always)]
            pub fn std(&mut self) -> StdW<DCtrlSpec> {
                StdW::new(self, 6)
            }
            #[doc = "Bits 8:10 - Release cycle"]
            #[inline(always)]
            pub fn rcyc(&mut self) -> RcycW<DCtrlSpec> {
                RcycW::new(self, 8)
            }
        }
        #[doc = "DMAC control\n\nYou can [`read`](crate::Reg::read) this register and get [`d_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DCtrlSpec;
        impl crate::RegisterSpec for DCtrlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d_ctrl::R`](R) reader structure"]
        impl crate::Readable for DCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`d_ctrl::W`](W) writer structure"]
        impl crate::Writable for DCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D_CTRL to value 0"]
        impl crate::Resettable for DCtrlSpec {}
    }
    #[doc = "D_STAT (rw) register accessor: DMAC status\n\nYou can [`read`](crate::Reg::read) this register and get [`d_stat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_stat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d_stat`] module"]
    #[doc(alias = "D_STAT")]
    pub type DStat = crate::Reg<d_stat::DStatSpec>;
    #[doc = "DMAC status"]
    pub mod d_stat {
        #[doc = "Register `D_STAT` reader"]
        pub type R = crate::R<DStatSpec>;
        #[doc = "Register `D_STAT` writer"]
        pub type W = crate::W<DStatSpec>;
        #[doc = "Field `CIS0` reader - Channel interrupt status (ch-0)"]
        pub type Cis0R = crate::BitReader;
        #[doc = "Field `CIS0` writer - Channel interrupt status (ch-0)"]
        pub type Cis0W<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `CIS1` reader - Channel interrupt status (ch-1)"]
        pub type Cis1R = crate::BitReader;
        #[doc = "Field `CIS1` writer - Channel interrupt status (ch-1)"]
        pub type Cis1W<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `CIS2` reader - Channel interrupt status (ch-2)"]
        pub type Cis2R = crate::BitReader;
        #[doc = "Field `CIS2` writer - Channel interrupt status (ch-2)"]
        pub type Cis2W<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `CIS3` reader - Channel interrupt status (ch-3)"]
        pub type Cis3R = crate::BitReader;
        #[doc = "Field `CIS3` writer - Channel interrupt status (ch-3)"]
        pub type Cis3W<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `CIS4` reader - Channel interrupt status (ch-4)"]
        pub type Cis4R = crate::BitReader;
        #[doc = "Field `CIS4` writer - Channel interrupt status (ch-4)"]
        pub type Cis4W<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `CIS5` reader - Channel interrupt status (ch-5)"]
        pub type Cis5R = crate::BitReader;
        #[doc = "Field `CIS5` writer - Channel interrupt status (ch-5)"]
        pub type Cis5W<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `CIS6` reader - Channel interrupt status (ch-6)"]
        pub type Cis6R = crate::BitReader;
        #[doc = "Field `CIS6` writer - Channel interrupt status (ch-6)"]
        pub type Cis6W<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `CIS7` reader - Channel interrupt status (ch-7)"]
        pub type Cis7R = crate::BitReader;
        #[doc = "Field `CIS7` writer - Channel interrupt status (ch-7)"]
        pub type Cis7W<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `CIS8` reader - Channel interrupt status (ch-8)"]
        pub type Cis8R = crate::BitReader;
        #[doc = "Field `CIS8` writer - Channel interrupt status (ch-8)"]
        pub type Cis8W<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `CIS9` reader - Channel interrupt status (ch-9)"]
        pub type Cis9R = crate::BitReader;
        #[doc = "Field `CIS9` writer - Channel interrupt status (ch-9)"]
        pub type Cis9W<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `SIS` reader - DMA Stall interrupt status"]
        pub type SisR = crate::BitReader;
        #[doc = "Field `SIS` writer - DMA Stall interrupt status"]
        pub type SisW<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `MEIS` reader - MFIFO empty interrupt status"]
        pub type MeisR = crate::BitReader;
        #[doc = "Field `MEIS` writer - MFIFO empty interrupt status"]
        pub type MeisW<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Field `BEIS` reader - BUSERR interrupt status"]
        pub type BeisR = crate::BitReader;
        #[doc = "Field `BEIS` writer - BUSERR interrupt status"]
        pub type BeisW<'a, REG> = crate::BitWriter1C<'a, REG>;
        #[doc = "Channel interrupt mask (ch-0)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cim0 {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cim0> for bool {
            #[inline(always)]
            fn from(variant: Cim0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIM0` reader - Channel interrupt mask (ch-0)"]
        pub type Cim0R = crate::BitReader<Cim0>;
        impl Cim0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cim0 {
                match self.bits {
                    false => Cim0::Disable,
                    true => Cim0::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cim0::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cim0::Enable
            }
        }
        #[doc = "Field `CIM0` writer - Channel interrupt mask (ch-0)"]
        pub type Cim0W<'a, REG> = crate::BitWriter<'a, REG, Cim0>;
        impl<'a, REG> Cim0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim0::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim0::Enable)
            }
        }
        #[doc = "Channel interrupt mask (ch-1)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cim1 {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cim1> for bool {
            #[inline(always)]
            fn from(variant: Cim1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIM1` reader - Channel interrupt mask (ch-1)"]
        pub type Cim1R = crate::BitReader<Cim1>;
        impl Cim1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cim1 {
                match self.bits {
                    false => Cim1::Disable,
                    true => Cim1::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cim1::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cim1::Enable
            }
        }
        #[doc = "Field `CIM1` writer - Channel interrupt mask (ch-1)"]
        pub type Cim1W<'a, REG> = crate::BitWriter<'a, REG, Cim1>;
        impl<'a, REG> Cim1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim1::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim1::Enable)
            }
        }
        #[doc = "Channel interrupt mask (ch-2)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cim2 {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cim2> for bool {
            #[inline(always)]
            fn from(variant: Cim2) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIM2` reader - Channel interrupt mask (ch-2)"]
        pub type Cim2R = crate::BitReader<Cim2>;
        impl Cim2R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cim2 {
                match self.bits {
                    false => Cim2::Disable,
                    true => Cim2::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cim2::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cim2::Enable
            }
        }
        #[doc = "Field `CIM2` writer - Channel interrupt mask (ch-2)"]
        pub type Cim2W<'a, REG> = crate::BitWriter<'a, REG, Cim2>;
        impl<'a, REG> Cim2W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim2::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim2::Enable)
            }
        }
        #[doc = "Channel interrupt mask (ch-3)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cim3 {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cim3> for bool {
            #[inline(always)]
            fn from(variant: Cim3) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIM3` reader - Channel interrupt mask (ch-3)"]
        pub type Cim3R = crate::BitReader<Cim3>;
        impl Cim3R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cim3 {
                match self.bits {
                    false => Cim3::Disable,
                    true => Cim3::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cim3::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cim3::Enable
            }
        }
        #[doc = "Field `CIM3` writer - Channel interrupt mask (ch-3)"]
        pub type Cim3W<'a, REG> = crate::BitWriter<'a, REG, Cim3>;
        impl<'a, REG> Cim3W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim3::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim3::Enable)
            }
        }
        #[doc = "Channel interrupt mask (ch-4)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cim4 {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cim4> for bool {
            #[inline(always)]
            fn from(variant: Cim4) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIM4` reader - Channel interrupt mask (ch-4)"]
        pub type Cim4R = crate::BitReader<Cim4>;
        impl Cim4R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cim4 {
                match self.bits {
                    false => Cim4::Disable,
                    true => Cim4::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cim4::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cim4::Enable
            }
        }
        #[doc = "Field `CIM4` writer - Channel interrupt mask (ch-4)"]
        pub type Cim4W<'a, REG> = crate::BitWriter<'a, REG, Cim4>;
        impl<'a, REG> Cim4W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim4::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim4::Enable)
            }
        }
        #[doc = "Channel interrupt mask (ch-5)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cim5 {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cim5> for bool {
            #[inline(always)]
            fn from(variant: Cim5) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIM5` reader - Channel interrupt mask (ch-5)"]
        pub type Cim5R = crate::BitReader<Cim5>;
        impl Cim5R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cim5 {
                match self.bits {
                    false => Cim5::Disable,
                    true => Cim5::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cim5::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cim5::Enable
            }
        }
        #[doc = "Field `CIM5` writer - Channel interrupt mask (ch-5)"]
        pub type Cim5W<'a, REG> = crate::BitWriter<'a, REG, Cim5>;
        impl<'a, REG> Cim5W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim5::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim5::Enable)
            }
        }
        #[doc = "Channel interrupt mask (ch-6)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cim6 {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cim6> for bool {
            #[inline(always)]
            fn from(variant: Cim6) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIM6` reader - Channel interrupt mask (ch-6)"]
        pub type Cim6R = crate::BitReader<Cim6>;
        impl Cim6R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cim6 {
                match self.bits {
                    false => Cim6::Disable,
                    true => Cim6::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cim6::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cim6::Enable
            }
        }
        #[doc = "Field `CIM6` writer - Channel interrupt mask (ch-6)"]
        pub type Cim6W<'a, REG> = crate::BitWriter<'a, REG, Cim6>;
        impl<'a, REG> Cim6W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim6::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim6::Enable)
            }
        }
        #[doc = "Channel interrupt mask (ch-7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cim7 {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cim7> for bool {
            #[inline(always)]
            fn from(variant: Cim7) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIM7` reader - Channel interrupt mask (ch-7)"]
        pub type Cim7R = crate::BitReader<Cim7>;
        impl Cim7R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cim7 {
                match self.bits {
                    false => Cim7::Disable,
                    true => Cim7::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cim7::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cim7::Enable
            }
        }
        #[doc = "Field `CIM7` writer - Channel interrupt mask (ch-7)"]
        pub type Cim7W<'a, REG> = crate::BitWriter<'a, REG, Cim7>;
        impl<'a, REG> Cim7W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim7::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim7::Enable)
            }
        }
        #[doc = "Channel interrupt mask (ch-8)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cim8 {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cim8> for bool {
            #[inline(always)]
            fn from(variant: Cim8) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIM8` reader - Channel interrupt mask (ch-8)"]
        pub type Cim8R = crate::BitReader<Cim8>;
        impl Cim8R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cim8 {
                match self.bits {
                    false => Cim8::Disable,
                    true => Cim8::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cim8::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cim8::Enable
            }
        }
        #[doc = "Field `CIM8` writer - Channel interrupt mask (ch-8)"]
        pub type Cim8W<'a, REG> = crate::BitWriter<'a, REG, Cim8>;
        impl<'a, REG> Cim8W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim8::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim8::Enable)
            }
        }
        #[doc = "Channel interrupt mask (ch-9)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cim9 {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cim9> for bool {
            #[inline(always)]
            fn from(variant: Cim9) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CIM9` reader - Channel interrupt mask (ch-9)"]
        pub type Cim9R = crate::BitReader<Cim9>;
        impl Cim9R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cim9 {
                match self.bits {
                    false => Cim9::Disable,
                    true => Cim9::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cim9::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cim9::Enable
            }
        }
        #[doc = "Field `CIM9` writer - Channel interrupt mask (ch-9)"]
        pub type Cim9W<'a, REG> = crate::BitWriter<'a, REG, Cim9>;
        impl<'a, REG> Cim9W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim9::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cim9::Enable)
            }
        }
        #[doc = "DMA stall interrupt mask\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sim {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Sim> for bool {
            #[inline(always)]
            fn from(variant: Sim) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SIM` reader - DMA stall interrupt mask"]
        pub type SimR = crate::BitReader<Sim>;
        impl SimR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sim {
                match self.bits {
                    false => Sim::Disable,
                    true => Sim::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Sim::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Sim::Enable
            }
        }
        #[doc = "Field `SIM` writer - DMA stall interrupt mask"]
        pub type SimW<'a, REG> = crate::BitWriter<'a, REG, Sim>;
        impl<'a, REG> SimW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Sim::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Sim::Enable)
            }
        }
        #[doc = "MFIFO empty interrupt mask\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Meim {
            #[doc = "0: Disable"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Meim> for bool {
            #[inline(always)]
            fn from(variant: Meim) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `MEIM` reader - MFIFO empty interrupt mask"]
        pub type MeimR = crate::BitReader<Meim>;
        impl MeimR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Meim {
                match self.bits {
                    false => Meim::Disable,
                    true => Meim::Enable,
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Meim::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Meim::Enable
            }
        }
        #[doc = "Field `MEIM` writer - MFIFO empty interrupt mask"]
        pub type MeimW<'a, REG> = crate::BitWriter<'a, REG, Meim>;
        impl<'a, REG> MeimW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Meim::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Meim::Enable)
            }
        }
        impl R {
            #[doc = "Bit 0 - Channel interrupt status (ch-0)"]
            #[inline(always)]
            pub fn cis0(&self) -> Cis0R {
                Cis0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Channel interrupt status (ch-1)"]
            #[inline(always)]
            pub fn cis1(&self) -> Cis1R {
                Cis1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Channel interrupt status (ch-2)"]
            #[inline(always)]
            pub fn cis2(&self) -> Cis2R {
                Cis2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Channel interrupt status (ch-3)"]
            #[inline(always)]
            pub fn cis3(&self) -> Cis3R {
                Cis3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Channel interrupt status (ch-4)"]
            #[inline(always)]
            pub fn cis4(&self) -> Cis4R {
                Cis4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Channel interrupt status (ch-5)"]
            #[inline(always)]
            pub fn cis5(&self) -> Cis5R {
                Cis5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Channel interrupt status (ch-6)"]
            #[inline(always)]
            pub fn cis6(&self) -> Cis6R {
                Cis6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Channel interrupt status (ch-7)"]
            #[inline(always)]
            pub fn cis7(&self) -> Cis7R {
                Cis7R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Channel interrupt status (ch-8)"]
            #[inline(always)]
            pub fn cis8(&self) -> Cis8R {
                Cis8R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Channel interrupt status (ch-9)"]
            #[inline(always)]
            pub fn cis9(&self) -> Cis9R {
                Cis9R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 13 - DMA Stall interrupt status"]
            #[inline(always)]
            pub fn sis(&self) -> SisR {
                SisR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - MFIFO empty interrupt status"]
            #[inline(always)]
            pub fn meis(&self) -> MeisR {
                MeisR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - BUSERR interrupt status"]
            #[inline(always)]
            pub fn beis(&self) -> BeisR {
                BeisR::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bit 16 - Channel interrupt mask (ch-0)"]
            #[inline(always)]
            pub fn cim0(&self) -> Cim0R {
                Cim0R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Channel interrupt mask (ch-1)"]
            #[inline(always)]
            pub fn cim1(&self) -> Cim1R {
                Cim1R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Channel interrupt mask (ch-2)"]
            #[inline(always)]
            pub fn cim2(&self) -> Cim2R {
                Cim2R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Channel interrupt mask (ch-3)"]
            #[inline(always)]
            pub fn cim3(&self) -> Cim3R {
                Cim3R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Channel interrupt mask (ch-4)"]
            #[inline(always)]
            pub fn cim4(&self) -> Cim4R {
                Cim4R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Channel interrupt mask (ch-5)"]
            #[inline(always)]
            pub fn cim5(&self) -> Cim5R {
                Cim5R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Channel interrupt mask (ch-6)"]
            #[inline(always)]
            pub fn cim6(&self) -> Cim6R {
                Cim6R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Channel interrupt mask (ch-7)"]
            #[inline(always)]
            pub fn cim7(&self) -> Cim7R {
                Cim7R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Channel interrupt mask (ch-8)"]
            #[inline(always)]
            pub fn cim8(&self) -> Cim8R {
                Cim8R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Channel interrupt mask (ch-9)"]
            #[inline(always)]
            pub fn cim9(&self) -> Cim9R {
                Cim9R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 29 - DMA stall interrupt mask"]
            #[inline(always)]
            pub fn sim(&self) -> SimR {
                SimR::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - MFIFO empty interrupt mask"]
            #[inline(always)]
            pub fn meim(&self) -> MeimR {
                MeimR::new(((self.bits >> 30) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Channel interrupt status (ch-0)"]
            #[inline(always)]
            pub fn cis0(&mut self) -> Cis0W<DStatSpec> {
                Cis0W::new(self, 0)
            }
            #[doc = "Bit 1 - Channel interrupt status (ch-1)"]
            #[inline(always)]
            pub fn cis1(&mut self) -> Cis1W<DStatSpec> {
                Cis1W::new(self, 1)
            }
            #[doc = "Bit 2 - Channel interrupt status (ch-2)"]
            #[inline(always)]
            pub fn cis2(&mut self) -> Cis2W<DStatSpec> {
                Cis2W::new(self, 2)
            }
            #[doc = "Bit 3 - Channel interrupt status (ch-3)"]
            #[inline(always)]
            pub fn cis3(&mut self) -> Cis3W<DStatSpec> {
                Cis3W::new(self, 3)
            }
            #[doc = "Bit 4 - Channel interrupt status (ch-4)"]
            #[inline(always)]
            pub fn cis4(&mut self) -> Cis4W<DStatSpec> {
                Cis4W::new(self, 4)
            }
            #[doc = "Bit 5 - Channel interrupt status (ch-5)"]
            #[inline(always)]
            pub fn cis5(&mut self) -> Cis5W<DStatSpec> {
                Cis5W::new(self, 5)
            }
            #[doc = "Bit 6 - Channel interrupt status (ch-6)"]
            #[inline(always)]
            pub fn cis6(&mut self) -> Cis6W<DStatSpec> {
                Cis6W::new(self, 6)
            }
            #[doc = "Bit 7 - Channel interrupt status (ch-7)"]
            #[inline(always)]
            pub fn cis7(&mut self) -> Cis7W<DStatSpec> {
                Cis7W::new(self, 7)
            }
            #[doc = "Bit 8 - Channel interrupt status (ch-8)"]
            #[inline(always)]
            pub fn cis8(&mut self) -> Cis8W<DStatSpec> {
                Cis8W::new(self, 8)
            }
            #[doc = "Bit 9 - Channel interrupt status (ch-9)"]
            #[inline(always)]
            pub fn cis9(&mut self) -> Cis9W<DStatSpec> {
                Cis9W::new(self, 9)
            }
            #[doc = "Bit 13 - DMA Stall interrupt status"]
            #[inline(always)]
            pub fn sis(&mut self) -> SisW<DStatSpec> {
                SisW::new(self, 13)
            }
            #[doc = "Bit 14 - MFIFO empty interrupt status"]
            #[inline(always)]
            pub fn meis(&mut self) -> MeisW<DStatSpec> {
                MeisW::new(self, 14)
            }
            #[doc = "Bit 15 - BUSERR interrupt status"]
            #[inline(always)]
            pub fn beis(&mut self) -> BeisW<DStatSpec> {
                BeisW::new(self, 15)
            }
            #[doc = "Bit 16 - Channel interrupt mask (ch-0)"]
            #[inline(always)]
            pub fn cim0(&mut self) -> Cim0W<DStatSpec> {
                Cim0W::new(self, 16)
            }
            #[doc = "Bit 17 - Channel interrupt mask (ch-1)"]
            #[inline(always)]
            pub fn cim1(&mut self) -> Cim1W<DStatSpec> {
                Cim1W::new(self, 17)
            }
            #[doc = "Bit 18 - Channel interrupt mask (ch-2)"]
            #[inline(always)]
            pub fn cim2(&mut self) -> Cim2W<DStatSpec> {
                Cim2W::new(self, 18)
            }
            #[doc = "Bit 19 - Channel interrupt mask (ch-3)"]
            #[inline(always)]
            pub fn cim3(&mut self) -> Cim3W<DStatSpec> {
                Cim3W::new(self, 19)
            }
            #[doc = "Bit 20 - Channel interrupt mask (ch-4)"]
            #[inline(always)]
            pub fn cim4(&mut self) -> Cim4W<DStatSpec> {
                Cim4W::new(self, 20)
            }
            #[doc = "Bit 21 - Channel interrupt mask (ch-5)"]
            #[inline(always)]
            pub fn cim5(&mut self) -> Cim5W<DStatSpec> {
                Cim5W::new(self, 21)
            }
            #[doc = "Bit 22 - Channel interrupt mask (ch-6)"]
            #[inline(always)]
            pub fn cim6(&mut self) -> Cim6W<DStatSpec> {
                Cim6W::new(self, 22)
            }
            #[doc = "Bit 23 - Channel interrupt mask (ch-7)"]
            #[inline(always)]
            pub fn cim7(&mut self) -> Cim7W<DStatSpec> {
                Cim7W::new(self, 23)
            }
            #[doc = "Bit 24 - Channel interrupt mask (ch-8)"]
            #[inline(always)]
            pub fn cim8(&mut self) -> Cim8W<DStatSpec> {
                Cim8W::new(self, 24)
            }
            #[doc = "Bit 25 - Channel interrupt mask (ch-9)"]
            #[inline(always)]
            pub fn cim9(&mut self) -> Cim9W<DStatSpec> {
                Cim9W::new(self, 25)
            }
            #[doc = "Bit 29 - DMA stall interrupt mask"]
            #[inline(always)]
            pub fn sim(&mut self) -> SimW<DStatSpec> {
                SimW::new(self, 29)
            }
            #[doc = "Bit 30 - MFIFO empty interrupt mask"]
            #[inline(always)]
            pub fn meim(&mut self) -> MeimW<DStatSpec> {
                MeimW::new(self, 30)
            }
        }
        #[doc = "DMAC status\n\nYou can [`read`](crate::Reg::read) this register and get [`d_stat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_stat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DStatSpec;
        impl crate::RegisterSpec for DStatSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d_stat::R`](R) reader structure"]
        impl crate::Readable for DStatSpec {}
        #[doc = "`write(|w| ..)` method takes [`d_stat::W`](W) writer structure"]
        impl crate::Writable for DStatSpec {
            type Safety = crate::Unsafe;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0xe3ff;
        }
        #[doc = "`reset()` method sets D_STAT to value 0"]
        impl crate::Resettable for DStatSpec {}
    }
    #[doc = "D_PCR (rw) register accessor: DMAC priority control\n\nYou can [`read`](crate::Reg::read) this register and get [`d_pcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_pcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d_pcr`] module"]
    #[doc(alias = "D_PCR")]
    pub type DPcr = crate::Reg<d_pcr::DPcrSpec>;
    #[doc = "DMAC priority control"]
    pub mod d_pcr {
        #[doc = "Register `D_PCR` reader"]
        pub type R = crate::R<DPcrSpec>;
        #[doc = "Register `D_PCR` writer"]
        pub type W = crate::W<DPcrSpec>;
        #[doc = "COP control (ch-0)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpc0 {
            #[doc = "0: Does not output applicable channel status to CPCOND\\[0\\]"]
            Off = 0,
            #[doc = "1: Outputs applicable channel status to CPCOND\\[0\\]"]
            On = 1,
        }
        impl From<Cpc0> for bool {
            #[inline(always)]
            fn from(variant: Cpc0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPC0` reader - COP control (ch-0)"]
        pub type Cpc0R = crate::BitReader<Cpc0>;
        impl Cpc0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpc0 {
                match self.bits {
                    false => Cpc0::Off,
                    true => Cpc0::On,
                }
            }
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cpc0::Off
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cpc0::On
            }
        }
        #[doc = "Field `CPC0` writer - COP control (ch-0)"]
        pub type Cpc0W<'a, REG> = crate::BitWriter<'a, REG, Cpc0>;
        impl<'a, REG> Cpc0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc0::Off)
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc0::On)
            }
        }
        #[doc = "COP control (ch-1)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpc1 {
            #[doc = "0: Does not output applicable channel status to CPCOND\\[0\\]"]
            Off = 0,
            #[doc = "1: Outputs applicable channel status to CPCOND\\[0\\]"]
            On = 1,
        }
        impl From<Cpc1> for bool {
            #[inline(always)]
            fn from(variant: Cpc1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPC1` reader - COP control (ch-1)"]
        pub type Cpc1R = crate::BitReader<Cpc1>;
        impl Cpc1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpc1 {
                match self.bits {
                    false => Cpc1::Off,
                    true => Cpc1::On,
                }
            }
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cpc1::Off
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cpc1::On
            }
        }
        #[doc = "Field `CPC1` writer - COP control (ch-1)"]
        pub type Cpc1W<'a, REG> = crate::BitWriter<'a, REG, Cpc1>;
        impl<'a, REG> Cpc1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc1::Off)
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc1::On)
            }
        }
        #[doc = "COP control (ch-2)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpc2 {
            #[doc = "0: Does not output applicable channel status to CPCOND\\[0\\]"]
            Off = 0,
            #[doc = "1: Outputs applicable channel status to CPCOND\\[0\\]"]
            On = 1,
        }
        impl From<Cpc2> for bool {
            #[inline(always)]
            fn from(variant: Cpc2) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPC2` reader - COP control (ch-2)"]
        pub type Cpc2R = crate::BitReader<Cpc2>;
        impl Cpc2R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpc2 {
                match self.bits {
                    false => Cpc2::Off,
                    true => Cpc2::On,
                }
            }
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cpc2::Off
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cpc2::On
            }
        }
        #[doc = "Field `CPC2` writer - COP control (ch-2)"]
        pub type Cpc2W<'a, REG> = crate::BitWriter<'a, REG, Cpc2>;
        impl<'a, REG> Cpc2W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc2::Off)
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc2::On)
            }
        }
        #[doc = "COP control (ch-3)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpc3 {
            #[doc = "0: Does not output applicable channel status to CPCOND\\[0\\]"]
            Off = 0,
            #[doc = "1: Outputs applicable channel status to CPCOND\\[0\\]"]
            On = 1,
        }
        impl From<Cpc3> for bool {
            #[inline(always)]
            fn from(variant: Cpc3) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPC3` reader - COP control (ch-3)"]
        pub type Cpc3R = crate::BitReader<Cpc3>;
        impl Cpc3R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpc3 {
                match self.bits {
                    false => Cpc3::Off,
                    true => Cpc3::On,
                }
            }
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cpc3::Off
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cpc3::On
            }
        }
        #[doc = "Field `CPC3` writer - COP control (ch-3)"]
        pub type Cpc3W<'a, REG> = crate::BitWriter<'a, REG, Cpc3>;
        impl<'a, REG> Cpc3W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc3::Off)
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc3::On)
            }
        }
        #[doc = "COP control (ch-4)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpc4 {
            #[doc = "0: Does not output applicable channel status to CPCOND\\[0\\]"]
            Off = 0,
            #[doc = "1: Outputs applicable channel status to CPCOND\\[0\\]"]
            On = 1,
        }
        impl From<Cpc4> for bool {
            #[inline(always)]
            fn from(variant: Cpc4) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPC4` reader - COP control (ch-4)"]
        pub type Cpc4R = crate::BitReader<Cpc4>;
        impl Cpc4R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpc4 {
                match self.bits {
                    false => Cpc4::Off,
                    true => Cpc4::On,
                }
            }
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cpc4::Off
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cpc4::On
            }
        }
        #[doc = "Field `CPC4` writer - COP control (ch-4)"]
        pub type Cpc4W<'a, REG> = crate::BitWriter<'a, REG, Cpc4>;
        impl<'a, REG> Cpc4W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc4::Off)
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc4::On)
            }
        }
        #[doc = "COP control (ch-5)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpc5 {
            #[doc = "0: Does not output applicable channel status to CPCOND\\[0\\]"]
            Off = 0,
            #[doc = "1: Outputs applicable channel status to CPCOND\\[0\\]"]
            On = 1,
        }
        impl From<Cpc5> for bool {
            #[inline(always)]
            fn from(variant: Cpc5) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPC5` reader - COP control (ch-5)"]
        pub type Cpc5R = crate::BitReader<Cpc5>;
        impl Cpc5R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpc5 {
                match self.bits {
                    false => Cpc5::Off,
                    true => Cpc5::On,
                }
            }
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cpc5::Off
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cpc5::On
            }
        }
        #[doc = "Field `CPC5` writer - COP control (ch-5)"]
        pub type Cpc5W<'a, REG> = crate::BitWriter<'a, REG, Cpc5>;
        impl<'a, REG> Cpc5W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc5::Off)
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc5::On)
            }
        }
        #[doc = "COP control (ch-6)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpc6 {
            #[doc = "0: Does not output applicable channel status to CPCOND\\[0\\]"]
            Off = 0,
            #[doc = "1: Outputs applicable channel status to CPCOND\\[0\\]"]
            On = 1,
        }
        impl From<Cpc6> for bool {
            #[inline(always)]
            fn from(variant: Cpc6) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPC6` reader - COP control (ch-6)"]
        pub type Cpc6R = crate::BitReader<Cpc6>;
        impl Cpc6R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpc6 {
                match self.bits {
                    false => Cpc6::Off,
                    true => Cpc6::On,
                }
            }
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cpc6::Off
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cpc6::On
            }
        }
        #[doc = "Field `CPC6` writer - COP control (ch-6)"]
        pub type Cpc6W<'a, REG> = crate::BitWriter<'a, REG, Cpc6>;
        impl<'a, REG> Cpc6W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc6::Off)
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc6::On)
            }
        }
        #[doc = "COP control (ch-7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpc7 {
            #[doc = "0: Does not output applicable channel status to CPCOND\\[0\\]"]
            Off = 0,
            #[doc = "1: Outputs applicable channel status to CPCOND\\[0\\]"]
            On = 1,
        }
        impl From<Cpc7> for bool {
            #[inline(always)]
            fn from(variant: Cpc7) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPC7` reader - COP control (ch-7)"]
        pub type Cpc7R = crate::BitReader<Cpc7>;
        impl Cpc7R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpc7 {
                match self.bits {
                    false => Cpc7::Off,
                    true => Cpc7::On,
                }
            }
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cpc7::Off
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cpc7::On
            }
        }
        #[doc = "Field `CPC7` writer - COP control (ch-7)"]
        pub type Cpc7W<'a, REG> = crate::BitWriter<'a, REG, Cpc7>;
        impl<'a, REG> Cpc7W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc7::Off)
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc7::On)
            }
        }
        #[doc = "COP control (ch-8)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpc8 {
            #[doc = "0: Does not output applicable channel status to CPCOND\\[0\\]"]
            Off = 0,
            #[doc = "1: Outputs applicable channel status to CPCOND\\[0\\]"]
            On = 1,
        }
        impl From<Cpc8> for bool {
            #[inline(always)]
            fn from(variant: Cpc8) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPC8` reader - COP control (ch-8)"]
        pub type Cpc8R = crate::BitReader<Cpc8>;
        impl Cpc8R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpc8 {
                match self.bits {
                    false => Cpc8::Off,
                    true => Cpc8::On,
                }
            }
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cpc8::Off
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cpc8::On
            }
        }
        #[doc = "Field `CPC8` writer - COP control (ch-8)"]
        pub type Cpc8W<'a, REG> = crate::BitWriter<'a, REG, Cpc8>;
        impl<'a, REG> Cpc8W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc8::Off)
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc8::On)
            }
        }
        #[doc = "COP control (ch-9)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpc9 {
            #[doc = "0: Does not output applicable channel status to CPCOND\\[0\\]"]
            Off = 0,
            #[doc = "1: Outputs applicable channel status to CPCOND\\[0\\]"]
            On = 1,
        }
        impl From<Cpc9> for bool {
            #[inline(always)]
            fn from(variant: Cpc9) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPC9` reader - COP control (ch-9)"]
        pub type Cpc9R = crate::BitReader<Cpc9>;
        impl Cpc9R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpc9 {
                match self.bits {
                    false => Cpc9::Off,
                    true => Cpc9::On,
                }
            }
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == Cpc9::Off
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == Cpc9::On
            }
        }
        #[doc = "Field `CPC9` writer - COP control (ch-9)"]
        pub type Cpc9W<'a, REG> = crate::BitWriter<'a, REG, Cpc9>;
        impl<'a, REG> Cpc9W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Does not output applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn off(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc9::Off)
            }
            #[doc = "Outputs applicable channel status to CPCOND\\[0\\]"]
            #[inline(always)]
            pub fn on(self) -> &'a mut crate::W<REG> {
                self.variant(Cpc9::On)
            }
        }
        #[doc = "Channel DMA enable (ch-0)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cde0 {
            #[doc = "0: Disable (low priority)"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cde0> for bool {
            #[inline(always)]
            fn from(variant: Cde0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CDE0` reader - Channel DMA enable (ch-0)"]
        pub type Cde0R = crate::BitReader<Cde0>;
        impl Cde0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cde0 {
                match self.bits {
                    false => Cde0::Disable,
                    true => Cde0::Enable,
                }
            }
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cde0::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cde0::Enable
            }
        }
        #[doc = "Field `CDE0` writer - Channel DMA enable (ch-0)"]
        pub type Cde0W<'a, REG> = crate::BitWriter<'a, REG, Cde0>;
        impl<'a, REG> Cde0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde0::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde0::Enable)
            }
        }
        #[doc = "Channel DMA enable (ch-1)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cde1 {
            #[doc = "0: Disable (low priority)"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cde1> for bool {
            #[inline(always)]
            fn from(variant: Cde1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CDE1` reader - Channel DMA enable (ch-1)"]
        pub type Cde1R = crate::BitReader<Cde1>;
        impl Cde1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cde1 {
                match self.bits {
                    false => Cde1::Disable,
                    true => Cde1::Enable,
                }
            }
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cde1::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cde1::Enable
            }
        }
        #[doc = "Field `CDE1` writer - Channel DMA enable (ch-1)"]
        pub type Cde1W<'a, REG> = crate::BitWriter<'a, REG, Cde1>;
        impl<'a, REG> Cde1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde1::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde1::Enable)
            }
        }
        #[doc = "Channel DMA enable (ch-2)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cde2 {
            #[doc = "0: Disable (low priority)"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cde2> for bool {
            #[inline(always)]
            fn from(variant: Cde2) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CDE2` reader - Channel DMA enable (ch-2)"]
        pub type Cde2R = crate::BitReader<Cde2>;
        impl Cde2R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cde2 {
                match self.bits {
                    false => Cde2::Disable,
                    true => Cde2::Enable,
                }
            }
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cde2::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cde2::Enable
            }
        }
        #[doc = "Field `CDE2` writer - Channel DMA enable (ch-2)"]
        pub type Cde2W<'a, REG> = crate::BitWriter<'a, REG, Cde2>;
        impl<'a, REG> Cde2W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde2::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde2::Enable)
            }
        }
        #[doc = "Channel DMA enable (ch-3)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cde3 {
            #[doc = "0: Disable (low priority)"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cde3> for bool {
            #[inline(always)]
            fn from(variant: Cde3) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CDE3` reader - Channel DMA enable (ch-3)"]
        pub type Cde3R = crate::BitReader<Cde3>;
        impl Cde3R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cde3 {
                match self.bits {
                    false => Cde3::Disable,
                    true => Cde3::Enable,
                }
            }
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cde3::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cde3::Enable
            }
        }
        #[doc = "Field `CDE3` writer - Channel DMA enable (ch-3)"]
        pub type Cde3W<'a, REG> = crate::BitWriter<'a, REG, Cde3>;
        impl<'a, REG> Cde3W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde3::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde3::Enable)
            }
        }
        #[doc = "Channel DMA enable (ch-4)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cde4 {
            #[doc = "0: Disable (low priority)"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cde4> for bool {
            #[inline(always)]
            fn from(variant: Cde4) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CDE4` reader - Channel DMA enable (ch-4)"]
        pub type Cde4R = crate::BitReader<Cde4>;
        impl Cde4R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cde4 {
                match self.bits {
                    false => Cde4::Disable,
                    true => Cde4::Enable,
                }
            }
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cde4::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cde4::Enable
            }
        }
        #[doc = "Field `CDE4` writer - Channel DMA enable (ch-4)"]
        pub type Cde4W<'a, REG> = crate::BitWriter<'a, REG, Cde4>;
        impl<'a, REG> Cde4W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde4::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde4::Enable)
            }
        }
        #[doc = "Channel DMA enable (ch-5)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cde5 {
            #[doc = "0: Disable (low priority)"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cde5> for bool {
            #[inline(always)]
            fn from(variant: Cde5) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CDE5` reader - Channel DMA enable (ch-5)"]
        pub type Cde5R = crate::BitReader<Cde5>;
        impl Cde5R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cde5 {
                match self.bits {
                    false => Cde5::Disable,
                    true => Cde5::Enable,
                }
            }
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cde5::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cde5::Enable
            }
        }
        #[doc = "Field `CDE5` writer - Channel DMA enable (ch-5)"]
        pub type Cde5W<'a, REG> = crate::BitWriter<'a, REG, Cde5>;
        impl<'a, REG> Cde5W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde5::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde5::Enable)
            }
        }
        #[doc = "Channel DMA enable (ch-6)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cde6 {
            #[doc = "0: Disable (low priority)"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cde6> for bool {
            #[inline(always)]
            fn from(variant: Cde6) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CDE6` reader - Channel DMA enable (ch-6)"]
        pub type Cde6R = crate::BitReader<Cde6>;
        impl Cde6R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cde6 {
                match self.bits {
                    false => Cde6::Disable,
                    true => Cde6::Enable,
                }
            }
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cde6::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cde6::Enable
            }
        }
        #[doc = "Field `CDE6` writer - Channel DMA enable (ch-6)"]
        pub type Cde6W<'a, REG> = crate::BitWriter<'a, REG, Cde6>;
        impl<'a, REG> Cde6W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde6::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde6::Enable)
            }
        }
        #[doc = "Channel DMA enable (ch-7)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cde7 {
            #[doc = "0: Disable (low priority)"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cde7> for bool {
            #[inline(always)]
            fn from(variant: Cde7) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CDE7` reader - Channel DMA enable (ch-7)"]
        pub type Cde7R = crate::BitReader<Cde7>;
        impl Cde7R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cde7 {
                match self.bits {
                    false => Cde7::Disable,
                    true => Cde7::Enable,
                }
            }
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cde7::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cde7::Enable
            }
        }
        #[doc = "Field `CDE7` writer - Channel DMA enable (ch-7)"]
        pub type Cde7W<'a, REG> = crate::BitWriter<'a, REG, Cde7>;
        impl<'a, REG> Cde7W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde7::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde7::Enable)
            }
        }
        #[doc = "Channel DMA enable (ch-0)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cde8 {
            #[doc = "0: Disable (low priority)"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cde8> for bool {
            #[inline(always)]
            fn from(variant: Cde8) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CDE8` reader - Channel DMA enable (ch-0)"]
        pub type Cde8R = crate::BitReader<Cde8>;
        impl Cde8R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cde8 {
                match self.bits {
                    false => Cde8::Disable,
                    true => Cde8::Enable,
                }
            }
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cde8::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cde8::Enable
            }
        }
        #[doc = "Field `CDE8` writer - Channel DMA enable (ch-0)"]
        pub type Cde8W<'a, REG> = crate::BitWriter<'a, REG, Cde8>;
        impl<'a, REG> Cde8W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde8::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde8::Enable)
            }
        }
        #[doc = "Channel DMA enable (ch-0)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cde9 {
            #[doc = "0: Disable (low priority)"]
            Disable = 0,
            #[doc = "1: Enable"]
            Enable = 1,
        }
        impl From<Cde9> for bool {
            #[inline(always)]
            fn from(variant: Cde9) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CDE9` reader - Channel DMA enable (ch-0)"]
        pub type Cde9R = crate::BitReader<Cde9>;
        impl Cde9R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cde9 {
                match self.bits {
                    false => Cde9::Disable,
                    true => Cde9::Enable,
                }
            }
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cde9::Disable
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cde9::Enable
            }
        }
        #[doc = "Field `CDE9` writer - Channel DMA enable (ch-0)"]
        pub type Cde9W<'a, REG> = crate::BitWriter<'a, REG, Cde9>;
        impl<'a, REG> Cde9W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Disable (low priority)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde9::Disable)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cde9::Enable)
            }
        }
        #[doc = "Priority control enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Pce {
            #[doc = "0: CDEn bit disable (regarded as 1)"]
            Disable = 0,
            #[doc = "1: CDEn bit enable"]
            Enable = 1,
        }
        impl From<Pce> for bool {
            #[inline(always)]
            fn from(variant: Pce) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PCE` reader - Priority control enable"]
        pub type PceR = crate::BitReader<Pce>;
        impl PceR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Pce {
                match self.bits {
                    false => Pce::Disable,
                    true => Pce::Enable,
                }
            }
            #[doc = "CDEn bit disable (regarded as 1)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Pce::Disable
            }
            #[doc = "CDEn bit enable"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Pce::Enable
            }
        }
        #[doc = "Field `PCE` writer - Priority control enable"]
        pub type PceW<'a, REG> = crate::BitWriter<'a, REG, Pce>;
        impl<'a, REG> PceW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "CDEn bit disable (regarded as 1)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Pce::Disable)
            }
            #[doc = "CDEn bit enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Pce::Enable)
            }
        }
        impl R {
            #[doc = "Bit 0 - COP control (ch-0)"]
            #[inline(always)]
            pub fn cpc0(&self) -> Cpc0R {
                Cpc0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - COP control (ch-1)"]
            #[inline(always)]
            pub fn cpc1(&self) -> Cpc1R {
                Cpc1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - COP control (ch-2)"]
            #[inline(always)]
            pub fn cpc2(&self) -> Cpc2R {
                Cpc2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - COP control (ch-3)"]
            #[inline(always)]
            pub fn cpc3(&self) -> Cpc3R {
                Cpc3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - COP control (ch-4)"]
            #[inline(always)]
            pub fn cpc4(&self) -> Cpc4R {
                Cpc4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - COP control (ch-5)"]
            #[inline(always)]
            pub fn cpc5(&self) -> Cpc5R {
                Cpc5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - COP control (ch-6)"]
            #[inline(always)]
            pub fn cpc6(&self) -> Cpc6R {
                Cpc6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - COP control (ch-7)"]
            #[inline(always)]
            pub fn cpc7(&self) -> Cpc7R {
                Cpc7R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - COP control (ch-8)"]
            #[inline(always)]
            pub fn cpc8(&self) -> Cpc8R {
                Cpc8R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - COP control (ch-9)"]
            #[inline(always)]
            pub fn cpc9(&self) -> Cpc9R {
                Cpc9R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 16 - Channel DMA enable (ch-0)"]
            #[inline(always)]
            pub fn cde0(&self) -> Cde0R {
                Cde0R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 17 - Channel DMA enable (ch-1)"]
            #[inline(always)]
            pub fn cde1(&self) -> Cde1R {
                Cde1R::new(((self.bits >> 17) & 1) != 0)
            }
            #[doc = "Bit 18 - Channel DMA enable (ch-2)"]
            #[inline(always)]
            pub fn cde2(&self) -> Cde2R {
                Cde2R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Channel DMA enable (ch-3)"]
            #[inline(always)]
            pub fn cde3(&self) -> Cde3R {
                Cde3R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - Channel DMA enable (ch-4)"]
            #[inline(always)]
            pub fn cde4(&self) -> Cde4R {
                Cde4R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Channel DMA enable (ch-5)"]
            #[inline(always)]
            pub fn cde5(&self) -> Cde5R {
                Cde5R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - Channel DMA enable (ch-6)"]
            #[inline(always)]
            pub fn cde6(&self) -> Cde6R {
                Cde6R::new(((self.bits >> 22) & 1) != 0)
            }
            #[doc = "Bit 23 - Channel DMA enable (ch-7)"]
            #[inline(always)]
            pub fn cde7(&self) -> Cde7R {
                Cde7R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Channel DMA enable (ch-0)"]
            #[inline(always)]
            pub fn cde8(&self) -> Cde8R {
                Cde8R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Channel DMA enable (ch-0)"]
            #[inline(always)]
            pub fn cde9(&self) -> Cde9R {
                Cde9R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 31 - Priority control enable"]
            #[inline(always)]
            pub fn pce(&self) -> PceR {
                PceR::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - COP control (ch-0)"]
            #[inline(always)]
            pub fn cpc0(&mut self) -> Cpc0W<DPcrSpec> {
                Cpc0W::new(self, 0)
            }
            #[doc = "Bit 1 - COP control (ch-1)"]
            #[inline(always)]
            pub fn cpc1(&mut self) -> Cpc1W<DPcrSpec> {
                Cpc1W::new(self, 1)
            }
            #[doc = "Bit 2 - COP control (ch-2)"]
            #[inline(always)]
            pub fn cpc2(&mut self) -> Cpc2W<DPcrSpec> {
                Cpc2W::new(self, 2)
            }
            #[doc = "Bit 3 - COP control (ch-3)"]
            #[inline(always)]
            pub fn cpc3(&mut self) -> Cpc3W<DPcrSpec> {
                Cpc3W::new(self, 3)
            }
            #[doc = "Bit 4 - COP control (ch-4)"]
            #[inline(always)]
            pub fn cpc4(&mut self) -> Cpc4W<DPcrSpec> {
                Cpc4W::new(self, 4)
            }
            #[doc = "Bit 5 - COP control (ch-5)"]
            #[inline(always)]
            pub fn cpc5(&mut self) -> Cpc5W<DPcrSpec> {
                Cpc5W::new(self, 5)
            }
            #[doc = "Bit 6 - COP control (ch-6)"]
            #[inline(always)]
            pub fn cpc6(&mut self) -> Cpc6W<DPcrSpec> {
                Cpc6W::new(self, 6)
            }
            #[doc = "Bit 7 - COP control (ch-7)"]
            #[inline(always)]
            pub fn cpc7(&mut self) -> Cpc7W<DPcrSpec> {
                Cpc7W::new(self, 7)
            }
            #[doc = "Bit 8 - COP control (ch-8)"]
            #[inline(always)]
            pub fn cpc8(&mut self) -> Cpc8W<DPcrSpec> {
                Cpc8W::new(self, 8)
            }
            #[doc = "Bit 9 - COP control (ch-9)"]
            #[inline(always)]
            pub fn cpc9(&mut self) -> Cpc9W<DPcrSpec> {
                Cpc9W::new(self, 9)
            }
            #[doc = "Bit 16 - Channel DMA enable (ch-0)"]
            #[inline(always)]
            pub fn cde0(&mut self) -> Cde0W<DPcrSpec> {
                Cde0W::new(self, 16)
            }
            #[doc = "Bit 17 - Channel DMA enable (ch-1)"]
            #[inline(always)]
            pub fn cde1(&mut self) -> Cde1W<DPcrSpec> {
                Cde1W::new(self, 17)
            }
            #[doc = "Bit 18 - Channel DMA enable (ch-2)"]
            #[inline(always)]
            pub fn cde2(&mut self) -> Cde2W<DPcrSpec> {
                Cde2W::new(self, 18)
            }
            #[doc = "Bit 19 - Channel DMA enable (ch-3)"]
            #[inline(always)]
            pub fn cde3(&mut self) -> Cde3W<DPcrSpec> {
                Cde3W::new(self, 19)
            }
            #[doc = "Bit 20 - Channel DMA enable (ch-4)"]
            #[inline(always)]
            pub fn cde4(&mut self) -> Cde4W<DPcrSpec> {
                Cde4W::new(self, 20)
            }
            #[doc = "Bit 21 - Channel DMA enable (ch-5)"]
            #[inline(always)]
            pub fn cde5(&mut self) -> Cde5W<DPcrSpec> {
                Cde5W::new(self, 21)
            }
            #[doc = "Bit 22 - Channel DMA enable (ch-6)"]
            #[inline(always)]
            pub fn cde6(&mut self) -> Cde6W<DPcrSpec> {
                Cde6W::new(self, 22)
            }
            #[doc = "Bit 23 - Channel DMA enable (ch-7)"]
            #[inline(always)]
            pub fn cde7(&mut self) -> Cde7W<DPcrSpec> {
                Cde7W::new(self, 23)
            }
            #[doc = "Bit 24 - Channel DMA enable (ch-0)"]
            #[inline(always)]
            pub fn cde8(&mut self) -> Cde8W<DPcrSpec> {
                Cde8W::new(self, 24)
            }
            #[doc = "Bit 25 - Channel DMA enable (ch-0)"]
            #[inline(always)]
            pub fn cde9(&mut self) -> Cde9W<DPcrSpec> {
                Cde9W::new(self, 25)
            }
            #[doc = "Bit 31 - Priority control enable"]
            #[inline(always)]
            pub fn pce(&mut self) -> PceW<DPcrSpec> {
                PceW::new(self, 31)
            }
        }
        #[doc = "DMAC priority control\n\nYou can [`read`](crate::Reg::read) this register and get [`d_pcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_pcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DPcrSpec;
        impl crate::RegisterSpec for DPcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d_pcr::R`](R) reader structure"]
        impl crate::Readable for DPcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d_pcr::W`](W) writer structure"]
        impl crate::Writable for DPcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D_PCR to value 0"]
        impl crate::Resettable for DPcrSpec {}
    }
    #[doc = "D_SQWC (rw) register accessor: DMAC skip quad word\n\nYou can [`read`](crate::Reg::read) this register and get [`d_sqwc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_sqwc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d_sqwc`] module"]
    #[doc(alias = "D_SQWC")]
    pub type DSqwc = crate::Reg<d_sqwc::DSqwcSpec>;
    #[doc = "DMAC skip quad word"]
    pub mod d_sqwc {
        #[doc = "Register `D_SQWC` reader"]
        pub type R = crate::R<DSqwcSpec>;
        #[doc = "Register `D_SQWC` writer"]
        pub type W = crate::W<DSqwcSpec>;
        #[doc = "Field `SQWC` reader - Skip quadword counter. Size of the part not transferred (qword)"]
        pub type SqwcR = crate::FieldReader;
        #[doc = "Field `SQWC` writer - Skip quadword counter. Size of the part not transferred (qword)"]
        pub type SqwcW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `TQWC` reader - Transfer quadword counter. Size of the part transferred (qword)"]
        pub type TqwcR = crate::FieldReader;
        #[doc = "Field `TQWC` writer - Transfer quadword counter. Size of the part transferred (qword)"]
        pub type TqwcW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Skip quadword counter. Size of the part not transferred (qword)"]
            #[inline(always)]
            pub fn sqwc(&self) -> SqwcR {
                SqwcR::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - Transfer quadword counter. Size of the part transferred (qword)"]
            #[inline(always)]
            pub fn tqwc(&self) -> TqwcR {
                TqwcR::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Skip quadword counter. Size of the part not transferred (qword)"]
            #[inline(always)]
            pub fn sqwc(&mut self) -> SqwcW<DSqwcSpec> {
                SqwcW::new(self, 0)
            }
            #[doc = "Bits 16:23 - Transfer quadword counter. Size of the part transferred (qword)"]
            #[inline(always)]
            pub fn tqwc(&mut self) -> TqwcW<DSqwcSpec> {
                TqwcW::new(self, 16)
            }
        }
        #[doc = "DMAC skip quad word\n\nYou can [`read`](crate::Reg::read) this register and get [`d_sqwc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_sqwc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DSqwcSpec;
        impl crate::RegisterSpec for DSqwcSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d_sqwc::R`](R) reader structure"]
        impl crate::Readable for DSqwcSpec {}
        #[doc = "`write(|w| ..)` method takes [`d_sqwc::W`](W) writer structure"]
        impl crate::Writable for DSqwcSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D_SQWC to value 0"]
        impl crate::Resettable for DSqwcSpec {}
    }
    #[doc = "D_RBSR (rw) register accessor: DMAC ring buffer size\n\nYou can [`read`](crate::Reg::read) this register and get [`d_rbsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_rbsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d_rbsr`] module"]
    #[doc(alias = "D_RBSR")]
    pub type DRbsr = crate::Reg<d_rbsr::DRbsrSpec>;
    #[doc = "DMAC ring buffer size"]
    pub mod d_rbsr {
        #[doc = "Register `D_RBSR` reader"]
        pub type R = crate::R<DRbsrSpec>;
        #[doc = "Register `D_RBSR` writer"]
        pub type W = crate::W<DRbsrSpec>;
        #[doc = "Field `RMSK` reader - Ring buffer size mask"]
        pub type RmskR = crate::FieldReader<u32>;
        #[doc = "Field `RMSK` writer - Ring buffer size mask"]
        pub type RmskW<'a, REG> = crate::FieldWriter<'a, REG, 27, u32>;
        impl R {
            #[doc = "Bits 4:30 - Ring buffer size mask"]
            #[inline(always)]
            pub fn rmsk(&self) -> RmskR {
                RmskR::new((self.bits >> 4) & 0x07ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 4:30 - Ring buffer size mask"]
            #[inline(always)]
            pub fn rmsk(&mut self) -> RmskW<DRbsrSpec> {
                RmskW::new(self, 4)
            }
        }
        #[doc = "DMAC ring buffer size\n\nYou can [`read`](crate::Reg::read) this register and get [`d_rbsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_rbsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DRbsrSpec;
        impl crate::RegisterSpec for DRbsrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d_rbsr::R`](R) reader structure"]
        impl crate::Readable for DRbsrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d_rbsr::W`](W) writer structure"]
        impl crate::Writable for DRbsrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D_RBSR to value 0"]
        impl crate::Resettable for DRbsrSpec {}
    }
    #[doc = "D_RBOR (rw) register accessor: DMAC ring buffer offset\n\nYou can [`read`](crate::Reg::read) this register and get [`d_rbor::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_rbor::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d_rbor`] module"]
    #[doc(alias = "D_RBOR")]
    pub type DRbor = crate::Reg<d_rbor::DRborSpec>;
    #[doc = "DMAC ring buffer offset"]
    pub mod d_rbor {
        #[doc = "Register `D_RBOR` reader"]
        pub type R = crate::R<DRborSpec>;
        #[doc = "Register `D_RBOR` writer"]
        pub type W = crate::W<DRborSpec>;
        #[doc = "Field `ADDR` reader - Ring buffer offset address (qword alignment)"]
        pub type AddrR = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Ring buffer offset address (qword alignment)"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 27, u32>;
        impl R {
            #[doc = "Bits 4:30 - Ring buffer offset address (qword alignment)"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new((self.bits >> 4) & 0x07ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 4:30 - Ring buffer offset address (qword alignment)"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<DRborSpec> {
                AddrW::new(self, 4)
            }
        }
        #[doc = "DMAC ring buffer offset\n\nYou can [`read`](crate::Reg::read) this register and get [`d_rbor::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_rbor::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DRborSpec;
        impl crate::RegisterSpec for DRborSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d_rbor::R`](R) reader structure"]
        impl crate::Readable for DRborSpec {}
        #[doc = "`write(|w| ..)` method takes [`d_rbor::W`](W) writer structure"]
        impl crate::Writable for DRborSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D_RBOR to value 0"]
        impl crate::Resettable for DRborSpec {}
    }
    #[doc = "D_STADR (rw) register accessor: DMAC stall address\n\nYou can [`read`](crate::Reg::read) this register and get [`d_stadr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_stadr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d_stadr`] module"]
    #[doc(alias = "D_STADR")]
    pub type DStadr = crate::Reg<d_stadr::DStadrSpec>;
    #[doc = "DMAC stall address"]
    pub mod d_stadr {
        #[doc = "Register `D_STADR` reader"]
        pub type R = crate::R<DStadrSpec>;
        #[doc = "Register `D_STADR` writer"]
        pub type W = crate::W<DStadrSpec>;
        #[doc = "Field `ADDR` reader - Stall address (qword alignment)"]
        pub type AddrR = crate::FieldReader<u32>;
        #[doc = "Field `ADDR` writer - Stall address (qword alignment)"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 27, u32>;
        impl R {
            #[doc = "Bits 4:30 - Stall address (qword alignment)"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new((self.bits >> 4) & 0x07ff_ffff)
            }
        }
        impl W {
            #[doc = "Bits 4:30 - Stall address (qword alignment)"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<DStadrSpec> {
                AddrW::new(self, 4)
            }
        }
        #[doc = "DMAC stall address\n\nYou can [`read`](crate::Reg::read) this register and get [`d_stadr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_stadr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DStadrSpec;
        impl crate::RegisterSpec for DStadrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d_stadr::R`](R) reader structure"]
        impl crate::Readable for DStadrSpec {}
        #[doc = "`write(|w| ..)` method takes [`d_stadr::W`](W) writer structure"]
        impl crate::Writable for DStadrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D_STADR to value 0"]
        impl crate::Resettable for DStadrSpec {}
    }
    #[doc = "D_ENABLER (r) register accessor: Acquistion of DMA suspend status\n\nYou can [`read`](crate::Reg::read) this register and get [`d_enabler::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d_enabler`] module"]
    #[doc(alias = "D_ENABLER")]
    pub type DEnabler = crate::Reg<d_enabler::DEnablerSpec>;
    #[doc = "Acquistion of DMA suspend status"]
    pub mod d_enabler {
        #[doc = "Register `D_ENABLER` reader"]
        pub type R = crate::R<DEnablerSpec>;
        #[doc = "DMA transfer hold state\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpnd {
            #[doc = "0: All channel transfer enabled"]
            Enable = 0,
            #[doc = "1: All channel transfer being held (suspended)"]
            Disable = 1,
        }
        impl From<Cpnd> for bool {
            #[inline(always)]
            fn from(variant: Cpnd) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPND` reader - DMA transfer hold state"]
        pub type CpndR = crate::BitReader<Cpnd>;
        impl CpndR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cpnd {
                match self.bits {
                    false => Cpnd::Enable,
                    true => Cpnd::Disable,
                }
            }
            #[doc = "All channel transfer enabled"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Cpnd::Enable
            }
            #[doc = "All channel transfer being held (suspended)"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Cpnd::Disable
            }
        }
        impl R {
            #[doc = "Bit 16 - DMA transfer hold state"]
            #[inline(always)]
            pub fn cpnd(&self) -> CpndR {
                CpndR::new(((self.bits >> 16) & 1) != 0)
            }
        }
        #[doc = "Acquistion of DMA suspend status\n\nYou can [`read`](crate::Reg::read) this register and get [`d_enabler::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DEnablerSpec;
        impl crate::RegisterSpec for DEnablerSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`d_enabler::R`](R) reader structure"]
        impl crate::Readable for DEnablerSpec {}
        #[doc = "`reset()` method sets D_ENABLER to value 0"]
        impl crate::Resettable for DEnablerSpec {}
    }
    #[doc = "D_ENABLEW (w) register accessor: DMA suspend control\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_enablew::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@d_enablew`] module"]
    #[doc(alias = "D_ENABLEW")]
    pub type DEnablew = crate::Reg<d_enablew::DEnablewSpec>;
    #[doc = "DMA suspend control"]
    pub mod d_enablew {
        #[doc = "Register `D_ENABLEW` writer"]
        pub type W = crate::W<DEnablewSpec>;
        #[doc = "DMA transfer is held\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Cpnd {
            #[doc = "0: Enables all channel transfer (restarts)"]
            Enable = 0,
            #[doc = "1: Holds all channel transfer (suspends)"]
            Disable = 1,
        }
        impl From<Cpnd> for bool {
            #[inline(always)]
            fn from(variant: Cpnd) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `CPND` writer - DMA transfer is held"]
        pub type CpndW<'a, REG> = crate::BitWriter<'a, REG, Cpnd>;
        impl<'a, REG> CpndW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Enables all channel transfer (restarts)"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Cpnd::Enable)
            }
            #[doc = "Holds all channel transfer (suspends)"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Cpnd::Disable)
            }
        }
        impl W {
            #[doc = "Bit 16 - DMA transfer is held"]
            #[inline(always)]
            pub fn cpnd(&mut self) -> CpndW<DEnablewSpec> {
                CpndW::new(self, 16)
            }
        }
        #[doc = "DMA suspend control\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`d_enablew::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DEnablewSpec;
        impl crate::RegisterSpec for DEnablewSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`d_enablew::W`](W) writer structure"]
        impl crate::Writable for DEnablewSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets D_ENABLEW to value 0"]
        impl crate::Resettable for DEnablewSpec {}
    }
}
#[doc = "Interrupt Controller. See EE User's Manual, Chapter 3."]
pub type Intc = crate::Periph<intc::RegisterBlock, 0xb000_f000>;
impl core::fmt::Debug for Intc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Intc").finish()
    }
}
#[doc = "Interrupt Controller. See EE User's Manual, Chapter 3."]
pub mod intc {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        i_stat: IStat,
        _reserved1: [u8; 0x0c],
        i_mask: IMask,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Interrupt Status"]
        #[inline(always)]
        pub const fn i_stat(&self) -> &IStat {
            &self.i_stat
        }
        #[doc = "0x10 - Interrupt Mask"]
        #[inline(always)]
        pub const fn i_mask(&self) -> &IMask {
            &self.i_mask
        }
    }
    #[doc = "I_STAT (rw) register accessor: Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`i_stat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`i_stat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i_stat`] module"]
    #[doc(alias = "I_STAT")]
    pub type IStat = crate::Reg<i_stat::IStatSpec>;
    #[doc = "Interrupt Status"]
    pub mod i_stat {
        #[doc = "Register `I_STAT` reader"]
        pub type R = crate::R<IStatSpec>;
        #[doc = "Register `I_STAT` writer"]
        pub type W = crate::W<IStatSpec>;
        #[doc = "Detection of an interrupt from GS\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Gs {
            #[doc = "0: No GS interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A GS interrupt has occurred."]
            Set = 1,
        }
        impl From<Gs> for bool {
            #[inline(always)]
            fn from(variant: Gs) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `GS` reader - Detection of an interrupt from GS"]
        pub type GsR = crate::BitReader<Gs>;
        impl GsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Gs {
                match self.bits {
                    false => Gs::Clear,
                    true => Gs::Set,
                }
            }
            #[doc = "No GS interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Gs::Clear
            }
            #[doc = "A GS interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Gs::Set
            }
        }
        #[doc = "Field `GS` writer - Detection of an interrupt from GS"]
        pub type GsW<'a, REG> = crate::BitWriter1C<'a, REG, Gs>;
        impl<'a, REG> GsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No GS interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Gs::Clear)
            }
            #[doc = "A GS interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Gs::Set)
            }
        }
        #[doc = "Detection of an interrupt from a peripheral on SBUS\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sbus {
            #[doc = "0: No SBUS interrupt has occurred."]
            Clear = 0,
            #[doc = "1: An SBUS interrupt has occurred."]
            Set = 1,
        }
        impl From<Sbus> for bool {
            #[inline(always)]
            fn from(variant: Sbus) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SBUS` reader - Detection of an interrupt from a peripheral on SBUS"]
        pub type SbusR = crate::BitReader<Sbus>;
        impl SbusR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sbus {
                match self.bits {
                    false => Sbus::Clear,
                    true => Sbus::Set,
                }
            }
            #[doc = "No SBUS interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Sbus::Clear
            }
            #[doc = "An SBUS interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Sbus::Set
            }
        }
        #[doc = "Field `SBUS` writer - Detection of an interrupt from a peripheral on SBUS"]
        pub type SbusW<'a, REG> = crate::BitWriter1C<'a, REG, Sbus>;
        impl<'a, REG> SbusW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No SBUS interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Sbus::Clear)
            }
            #[doc = "An SBUS interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Sbus::Set)
            }
        }
        #[doc = "Start of V-Blank\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vbon {
            #[doc = "0: No start-of-V-Blank interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A start-of-V-Blank interrupt has occurred."]
            Set = 1,
        }
        impl From<Vbon> for bool {
            #[inline(always)]
            fn from(variant: Vbon) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VBON` reader - Start of V-Blank"]
        pub type VbonR = crate::BitReader<Vbon>;
        impl VbonR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vbon {
                match self.bits {
                    false => Vbon::Clear,
                    true => Vbon::Set,
                }
            }
            #[doc = "No start-of-V-Blank interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Vbon::Clear
            }
            #[doc = "A start-of-V-Blank interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Vbon::Set
            }
        }
        #[doc = "Field `VBON` writer - Start of V-Blank"]
        pub type VbonW<'a, REG> = crate::BitWriter1C<'a, REG, Vbon>;
        impl<'a, REG> VbonW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No start-of-V-Blank interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Vbon::Clear)
            }
            #[doc = "A start-of-V-Blank interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Vbon::Set)
            }
        }
        #[doc = "End of V-Blank\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vbof {
            #[doc = "0: No end-of-V-Blank interrupt has occurred."]
            Clear = 0,
            #[doc = "1: An end-of-V-Blank interrupt has occurred."]
            Set = 1,
        }
        impl From<Vbof> for bool {
            #[inline(always)]
            fn from(variant: Vbof) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VBOF` reader - End of V-Blank"]
        pub type VbofR = crate::BitReader<Vbof>;
        impl VbofR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vbof {
                match self.bits {
                    false => Vbof::Clear,
                    true => Vbof::Set,
                }
            }
            #[doc = "No end-of-V-Blank interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Vbof::Clear
            }
            #[doc = "An end-of-V-Blank interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Vbof::Set
            }
        }
        #[doc = "Field `VBOF` writer - End of V-Blank"]
        pub type VbofW<'a, REG> = crate::BitWriter1C<'a, REG, Vbof>;
        impl<'a, REG> VbofW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No end-of-V-Blank interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Vbof::Clear)
            }
            #[doc = "An end-of-V-Blank interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Vbof::Set)
            }
        }
        #[doc = "VIF0's detection of VIFcode with an interrupt bit or an exception, or VIF0 stalls with occurrence of an interrupt.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vif0 {
            #[doc = "0: No VIF0 interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A VIF0 interrupt has occurred."]
            Set = 1,
        }
        impl From<Vif0> for bool {
            #[inline(always)]
            fn from(variant: Vif0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VIF0` reader - VIF0's detection of VIFcode with an interrupt bit or an exception, or VIF0 stalls with occurrence of an interrupt."]
        pub type Vif0R = crate::BitReader<Vif0>;
        impl Vif0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vif0 {
                match self.bits {
                    false => Vif0::Clear,
                    true => Vif0::Set,
                }
            }
            #[doc = "No VIF0 interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Vif0::Clear
            }
            #[doc = "A VIF0 interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Vif0::Set
            }
        }
        #[doc = "Field `VIF0` writer - VIF0's detection of VIFcode with an interrupt bit or an exception, or VIF0 stalls with occurrence of an interrupt."]
        pub type Vif0W<'a, REG> = crate::BitWriter1C<'a, REG, Vif0>;
        impl<'a, REG> Vif0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No VIF0 interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Vif0::Clear)
            }
            #[doc = "A VIF0 interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Vif0::Set)
            }
        }
        #[doc = "VIF1's detection of VIFcode with an interrupt bit or an exception, or VIF1 stalls with occurrence of an interrupt.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vif1 {
            #[doc = "0: No VIF1 interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A VIF1 interrupt has occurred."]
            Set = 1,
        }
        impl From<Vif1> for bool {
            #[inline(always)]
            fn from(variant: Vif1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VIF1` reader - VIF1's detection of VIFcode with an interrupt bit or an exception, or VIF1 stalls with occurrence of an interrupt."]
        pub type Vif1R = crate::BitReader<Vif1>;
        impl Vif1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vif1 {
                match self.bits {
                    false => Vif1::Clear,
                    true => Vif1::Set,
                }
            }
            #[doc = "No VIF1 interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Vif1::Clear
            }
            #[doc = "A VIF1 interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Vif1::Set
            }
        }
        #[doc = "Field `VIF1` writer - VIF1's detection of VIFcode with an interrupt bit or an exception, or VIF1 stalls with occurrence of an interrupt."]
        pub type Vif1W<'a, REG> = crate::BitWriter1C<'a, REG, Vif1>;
        impl<'a, REG> Vif1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No VIF1 interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Vif1::Clear)
            }
            #[doc = "A VIF1 interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Vif1::Set)
            }
        }
        #[doc = "VU0's execution of a microinstruction with an interrupt bit, or VU0 stalls with occurrence of an interrupt.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vu0 {
            #[doc = "0: No VU0 interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A VU0 interrupt has occurred."]
            Set = 1,
        }
        impl From<Vu0> for bool {
            #[inline(always)]
            fn from(variant: Vu0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VU0` reader - VU0's execution of a microinstruction with an interrupt bit, or VU0 stalls with occurrence of an interrupt."]
        pub type Vu0R = crate::BitReader<Vu0>;
        impl Vu0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vu0 {
                match self.bits {
                    false => Vu0::Clear,
                    true => Vu0::Set,
                }
            }
            #[doc = "No VU0 interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Vu0::Clear
            }
            #[doc = "A VU0 interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Vu0::Set
            }
        }
        #[doc = "Field `VU0` writer - VU0's execution of a microinstruction with an interrupt bit, or VU0 stalls with occurrence of an interrupt."]
        pub type Vu0W<'a, REG> = crate::BitWriter1C<'a, REG, Vu0>;
        impl<'a, REG> Vu0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No VU0 interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Vu0::Clear)
            }
            #[doc = "A VU0 interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Vu0::Set)
            }
        }
        #[doc = "VU1's execution of a microinstruction with an interrupt bit, or VU1 stalls with occurrence of an interrupt.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vu1 {
            #[doc = "0: No VU1 interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A VU1 interrupt has occurred."]
            Set = 1,
        }
        impl From<Vu1> for bool {
            #[inline(always)]
            fn from(variant: Vu1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VU1` reader - VU1's execution of a microinstruction with an interrupt bit, or VU1 stalls with occurrence of an interrupt."]
        pub type Vu1R = crate::BitReader<Vu1>;
        impl Vu1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vu1 {
                match self.bits {
                    false => Vu1::Clear,
                    true => Vu1::Set,
                }
            }
            #[doc = "No VU1 interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Vu1::Clear
            }
            #[doc = "A VU1 interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Vu1::Set
            }
        }
        #[doc = "Field `VU1` writer - VU1's execution of a microinstruction with an interrupt bit, or VU1 stalls with occurrence of an interrupt."]
        pub type Vu1W<'a, REG> = crate::BitWriter1C<'a, REG, Vu1>;
        impl<'a, REG> Vu1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No VU1 interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Vu1::Clear)
            }
            #[doc = "A VU1 interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Vu1::Set)
            }
        }
        #[doc = "IPU's detection of the end of data or an exception IPU stalls with occurrence of an interrupt.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ipu {
            #[doc = "0: No IPU interrupt has occurred."]
            Clear = 0,
            #[doc = "1: An IPU interrupt has occurred."]
            Set = 1,
        }
        impl From<Ipu> for bool {
            #[inline(always)]
            fn from(variant: Ipu) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IPU` reader - IPU's detection of the end of data or an exception IPU stalls with occurrence of an interrupt."]
        pub type IpuR = crate::BitReader<Ipu>;
        impl IpuR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ipu {
                match self.bits {
                    false => Ipu::Clear,
                    true => Ipu::Set,
                }
            }
            #[doc = "No IPU interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Ipu::Clear
            }
            #[doc = "An IPU interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Ipu::Set
            }
        }
        #[doc = "Field `IPU` writer - IPU's detection of the end of data or an exception IPU stalls with occurrence of an interrupt."]
        pub type IpuW<'a, REG> = crate::BitWriter1C<'a, REG, Ipu>;
        impl<'a, REG> IpuW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No IPU interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Ipu::Clear)
            }
            #[doc = "An IPU interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Ipu::Set)
            }
        }
        #[doc = "Conditions met in timer settings\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tim0 {
            #[doc = "0: No TIMER0 interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A TIMER0 interrupt has occurred."]
            Set = 1,
        }
        impl From<Tim0> for bool {
            #[inline(always)]
            fn from(variant: Tim0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIM0` reader - Conditions met in timer settings"]
        pub type Tim0R = crate::BitReader<Tim0>;
        impl Tim0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tim0 {
                match self.bits {
                    false => Tim0::Clear,
                    true => Tim0::Set,
                }
            }
            #[doc = "No TIMER0 interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Tim0::Clear
            }
            #[doc = "A TIMER0 interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Tim0::Set
            }
        }
        #[doc = "Field `TIM0` writer - Conditions met in timer settings"]
        pub type Tim0W<'a, REG> = crate::BitWriter1C<'a, REG, Tim0>;
        impl<'a, REG> Tim0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No TIMER0 interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Tim0::Clear)
            }
            #[doc = "A TIMER0 interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Tim0::Set)
            }
        }
        #[doc = "Conditions met in timer settings\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tim1 {
            #[doc = "0: No TIMER1 interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A TIMER1 interrupt has occurred."]
            Set = 1,
        }
        impl From<Tim1> for bool {
            #[inline(always)]
            fn from(variant: Tim1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIM1` reader - Conditions met in timer settings"]
        pub type Tim1R = crate::BitReader<Tim1>;
        impl Tim1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tim1 {
                match self.bits {
                    false => Tim1::Clear,
                    true => Tim1::Set,
                }
            }
            #[doc = "No TIMER1 interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Tim1::Clear
            }
            #[doc = "A TIMER1 interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Tim1::Set
            }
        }
        #[doc = "Field `TIM1` writer - Conditions met in timer settings"]
        pub type Tim1W<'a, REG> = crate::BitWriter1C<'a, REG, Tim1>;
        impl<'a, REG> Tim1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No TIMER1 interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Tim1::Clear)
            }
            #[doc = "A TIMER1 interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Tim1::Set)
            }
        }
        #[doc = "Conditions met in timer settings\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tim2 {
            #[doc = "0: No TIMER2 interrupt has occurred."]
            Clear = 0,
            #[doc = "1: An TIMER2 interrupt has occurred."]
            Set = 1,
        }
        impl From<Tim2> for bool {
            #[inline(always)]
            fn from(variant: Tim2) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIM2` reader - Conditions met in timer settings"]
        pub type Tim2R = crate::BitReader<Tim2>;
        impl Tim2R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tim2 {
                match self.bits {
                    false => Tim2::Clear,
                    true => Tim2::Set,
                }
            }
            #[doc = "No TIMER2 interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Tim2::Clear
            }
            #[doc = "An TIMER2 interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Tim2::Set
            }
        }
        #[doc = "Field `TIM2` writer - Conditions met in timer settings"]
        pub type Tim2W<'a, REG> = crate::BitWriter1C<'a, REG, Tim2>;
        impl<'a, REG> Tim2W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No TIMER2 interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Tim2::Clear)
            }
            #[doc = "An TIMER2 interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Tim2::Set)
            }
        }
        #[doc = "Conditions met in timer settings\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tim3 {
            #[doc = "0: No TIMER3 interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A TIMER3 interrupt has occurred."]
            Set = 1,
        }
        impl From<Tim3> for bool {
            #[inline(always)]
            fn from(variant: Tim3) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIM3` reader - Conditions met in timer settings"]
        pub type Tim3R = crate::BitReader<Tim3>;
        impl Tim3R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tim3 {
                match self.bits {
                    false => Tim3::Clear,
                    true => Tim3::Set,
                }
            }
            #[doc = "No TIMER3 interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Tim3::Clear
            }
            #[doc = "A TIMER3 interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Tim3::Set
            }
        }
        #[doc = "Field `TIM3` writer - Conditions met in timer settings"]
        pub type Tim3W<'a, REG> = crate::BitWriter1C<'a, REG, Tim3>;
        impl<'a, REG> Tim3W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No TIMER3 interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Tim3::Clear)
            }
            #[doc = "A TIMER3 interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Tim3::Set)
            }
        }
        #[doc = "Error detection during SFIFO transfer\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sfifo {
            #[doc = "0: No SFIFO interrupt has occurred."]
            Clear = 0,
            #[doc = "1: An SFIFO interrupt has occurred."]
            Set = 1,
        }
        impl From<Sfifo> for bool {
            #[inline(always)]
            fn from(variant: Sfifo) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SFIFO` reader - Error detection during SFIFO transfer"]
        pub type SfifoR = crate::BitReader<Sfifo>;
        impl SfifoR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sfifo {
                match self.bits {
                    false => Sfifo::Clear,
                    true => Sfifo::Set,
                }
            }
            #[doc = "No SFIFO interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Sfifo::Clear
            }
            #[doc = "An SFIFO interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Sfifo::Set
            }
        }
        #[doc = "Field `SFIFO` writer - Error detection during SFIFO transfer"]
        pub type SfifoW<'a, REG> = crate::BitWriter1C<'a, REG, Sfifo>;
        impl<'a, REG> SfifoW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No SFIFO interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Sfifo::Clear)
            }
            #[doc = "An SFIFO interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Sfifo::Set)
            }
        }
        #[doc = "VU0 in RUN status for a long time continuously; ForceBreak is sent to VU0.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vu0wd {
            #[doc = "0: No VU0 Watchdog interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A VU0 Watchdog interrupt has occurred."]
            Set = 1,
        }
        impl From<Vu0wd> for bool {
            #[inline(always)]
            fn from(variant: Vu0wd) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VU0WD` reader - VU0 in RUN status for a long time continuously; ForceBreak is sent to VU0."]
        pub type Vu0wdR = crate::BitReader<Vu0wd>;
        impl Vu0wdR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vu0wd {
                match self.bits {
                    false => Vu0wd::Clear,
                    true => Vu0wd::Set,
                }
            }
            #[doc = "No VU0 Watchdog interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Vu0wd::Clear
            }
            #[doc = "A VU0 Watchdog interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Vu0wd::Set
            }
        }
        #[doc = "Field `VU0WD` writer - VU0 in RUN status for a long time continuously; ForceBreak is sent to VU0."]
        pub type Vu0wdW<'a, REG> = crate::BitWriter1C<'a, REG, Vu0wd>;
        impl<'a, REG> Vu0wdW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No VU0 Watchdog interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Vu0wd::Clear)
            }
            #[doc = "A VU0 Watchdog interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Vu0wd::Set)
            }
        }
        #[doc = "DMA channel from IOP for emulating the PS1 GPU\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Pgif {
            #[doc = "0: No PGIF interrupt has occurred."]
            Clear = 0,
            #[doc = "1: A PGIF interrupt has occurred."]
            Set = 1,
        }
        impl From<Pgif> for bool {
            #[inline(always)]
            fn from(variant: Pgif) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PGIF` reader - DMA channel from IOP for emulating the PS1 GPU"]
        pub type PgifR = crate::BitReader<Pgif>;
        impl PgifR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Pgif {
                match self.bits {
                    false => Pgif::Clear,
                    true => Pgif::Set,
                }
            }
            #[doc = "No PGIF interrupt has occurred."]
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == Pgif::Clear
            }
            #[doc = "A PGIF interrupt has occurred."]
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == Pgif::Set
            }
        }
        #[doc = "Field `PGIF` writer - DMA channel from IOP for emulating the PS1 GPU"]
        pub type PgifW<'a, REG> = crate::BitWriter1C<'a, REG, Pgif>;
        impl<'a, REG> PgifW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "No PGIF interrupt has occurred."]
            #[inline(always)]
            pub fn clear(self) -> &'a mut crate::W<REG> {
                self.variant(Pgif::Clear)
            }
            #[doc = "A PGIF interrupt has occurred."]
            #[inline(always)]
            pub fn set_(self) -> &'a mut crate::W<REG> {
                self.variant(Pgif::Set)
            }
        }
        impl R {
            #[doc = "Bit 0 - Detection of an interrupt from GS"]
            #[inline(always)]
            pub fn gs(&self) -> GsR {
                GsR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Detection of an interrupt from a peripheral on SBUS"]
            #[inline(always)]
            pub fn sbus(&self) -> SbusR {
                SbusR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Start of V-Blank"]
            #[inline(always)]
            pub fn vbon(&self) -> VbonR {
                VbonR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - End of V-Blank"]
            #[inline(always)]
            pub fn vbof(&self) -> VbofR {
                VbofR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - VIF0's detection of VIFcode with an interrupt bit or an exception, or VIF0 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vif0(&self) -> Vif0R {
                Vif0R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - VIF1's detection of VIFcode with an interrupt bit or an exception, or VIF1 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vif1(&self) -> Vif1R {
                Vif1R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - VU0's execution of a microinstruction with an interrupt bit, or VU0 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vu0(&self) -> Vu0R {
                Vu0R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - VU1's execution of a microinstruction with an interrupt bit, or VU1 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vu1(&self) -> Vu1R {
                Vu1R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - IPU's detection of the end of data or an exception IPU stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn ipu(&self) -> IpuR {
                IpuR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Conditions met in timer settings"]
            #[inline(always)]
            pub fn tim0(&self) -> Tim0R {
                Tim0R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Conditions met in timer settings"]
            #[inline(always)]
            pub fn tim1(&self) -> Tim1R {
                Tim1R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Conditions met in timer settings"]
            #[inline(always)]
            pub fn tim2(&self) -> Tim2R {
                Tim2R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Conditions met in timer settings"]
            #[inline(always)]
            pub fn tim3(&self) -> Tim3R {
                Tim3R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Error detection during SFIFO transfer"]
            #[inline(always)]
            pub fn sfifo(&self) -> SfifoR {
                SfifoR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - VU0 in RUN status for a long time continuously; ForceBreak is sent to VU0."]
            #[inline(always)]
            pub fn vu0wd(&self) -> Vu0wdR {
                Vu0wdR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - DMA channel from IOP for emulating the PS1 GPU"]
            #[inline(always)]
            pub fn pgif(&self) -> PgifR {
                PgifR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Detection of an interrupt from GS"]
            #[inline(always)]
            pub fn gs(&mut self) -> GsW<IStatSpec> {
                GsW::new(self, 0)
            }
            #[doc = "Bit 1 - Detection of an interrupt from a peripheral on SBUS"]
            #[inline(always)]
            pub fn sbus(&mut self) -> SbusW<IStatSpec> {
                SbusW::new(self, 1)
            }
            #[doc = "Bit 2 - Start of V-Blank"]
            #[inline(always)]
            pub fn vbon(&mut self) -> VbonW<IStatSpec> {
                VbonW::new(self, 2)
            }
            #[doc = "Bit 3 - End of V-Blank"]
            #[inline(always)]
            pub fn vbof(&mut self) -> VbofW<IStatSpec> {
                VbofW::new(self, 3)
            }
            #[doc = "Bit 4 - VIF0's detection of VIFcode with an interrupt bit or an exception, or VIF0 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vif0(&mut self) -> Vif0W<IStatSpec> {
                Vif0W::new(self, 4)
            }
            #[doc = "Bit 5 - VIF1's detection of VIFcode with an interrupt bit or an exception, or VIF1 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vif1(&mut self) -> Vif1W<IStatSpec> {
                Vif1W::new(self, 5)
            }
            #[doc = "Bit 6 - VU0's execution of a microinstruction with an interrupt bit, or VU0 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vu0(&mut self) -> Vu0W<IStatSpec> {
                Vu0W::new(self, 6)
            }
            #[doc = "Bit 7 - VU1's execution of a microinstruction with an interrupt bit, or VU1 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vu1(&mut self) -> Vu1W<IStatSpec> {
                Vu1W::new(self, 7)
            }
            #[doc = "Bit 8 - IPU's detection of the end of data or an exception IPU stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn ipu(&mut self) -> IpuW<IStatSpec> {
                IpuW::new(self, 8)
            }
            #[doc = "Bit 9 - Conditions met in timer settings"]
            #[inline(always)]
            pub fn tim0(&mut self) -> Tim0W<IStatSpec> {
                Tim0W::new(self, 9)
            }
            #[doc = "Bit 10 - Conditions met in timer settings"]
            #[inline(always)]
            pub fn tim1(&mut self) -> Tim1W<IStatSpec> {
                Tim1W::new(self, 10)
            }
            #[doc = "Bit 11 - Conditions met in timer settings"]
            #[inline(always)]
            pub fn tim2(&mut self) -> Tim2W<IStatSpec> {
                Tim2W::new(self, 11)
            }
            #[doc = "Bit 12 - Conditions met in timer settings"]
            #[inline(always)]
            pub fn tim3(&mut self) -> Tim3W<IStatSpec> {
                Tim3W::new(self, 12)
            }
            #[doc = "Bit 13 - Error detection during SFIFO transfer"]
            #[inline(always)]
            pub fn sfifo(&mut self) -> SfifoW<IStatSpec> {
                SfifoW::new(self, 13)
            }
            #[doc = "Bit 14 - VU0 in RUN status for a long time continuously; ForceBreak is sent to VU0."]
            #[inline(always)]
            pub fn vu0wd(&mut self) -> Vu0wdW<IStatSpec> {
                Vu0wdW::new(self, 14)
            }
            #[doc = "Bit 15 - DMA channel from IOP for emulating the PS1 GPU"]
            #[inline(always)]
            pub fn pgif(&mut self) -> PgifW<IStatSpec> {
                PgifW::new(self, 15)
            }
        }
        #[doc = "Interrupt Status\n\nYou can [`read`](crate::Reg::read) this register and get [`i_stat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`i_stat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IStatSpec;
        impl crate::RegisterSpec for IStatSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`i_stat::R`](R) reader structure"]
        impl crate::Readable for IStatSpec {}
        #[doc = "`write(|w| ..)` method takes [`i_stat::W`](W) writer structure"]
        impl crate::Writable for IStatSpec {
            type Safety = crate::Unsafe;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0xffff;
        }
        #[doc = "`reset()` method sets I_STAT to value 0"]
        impl crate::Resettable for IStatSpec {}
    }
    #[doc = "I_MASK (rw) register accessor: Interrupt Mask\n\nYou can [`read`](crate::Reg::read) this register and get [`i_mask::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`i_mask::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i_mask`] module"]
    #[doc(alias = "I_MASK")]
    pub type IMask = crate::Reg<i_mask::IMaskSpec>;
    #[doc = "Interrupt Mask"]
    pub mod i_mask {
        #[doc = "Register `I_MASK` reader"]
        pub type R = crate::R<IMaskSpec>;
        #[doc = "Register `I_MASK` writer"]
        pub type W = crate::W<IMaskSpec>;
        #[doc = "Detection of an interrupt from GS\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Gs {
            #[doc = "0: GS interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: GS interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Gs> for bool {
            #[inline(always)]
            fn from(variant: Gs) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `GS` reader - Detection of an interrupt from GS"]
        pub type GsR = crate::BitReader<Gs>;
        impl GsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Gs {
                match self.bits {
                    false => Gs::Disabled,
                    true => Gs::Enabled,
                }
            }
            #[doc = "GS interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Gs::Disabled
            }
            #[doc = "GS interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Gs::Enabled
            }
        }
        #[doc = "Field `GS` writer - Detection of an interrupt from GS"]
        pub type GsW<'a, REG> = crate::BitWriter<'a, REG, Gs>;
        impl<'a, REG> GsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "GS interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Gs::Disabled)
            }
            #[doc = "GS interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Gs::Enabled)
            }
        }
        #[doc = "Detection of an interrupt from a peripheral on SBUS\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sbus {
            #[doc = "0: SBUS interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: SBUS interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Sbus> for bool {
            #[inline(always)]
            fn from(variant: Sbus) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SBUS` reader - Detection of an interrupt from a peripheral on SBUS"]
        pub type SbusR = crate::BitReader<Sbus>;
        impl SbusR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sbus {
                match self.bits {
                    false => Sbus::Disabled,
                    true => Sbus::Enabled,
                }
            }
            #[doc = "SBUS interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Sbus::Disabled
            }
            #[doc = "SBUS interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Sbus::Enabled
            }
        }
        #[doc = "Field `SBUS` writer - Detection of an interrupt from a peripheral on SBUS"]
        pub type SbusW<'a, REG> = crate::BitWriter<'a, REG, Sbus>;
        impl<'a, REG> SbusW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "SBUS interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Sbus::Disabled)
            }
            #[doc = "SBUS interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Sbus::Enabled)
            }
        }
        #[doc = "Start of V-Blank\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vbon {
            #[doc = "0: Start of V-Blank interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: Start of V-Blank interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Vbon> for bool {
            #[inline(always)]
            fn from(variant: Vbon) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VBON` reader - Start of V-Blank"]
        pub type VbonR = crate::BitReader<Vbon>;
        impl VbonR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vbon {
                match self.bits {
                    false => Vbon::Disabled,
                    true => Vbon::Enabled,
                }
            }
            #[doc = "Start of V-Blank interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Vbon::Disabled
            }
            #[doc = "Start of V-Blank interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Vbon::Enabled
            }
        }
        #[doc = "Field `VBON` writer - Start of V-Blank"]
        pub type VbonW<'a, REG> = crate::BitWriter<'a, REG, Vbon>;
        impl<'a, REG> VbonW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Start of V-Blank interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vbon::Disabled)
            }
            #[doc = "Start of V-Blank interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vbon::Enabled)
            }
        }
        #[doc = "End of V-Blank\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vbof {
            #[doc = "0: End of V-Blank interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: End of V-Blank interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Vbof> for bool {
            #[inline(always)]
            fn from(variant: Vbof) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VBOF` reader - End of V-Blank"]
        pub type VbofR = crate::BitReader<Vbof>;
        impl VbofR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vbof {
                match self.bits {
                    false => Vbof::Disabled,
                    true => Vbof::Enabled,
                }
            }
            #[doc = "End of V-Blank interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Vbof::Disabled
            }
            #[doc = "End of V-Blank interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Vbof::Enabled
            }
        }
        #[doc = "Field `VBOF` writer - End of V-Blank"]
        pub type VbofW<'a, REG> = crate::BitWriter<'a, REG, Vbof>;
        impl<'a, REG> VbofW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "End of V-Blank interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vbof::Disabled)
            }
            #[doc = "End of V-Blank interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vbof::Enabled)
            }
        }
        #[doc = "VIF0's detection of VIFcode with an interrupt bit or an exception, or VIF0 stalls with occurrence of an interrupt.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vif0 {
            #[doc = "0: VIF0 interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: VIF0 interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Vif0> for bool {
            #[inline(always)]
            fn from(variant: Vif0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VIF0` reader - VIF0's detection of VIFcode with an interrupt bit or an exception, or VIF0 stalls with occurrence of an interrupt."]
        pub type Vif0R = crate::BitReader<Vif0>;
        impl Vif0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vif0 {
                match self.bits {
                    false => Vif0::Disabled,
                    true => Vif0::Enabled,
                }
            }
            #[doc = "VIF0 interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Vif0::Disabled
            }
            #[doc = "VIF0 interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Vif0::Enabled
            }
        }
        #[doc = "Field `VIF0` writer - VIF0's detection of VIFcode with an interrupt bit or an exception, or VIF0 stalls with occurrence of an interrupt."]
        pub type Vif0W<'a, REG> = crate::BitWriter<'a, REG, Vif0>;
        impl<'a, REG> Vif0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "VIF0 interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vif0::Disabled)
            }
            #[doc = "VIF0 interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vif0::Enabled)
            }
        }
        #[doc = "VIF1's detection of VIFcode with an interrupt bit or an exception, or VIF1 stalls with occurrence of an interrupt.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vif1 {
            #[doc = "0: VIF1 interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: VIF1 interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Vif1> for bool {
            #[inline(always)]
            fn from(variant: Vif1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VIF1` reader - VIF1's detection of VIFcode with an interrupt bit or an exception, or VIF1 stalls with occurrence of an interrupt."]
        pub type Vif1R = crate::BitReader<Vif1>;
        impl Vif1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vif1 {
                match self.bits {
                    false => Vif1::Disabled,
                    true => Vif1::Enabled,
                }
            }
            #[doc = "VIF1 interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Vif1::Disabled
            }
            #[doc = "VIF1 interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Vif1::Enabled
            }
        }
        #[doc = "Field `VIF1` writer - VIF1's detection of VIFcode with an interrupt bit or an exception, or VIF1 stalls with occurrence of an interrupt."]
        pub type Vif1W<'a, REG> = crate::BitWriter<'a, REG, Vif1>;
        impl<'a, REG> Vif1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "VIF1 interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vif1::Disabled)
            }
            #[doc = "VIF1 interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vif1::Enabled)
            }
        }
        #[doc = "VU0's execution of a microinstruction with an interrupt bit, or VU0 stalls with occurrence of an interrupt.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vu0 {
            #[doc = "0: VU0 interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: VU0 interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Vu0> for bool {
            #[inline(always)]
            fn from(variant: Vu0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VU0` reader - VU0's execution of a microinstruction with an interrupt bit, or VU0 stalls with occurrence of an interrupt."]
        pub type Vu0R = crate::BitReader<Vu0>;
        impl Vu0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vu0 {
                match self.bits {
                    false => Vu0::Disabled,
                    true => Vu0::Enabled,
                }
            }
            #[doc = "VU0 interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Vu0::Disabled
            }
            #[doc = "VU0 interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Vu0::Enabled
            }
        }
        #[doc = "Field `VU0` writer - VU0's execution of a microinstruction with an interrupt bit, or VU0 stalls with occurrence of an interrupt."]
        pub type Vu0W<'a, REG> = crate::BitWriter<'a, REG, Vu0>;
        impl<'a, REG> Vu0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "VU0 interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vu0::Disabled)
            }
            #[doc = "VU0 interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vu0::Enabled)
            }
        }
        #[doc = "VU1's execution of a microinstruction with an interrupt bit, or VU1 stalls with occurrence of an interrupt.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vu1 {
            #[doc = "0: VU1 interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: VU1 interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Vu1> for bool {
            #[inline(always)]
            fn from(variant: Vu1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VU1` reader - VU1's execution of a microinstruction with an interrupt bit, or VU1 stalls with occurrence of an interrupt."]
        pub type Vu1R = crate::BitReader<Vu1>;
        impl Vu1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vu1 {
                match self.bits {
                    false => Vu1::Disabled,
                    true => Vu1::Enabled,
                }
            }
            #[doc = "VU1 interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Vu1::Disabled
            }
            #[doc = "VU1 interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Vu1::Enabled
            }
        }
        #[doc = "Field `VU1` writer - VU1's execution of a microinstruction with an interrupt bit, or VU1 stalls with occurrence of an interrupt."]
        pub type Vu1W<'a, REG> = crate::BitWriter<'a, REG, Vu1>;
        impl<'a, REG> Vu1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "VU1 interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vu1::Disabled)
            }
            #[doc = "VU1 interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vu1::Enabled)
            }
        }
        #[doc = "IPU's detection of the end of data or an exception IPU stalls with occurrence of an interrupt.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ipu {
            #[doc = "0: IPU interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: IPU interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Ipu> for bool {
            #[inline(always)]
            fn from(variant: Ipu) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `IPU` reader - IPU's detection of the end of data or an exception IPU stalls with occurrence of an interrupt."]
        pub type IpuR = crate::BitReader<Ipu>;
        impl IpuR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ipu {
                match self.bits {
                    false => Ipu::Disabled,
                    true => Ipu::Enabled,
                }
            }
            #[doc = "IPU interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Ipu::Disabled
            }
            #[doc = "IPU interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Ipu::Enabled
            }
        }
        #[doc = "Field `IPU` writer - IPU's detection of the end of data or an exception IPU stalls with occurrence of an interrupt."]
        pub type IpuW<'a, REG> = crate::BitWriter<'a, REG, Ipu>;
        impl<'a, REG> IpuW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "IPU interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ipu::Disabled)
            }
            #[doc = "IPU interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Ipu::Enabled)
            }
        }
        #[doc = "Conditions met in timer 0 settings\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tim0 {
            #[doc = "0: TIMER0 interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: TIMER0 interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Tim0> for bool {
            #[inline(always)]
            fn from(variant: Tim0) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIM0` reader - Conditions met in timer 0 settings"]
        pub type Tim0R = crate::BitReader<Tim0>;
        impl Tim0R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tim0 {
                match self.bits {
                    false => Tim0::Disabled,
                    true => Tim0::Enabled,
                }
            }
            #[doc = "TIMER0 interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Tim0::Disabled
            }
            #[doc = "TIMER0 interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Tim0::Enabled
            }
        }
        #[doc = "Field `TIM0` writer - Conditions met in timer 0 settings"]
        pub type Tim0W<'a, REG> = crate::BitWriter<'a, REG, Tim0>;
        impl<'a, REG> Tim0W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "TIMER0 interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Tim0::Disabled)
            }
            #[doc = "TIMER0 interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Tim0::Enabled)
            }
        }
        #[doc = "Conditions met in timer 1 settings\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tim1 {
            #[doc = "0: TIMER1 interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: TIMER1 interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Tim1> for bool {
            #[inline(always)]
            fn from(variant: Tim1) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIM1` reader - Conditions met in timer 1 settings"]
        pub type Tim1R = crate::BitReader<Tim1>;
        impl Tim1R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tim1 {
                match self.bits {
                    false => Tim1::Disabled,
                    true => Tim1::Enabled,
                }
            }
            #[doc = "TIMER1 interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Tim1::Disabled
            }
            #[doc = "TIMER1 interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Tim1::Enabled
            }
        }
        #[doc = "Field `TIM1` writer - Conditions met in timer 1 settings"]
        pub type Tim1W<'a, REG> = crate::BitWriter<'a, REG, Tim1>;
        impl<'a, REG> Tim1W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "TIMER1 interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Tim1::Disabled)
            }
            #[doc = "TIMER1 interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Tim1::Enabled)
            }
        }
        #[doc = "Conditions met in timer 2 settings\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tim2 {
            #[doc = "0: TIMER2 interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: TIMER2 interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Tim2> for bool {
            #[inline(always)]
            fn from(variant: Tim2) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIM2` reader - Conditions met in timer 2 settings"]
        pub type Tim2R = crate::BitReader<Tim2>;
        impl Tim2R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tim2 {
                match self.bits {
                    false => Tim2::Disabled,
                    true => Tim2::Enabled,
                }
            }
            #[doc = "TIMER2 interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Tim2::Disabled
            }
            #[doc = "TIMER2 interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Tim2::Enabled
            }
        }
        #[doc = "Field `TIM2` writer - Conditions met in timer 2 settings"]
        pub type Tim2W<'a, REG> = crate::BitWriter<'a, REG, Tim2>;
        impl<'a, REG> Tim2W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "TIMER2 interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Tim2::Disabled)
            }
            #[doc = "TIMER2 interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Tim2::Enabled)
            }
        }
        #[doc = "Conditions met in timer 3 settings\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Tim3 {
            #[doc = "0: TIMER3 interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: TIMER3 interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Tim3> for bool {
            #[inline(always)]
            fn from(variant: Tim3) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TIM3` reader - Conditions met in timer 3 settings"]
        pub type Tim3R = crate::BitReader<Tim3>;
        impl Tim3R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tim3 {
                match self.bits {
                    false => Tim3::Disabled,
                    true => Tim3::Enabled,
                }
            }
            #[doc = "TIMER3 interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Tim3::Disabled
            }
            #[doc = "TIMER3 interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Tim3::Enabled
            }
        }
        #[doc = "Field `TIM3` writer - Conditions met in timer 3 settings"]
        pub type Tim3W<'a, REG> = crate::BitWriter<'a, REG, Tim3>;
        impl<'a, REG> Tim3W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "TIMER3 interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Tim3::Disabled)
            }
            #[doc = "TIMER3 interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Tim3::Enabled)
            }
        }
        #[doc = "Error detection during SFIFO transfer\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Sfifo {
            #[doc = "0: SFIFO interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: SFIFO interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Sfifo> for bool {
            #[inline(always)]
            fn from(variant: Sfifo) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `SFIFO` reader - Error detection during SFIFO transfer"]
        pub type SfifoR = crate::BitReader<Sfifo>;
        impl SfifoR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sfifo {
                match self.bits {
                    false => Sfifo::Disabled,
                    true => Sfifo::Enabled,
                }
            }
            #[doc = "SFIFO interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Sfifo::Disabled
            }
            #[doc = "SFIFO interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Sfifo::Enabled
            }
        }
        #[doc = "Field `SFIFO` writer - Error detection during SFIFO transfer"]
        pub type SfifoW<'a, REG> = crate::BitWriter<'a, REG, Sfifo>;
        impl<'a, REG> SfifoW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "SFIFO interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Sfifo::Disabled)
            }
            #[doc = "SFIFO interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Sfifo::Enabled)
            }
        }
        #[doc = "VU0 in RUN status for a long time continuously; ForceBreak is sent to VU0.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Vu0wd {
            #[doc = "0: VU0 Watchdog interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: VU0 Watchdog interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Vu0wd> for bool {
            #[inline(always)]
            fn from(variant: Vu0wd) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `VU0WD` reader - VU0 in RUN status for a long time continuously; ForceBreak is sent to VU0."]
        pub type Vu0wdR = crate::BitReader<Vu0wd>;
        impl Vu0wdR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Vu0wd {
                match self.bits {
                    false => Vu0wd::Disabled,
                    true => Vu0wd::Enabled,
                }
            }
            #[doc = "VU0 Watchdog interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Vu0wd::Disabled
            }
            #[doc = "VU0 Watchdog interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Vu0wd::Enabled
            }
        }
        #[doc = "Field `VU0WD` writer - VU0 in RUN status for a long time continuously; ForceBreak is sent to VU0."]
        pub type Vu0wdW<'a, REG> = crate::BitWriter<'a, REG, Vu0wd>;
        impl<'a, REG> Vu0wdW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "VU0 Watchdog interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vu0wd::Disabled)
            }
            #[doc = "VU0 Watchdog interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Vu0wd::Enabled)
            }
        }
        #[doc = "DMA channel from IOP for emulating the PS1 GPU\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Pgif {
            #[doc = "0: PGIF interrupts are disabled."]
            Disabled = 0,
            #[doc = "1: PGIF interrupts are enabled."]
            Enabled = 1,
        }
        impl From<Pgif> for bool {
            #[inline(always)]
            fn from(variant: Pgif) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `PGIF` reader - DMA channel from IOP for emulating the PS1 GPU"]
        pub type PgifR = crate::BitReader<Pgif>;
        impl PgifR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Pgif {
                match self.bits {
                    false => Pgif::Disabled,
                    true => Pgif::Enabled,
                }
            }
            #[doc = "PGIF interrupts are disabled."]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == Pgif::Disabled
            }
            #[doc = "PGIF interrupts are enabled."]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == Pgif::Enabled
            }
        }
        #[doc = "Field `PGIF` writer - DMA channel from IOP for emulating the PS1 GPU"]
        pub type PgifW<'a, REG> = crate::BitWriter<'a, REG, Pgif>;
        impl<'a, REG> PgifW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "PGIF interrupts are disabled."]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut crate::W<REG> {
                self.variant(Pgif::Disabled)
            }
            #[doc = "PGIF interrupts are enabled."]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut crate::W<REG> {
                self.variant(Pgif::Enabled)
            }
        }
        impl R {
            #[doc = "Bit 0 - Detection of an interrupt from GS"]
            #[inline(always)]
            pub fn gs(&self) -> GsR {
                GsR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Detection of an interrupt from a peripheral on SBUS"]
            #[inline(always)]
            pub fn sbus(&self) -> SbusR {
                SbusR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Start of V-Blank"]
            #[inline(always)]
            pub fn vbon(&self) -> VbonR {
                VbonR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - End of V-Blank"]
            #[inline(always)]
            pub fn vbof(&self) -> VbofR {
                VbofR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - VIF0's detection of VIFcode with an interrupt bit or an exception, or VIF0 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vif0(&self) -> Vif0R {
                Vif0R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - VIF1's detection of VIFcode with an interrupt bit or an exception, or VIF1 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vif1(&self) -> Vif1R {
                Vif1R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - VU0's execution of a microinstruction with an interrupt bit, or VU0 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vu0(&self) -> Vu0R {
                Vu0R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - VU1's execution of a microinstruction with an interrupt bit, or VU1 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vu1(&self) -> Vu1R {
                Vu1R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - IPU's detection of the end of data or an exception IPU stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn ipu(&self) -> IpuR {
                IpuR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Conditions met in timer 0 settings"]
            #[inline(always)]
            pub fn tim0(&self) -> Tim0R {
                Tim0R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - Conditions met in timer 1 settings"]
            #[inline(always)]
            pub fn tim1(&self) -> Tim1R {
                Tim1R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Conditions met in timer 2 settings"]
            #[inline(always)]
            pub fn tim2(&self) -> Tim2R {
                Tim2R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Conditions met in timer 3 settings"]
            #[inline(always)]
            pub fn tim3(&self) -> Tim3R {
                Tim3R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Error detection during SFIFO transfer"]
            #[inline(always)]
            pub fn sfifo(&self) -> SfifoR {
                SfifoR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - VU0 in RUN status for a long time continuously; ForceBreak is sent to VU0."]
            #[inline(always)]
            pub fn vu0wd(&self) -> Vu0wdR {
                Vu0wdR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - DMA channel from IOP for emulating the PS1 GPU"]
            #[inline(always)]
            pub fn pgif(&self) -> PgifR {
                PgifR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Detection of an interrupt from GS"]
            #[inline(always)]
            pub fn gs(&mut self) -> GsW<IMaskSpec> {
                GsW::new(self, 0)
            }
            #[doc = "Bit 1 - Detection of an interrupt from a peripheral on SBUS"]
            #[inline(always)]
            pub fn sbus(&mut self) -> SbusW<IMaskSpec> {
                SbusW::new(self, 1)
            }
            #[doc = "Bit 2 - Start of V-Blank"]
            #[inline(always)]
            pub fn vbon(&mut self) -> VbonW<IMaskSpec> {
                VbonW::new(self, 2)
            }
            #[doc = "Bit 3 - End of V-Blank"]
            #[inline(always)]
            pub fn vbof(&mut self) -> VbofW<IMaskSpec> {
                VbofW::new(self, 3)
            }
            #[doc = "Bit 4 - VIF0's detection of VIFcode with an interrupt bit or an exception, or VIF0 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vif0(&mut self) -> Vif0W<IMaskSpec> {
                Vif0W::new(self, 4)
            }
            #[doc = "Bit 5 - VIF1's detection of VIFcode with an interrupt bit or an exception, or VIF1 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vif1(&mut self) -> Vif1W<IMaskSpec> {
                Vif1W::new(self, 5)
            }
            #[doc = "Bit 6 - VU0's execution of a microinstruction with an interrupt bit, or VU0 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vu0(&mut self) -> Vu0W<IMaskSpec> {
                Vu0W::new(self, 6)
            }
            #[doc = "Bit 7 - VU1's execution of a microinstruction with an interrupt bit, or VU1 stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn vu1(&mut self) -> Vu1W<IMaskSpec> {
                Vu1W::new(self, 7)
            }
            #[doc = "Bit 8 - IPU's detection of the end of data or an exception IPU stalls with occurrence of an interrupt."]
            #[inline(always)]
            pub fn ipu(&mut self) -> IpuW<IMaskSpec> {
                IpuW::new(self, 8)
            }
            #[doc = "Bit 9 - Conditions met in timer 0 settings"]
            #[inline(always)]
            pub fn tim0(&mut self) -> Tim0W<IMaskSpec> {
                Tim0W::new(self, 9)
            }
            #[doc = "Bit 10 - Conditions met in timer 1 settings"]
            #[inline(always)]
            pub fn tim1(&mut self) -> Tim1W<IMaskSpec> {
                Tim1W::new(self, 10)
            }
            #[doc = "Bit 11 - Conditions met in timer 2 settings"]
            #[inline(always)]
            pub fn tim2(&mut self) -> Tim2W<IMaskSpec> {
                Tim2W::new(self, 11)
            }
            #[doc = "Bit 12 - Conditions met in timer 3 settings"]
            #[inline(always)]
            pub fn tim3(&mut self) -> Tim3W<IMaskSpec> {
                Tim3W::new(self, 12)
            }
            #[doc = "Bit 13 - Error detection during SFIFO transfer"]
            #[inline(always)]
            pub fn sfifo(&mut self) -> SfifoW<IMaskSpec> {
                SfifoW::new(self, 13)
            }
            #[doc = "Bit 14 - VU0 in RUN status for a long time continuously; ForceBreak is sent to VU0."]
            #[inline(always)]
            pub fn vu0wd(&mut self) -> Vu0wdW<IMaskSpec> {
                Vu0wdW::new(self, 14)
            }
            #[doc = "Bit 15 - DMA channel from IOP for emulating the PS1 GPU"]
            #[inline(always)]
            pub fn pgif(&mut self) -> PgifW<IMaskSpec> {
                PgifW::new(self, 15)
            }
        }
        #[doc = "Interrupt Mask\n\nYou can [`read`](crate::Reg::read) this register and get [`i_mask::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`i_mask::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IMaskSpec;
        impl crate::RegisterSpec for IMaskSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`i_mask::R`](R) reader structure"]
        impl crate::Readable for IMaskSpec {}
        #[doc = "`write(|w| ..)` method takes [`i_mask::W`](W) writer structure"]
        impl crate::Writable for IMaskSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets I_MASK to value 0"]
        impl crate::Resettable for IMaskSpec {}
    }
}
#[doc = "Serial Input/Output"]
pub type Sio = crate::Periph<sio::RegisterBlock, 0xb000_f100>;
impl core::fmt::Debug for Sio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sio").finish()
    }
}
#[doc = "Serial Input/Output"]
pub mod sio {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        sio_lcr: SioLcr,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Line Control Register. Controls the serial data format. Matches the same register found in the TMPR4937 CPU."]
        #[inline(always)]
        pub const fn sio_lcr(&self) -> &SioLcr {
            &self.sio_lcr
        }
    }
    #[doc = "SIO_LCR (rw) register accessor: Line Control Register. Controls the serial data format. Matches the same register found in the TMPR4937 CPU.\n\nYou can [`read`](crate::Reg::read) this register and get [`sio_lcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sio_lcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sio_lcr`] module"]
    #[doc(alias = "SIO_LCR")]
    pub type SioLcr = crate::Reg<sio_lcr::SioLcrSpec>;
    #[doc = "Line Control Register. Controls the serial data format. Matches the same register found in the TMPR4937 CPU."]
    pub mod sio_lcr {
        #[doc = "Register `SIO_LCR` reader"]
        pub type R = crate::R<SioLcrSpec>;
        #[doc = "Register `SIO_LCR` writer"]
        pub type W = crate::W<SioLcrSpec>;
        #[doc = "The length of each data frame.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Umodelen {
            #[doc = "0: 8-bit data length."]
            Bit8 = 0,
            #[doc = "1: 7-bit data length."]
            Bit7 = 1,
        }
        impl From<Umodelen> for bool {
            #[inline(always)]
            fn from(variant: Umodelen) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `UMODELEN` reader - The length of each data frame."]
        pub type UmodelenR = crate::BitReader<Umodelen>;
        impl UmodelenR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Umodelen {
                match self.bits {
                    false => Umodelen::Bit8,
                    true => Umodelen::Bit7,
                }
            }
            #[doc = "8-bit data length."]
            #[inline(always)]
            pub fn is_bit8(&self) -> bool {
                *self == Umodelen::Bit8
            }
            #[doc = "7-bit data length."]
            #[inline(always)]
            pub fn is_bit7(&self) -> bool {
                *self == Umodelen::Bit7
            }
        }
        #[doc = "Field `UMODELEN` writer - The length of each data frame."]
        pub type UmodelenW<'a, REG> = crate::BitWriter<'a, REG, Umodelen>;
        impl<'a, REG> UmodelenW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "8-bit data length."]
            #[inline(always)]
            pub fn bit8(self) -> &'a mut crate::W<REG> {
                self.variant(Umodelen::Bit8)
            }
            #[doc = "7-bit data length."]
            #[inline(always)]
            pub fn bit7(self) -> &'a mut crate::W<REG> {
                self.variant(Umodelen::Bit7)
            }
        }
        #[doc = "Whether to add a TX wake-up bit after data bits.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Umodemc {
            #[doc = "0: Multi-Controller off."]
            Disable = 0,
            #[doc = "1: Multi-Controller on."]
            Enable = 1,
        }
        impl From<Umodemc> for bool {
            #[inline(always)]
            fn from(variant: Umodemc) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `UMODEMC` reader - Whether to add a TX wake-up bit after data bits."]
        pub type UmodemcR = crate::BitReader<Umodemc>;
        impl UmodemcR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Umodemc {
                match self.bits {
                    false => Umodemc::Disable,
                    true => Umodemc::Enable,
                }
            }
            #[doc = "Multi-Controller off."]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Umodemc::Disable
            }
            #[doc = "Multi-Controller on."]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Umodemc::Enable
            }
        }
        #[doc = "Field `UMODEMC` writer - Whether to add a TX wake-up bit after data bits."]
        pub type UmodemcW<'a, REG> = crate::BitWriter<'a, REG, Umodemc>;
        impl<'a, REG> UmodemcW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Multi-Controller off."]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Umodemc::Disable)
            }
            #[doc = "Multi-Controller on."]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Umodemc::Enable)
            }
        }
        #[doc = "How many stop bits to add.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Usbl {
            #[doc = "0: One bit."]
            Bit1 = 0,
            #[doc = "1: Two bits."]
            Bit2 = 1,
        }
        impl From<Usbl> for bool {
            #[inline(always)]
            fn from(variant: Usbl) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `USBL` reader - How many stop bits to add."]
        pub type UsblR = crate::BitReader<Usbl>;
        impl UsblR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Usbl {
                match self.bits {
                    false => Usbl::Bit1,
                    true => Usbl::Bit2,
                }
            }
            #[doc = "One bit."]
            #[inline(always)]
            pub fn is_bit1(&self) -> bool {
                *self == Usbl::Bit1
            }
            #[doc = "Two bits."]
            #[inline(always)]
            pub fn is_bit2(&self) -> bool {
                *self == Usbl::Bit2
            }
        }
        #[doc = "Field `USBL` writer - How many stop bits to add."]
        pub type UsblW<'a, REG> = crate::BitWriter<'a, REG, Usbl>;
        impl<'a, REG> UsblW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "One bit."]
            #[inline(always)]
            pub fn bit1(self) -> &'a mut crate::W<REG> {
                self.variant(Usbl::Bit1)
            }
            #[doc = "Two bits."]
            #[inline(always)]
            pub fn bit2(self) -> &'a mut crate::W<REG> {
                self.variant(Usbl::Bit2)
            }
        }
        #[doc = "Enable/disable parity-checking. MUST BE DISABLED when MCENABLE is on.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Upen {
            #[doc = "0: Parity check is disabled."]
            Disable = 0,
            #[doc = "1: Parity check is enabled."]
            Enable = 1,
        }
        impl From<Upen> for bool {
            #[inline(always)]
            fn from(variant: Upen) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `UPEN` reader - Enable/disable parity-checking. MUST BE DISABLED when MCENABLE is on."]
        pub type UpenR = crate::BitReader<Upen>;
        impl UpenR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Upen {
                match self.bits {
                    false => Upen::Disable,
                    true => Upen::Enable,
                }
            }
            #[doc = "Parity check is disabled."]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Upen::Disable
            }
            #[doc = "Parity check is enabled."]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Upen::Enable
            }
        }
        #[doc = "Field `UPEN` writer - Enable/disable parity-checking. MUST BE DISABLED when MCENABLE is on."]
        pub type UpenW<'a, REG> = crate::BitWriter<'a, REG, Upen>;
        impl<'a, REG> UpenW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Parity check is disabled."]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Upen::Disable)
            }
            #[doc = "Parity check is enabled."]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Upen::Enable)
            }
        }
        #[doc = "Odd or even parity.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ueps {
            #[doc = "0: Use odd parity."]
            Odd = 0,
            #[doc = "1: Use even parity."]
            Even = 1,
        }
        impl From<Ueps> for bool {
            #[inline(always)]
            fn from(variant: Ueps) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `UEPS` reader - Odd or even parity."]
        pub type UepsR = crate::BitReader<Ueps>;
        impl UepsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ueps {
                match self.bits {
                    false => Ueps::Odd,
                    true => Ueps::Even,
                }
            }
            #[doc = "Use odd parity."]
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                *self == Ueps::Odd
            }
            #[doc = "Use even parity."]
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                *self == Ueps::Even
            }
        }
        #[doc = "Field `UEPS` writer - Odd or even parity."]
        pub type UepsW<'a, REG> = crate::BitWriter<'a, REG, Ueps>;
        impl<'a, REG> UepsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Use odd parity."]
            #[inline(always)]
            pub fn odd(self) -> &'a mut crate::W<REG> {
                self.variant(Ueps::Odd)
            }
            #[doc = "Use even parity."]
            #[inline(always)]
            pub fn even(self) -> &'a mut crate::W<REG> {
                self.variant(Ueps::Even)
            }
        }
        #[doc = "Selects the serial transfer clock. The baud rate is equal to the chosen clock frequency divided by 16.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Scs {
            #[doc = "0: Uses the internal clock (IMBUSCLK)."]
            Internal = 0,
            #[doc = "1: The IMBUSCLK divided by the baud rate generator output."]
            BrgDivInternal = 1,
            #[doc = "2: Uses an external clock (SCLK)."]
            External = 2,
            #[doc = "3: The SCLK divided by the baud rate generator output."]
            BrgDivExternal = 3,
        }
        impl From<Scs> for u8 {
            #[inline(always)]
            fn from(variant: Scs) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Scs {
            type Ux = u8;
        }
        impl crate::IsEnum for Scs {}
        #[doc = "Field `SCS` reader - Selects the serial transfer clock. The baud rate is equal to the chosen clock frequency divided by 16."]
        pub type ScsR = crate::FieldReader<Scs>;
        impl ScsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Scs {
                match self.bits {
                    0 => Scs::Internal,
                    1 => Scs::BrgDivInternal,
                    2 => Scs::External,
                    3 => Scs::BrgDivExternal,
                    _ => unreachable!(),
                }
            }
            #[doc = "Uses the internal clock (IMBUSCLK)."]
            #[inline(always)]
            pub fn is_internal(&self) -> bool {
                *self == Scs::Internal
            }
            #[doc = "The IMBUSCLK divided by the baud rate generator output."]
            #[inline(always)]
            pub fn is_brg_div_internal(&self) -> bool {
                *self == Scs::BrgDivInternal
            }
            #[doc = "Uses an external clock (SCLK)."]
            #[inline(always)]
            pub fn is_external(&self) -> bool {
                *self == Scs::External
            }
            #[doc = "The SCLK divided by the baud rate generator output."]
            #[inline(always)]
            pub fn is_brg_div_external(&self) -> bool {
                *self == Scs::BrgDivExternal
            }
        }
        #[doc = "Field `SCS` writer - Selects the serial transfer clock. The baud rate is equal to the chosen clock frequency divided by 16."]
        pub type ScsW<'a, REG> = crate::FieldWriter<'a, REG, 2, Scs, crate::Safe>;
        impl<'a, REG> ScsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Uses the internal clock (IMBUSCLK)."]
            #[inline(always)]
            pub fn internal(self) -> &'a mut crate::W<REG> {
                self.variant(Scs::Internal)
            }
            #[doc = "The IMBUSCLK divided by the baud rate generator output."]
            #[inline(always)]
            pub fn brg_div_internal(self) -> &'a mut crate::W<REG> {
                self.variant(Scs::BrgDivInternal)
            }
            #[doc = "Uses an external clock (SCLK)."]
            #[inline(always)]
            pub fn external(self) -> &'a mut crate::W<REG> {
                self.variant(Scs::External)
            }
            #[doc = "The SCLK divided by the baud rate generator output."]
            #[inline(always)]
            pub fn brg_div_external(self) -> &'a mut crate::W<REG> {
                self.variant(Scs::BrgDivExternal)
            }
        }
        #[doc = "Enables RTC-CTS flow control. When high, allows data to be queued for transmission in TX FIFO if CTS is high.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Ufce {
            #[doc = "0: Flow control is disabled."]
            Disable = 0,
            #[doc = "1: Flow control is enabled."]
            Enable = 1,
        }
        impl From<Ufce> for bool {
            #[inline(always)]
            fn from(variant: Ufce) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `UFCE` reader - Enables RTC-CTS flow control. When high, allows data to be queued for transmission in TX FIFO if CTS is high."]
        pub type UfceR = crate::BitReader<Ufce>;
        impl UfceR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ufce {
                match self.bits {
                    false => Ufce::Disable,
                    true => Ufce::Enable,
                }
            }
            #[doc = "Flow control is disabled."]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == Ufce::Disable
            }
            #[doc = "Flow control is enabled."]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == Ufce::Enable
            }
        }
        #[doc = "Field `UFCE` writer - Enables RTC-CTS flow control. When high, allows data to be queued for transmission in TX FIFO if CTS is high."]
        pub type UfceW<'a, REG> = crate::BitWriter<'a, REG, Ufce>;
        impl<'a, REG> UfceW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Flow control is disabled."]
            #[inline(always)]
            pub fn disable(self) -> &'a mut crate::W<REG> {
                self.variant(Ufce::Disable)
            }
            #[doc = "Flow control is enabled."]
            #[inline(always)]
            pub fn enable(self) -> &'a mut crate::W<REG> {
                self.variant(Ufce::Enable)
            }
        }
        #[doc = "Controls the output mode of the TXD signal. Expects the slave controller to set the TXD signal to Open Drain when Multi-Controller is enabled.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Uode {
            #[doc = "0: Totem pole output."]
            TotemPole = 0,
            #[doc = "1: Open drain output."]
            OpenDrain = 1,
        }
        impl From<Uode> for bool {
            #[inline(always)]
            fn from(variant: Uode) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `UODE` reader - Controls the output mode of the TXD signal. Expects the slave controller to set the TXD signal to Open Drain when Multi-Controller is enabled."]
        pub type UodeR = crate::BitReader<Uode>;
        impl UodeR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Uode {
                match self.bits {
                    false => Uode::TotemPole,
                    true => Uode::OpenDrain,
                }
            }
            #[doc = "Totem pole output."]
            #[inline(always)]
            pub fn is_totem_pole(&self) -> bool {
                *self == Uode::TotemPole
            }
            #[doc = "Open drain output."]
            #[inline(always)]
            pub fn is_open_drain(&self) -> bool {
                *self == Uode::OpenDrain
            }
        }
        #[doc = "Field `UODE` writer - Controls the output mode of the TXD signal. Expects the slave controller to set the TXD signal to Open Drain when Multi-Controller is enabled."]
        pub type UodeW<'a, REG> = crate::BitWriter<'a, REG, Uode>;
        impl<'a, REG> UodeW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Totem pole output."]
            #[inline(always)]
            pub fn totem_pole(self) -> &'a mut crate::W<REG> {
                self.variant(Uode::TotemPole)
            }
            #[doc = "Open drain output."]
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut crate::W<REG> {
                self.variant(Uode::OpenDrain)
            }
        }
        #[doc = "Specifies the Wake Up Bit (WUB) to use when in Multi-Controller System mode.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Twub {
            #[doc = "0: Data frame transfer."]
            DataFrame = 0,
            #[doc = "1: Address (ID) frame transfer."]
            Address = 1,
        }
        impl From<Twub> for bool {
            #[inline(always)]
            fn from(variant: Twub) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `TWUB` reader - Specifies the Wake Up Bit (WUB) to use when in Multi-Controller System mode."]
        pub type TwubR = crate::BitReader<Twub>;
        impl TwubR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Twub {
                match self.bits {
                    false => Twub::DataFrame,
                    true => Twub::Address,
                }
            }
            #[doc = "Data frame transfer."]
            #[inline(always)]
            pub fn is_data_frame(&self) -> bool {
                *self == Twub::DataFrame
            }
            #[doc = "Address (ID) frame transfer."]
            #[inline(always)]
            pub fn is_address(&self) -> bool {
                *self == Twub::Address
            }
        }
        #[doc = "Field `TWUB` writer - Specifies the Wake Up Bit (WUB) to use when in Multi-Controller System mode."]
        pub type TwubW<'a, REG> = crate::BitWriter<'a, REG, Twub>;
        impl<'a, REG> TwubW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Data frame transfer."]
            #[inline(always)]
            pub fn data_frame(self) -> &'a mut crate::W<REG> {
                self.variant(Twub::DataFrame)
            }
            #[doc = "Address (ID) frame transfer."]
            #[inline(always)]
            pub fn address(self) -> &'a mut crate::W<REG> {
                self.variant(Twub::Address)
            }
        }
        #[doc = "Specifies whether to expect address (ID) frames with Wake Up Bits set to 1 or data frames with Wake Up Bits set to 0. Only used when in Multi-Controller System mode.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum Rwub {
            #[doc = "0: Receive data frames."]
            DataFrame = 0,
            #[doc = "1: Receive Address (ID) frames."]
            Address = 1,
        }
        impl From<Rwub> for bool {
            #[inline(always)]
            fn from(variant: Rwub) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `RWUB` reader - Specifies whether to expect address (ID) frames with Wake Up Bits set to 1 or data frames with Wake Up Bits set to 0. Only used when in Multi-Controller System mode."]
        pub type RwubR = crate::BitReader<Rwub>;
        impl RwubR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Rwub {
                match self.bits {
                    false => Rwub::DataFrame,
                    true => Rwub::Address,
                }
            }
            #[doc = "Receive data frames."]
            #[inline(always)]
            pub fn is_data_frame(&self) -> bool {
                *self == Rwub::DataFrame
            }
            #[doc = "Receive Address (ID) frames."]
            #[inline(always)]
            pub fn is_address(&self) -> bool {
                *self == Rwub::Address
            }
        }
        #[doc = "Field `RWUB` writer - Specifies whether to expect address (ID) frames with Wake Up Bits set to 1 or data frames with Wake Up Bits set to 0. Only used when in Multi-Controller System mode."]
        pub type RwubW<'a, REG> = crate::BitWriter<'a, REG, Rwub>;
        impl<'a, REG> RwubW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
        {
            #[doc = "Receive data frames."]
            #[inline(always)]
            pub fn data_frame(self) -> &'a mut crate::W<REG> {
                self.variant(Rwub::DataFrame)
            }
            #[doc = "Receive Address (ID) frames."]
            #[inline(always)]
            pub fn address(self) -> &'a mut crate::W<REG> {
                self.variant(Rwub::Address)
            }
        }
        impl R {
            #[doc = "Bit 0 - The length of each data frame."]
            #[inline(always)]
            pub fn umodelen(&self) -> UmodelenR {
                UmodelenR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Whether to add a TX wake-up bit after data bits."]
            #[inline(always)]
            pub fn umodemc(&self) -> UmodemcR {
                UmodemcR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - How many stop bits to add."]
            #[inline(always)]
            pub fn usbl(&self) -> UsblR {
                UsblR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Enable/disable parity-checking. MUST BE DISABLED when MCENABLE is on."]
            #[inline(always)]
            pub fn upen(&self) -> UpenR {
                UpenR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Odd or even parity."]
            #[inline(always)]
            pub fn ueps(&self) -> UepsR {
                UepsR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 5:6 - Selects the serial transfer clock. The baud rate is equal to the chosen clock frequency divided by 16."]
            #[inline(always)]
            pub fn scs(&self) -> ScsR {
                ScsR::new(((self.bits >> 5) & 3) as u8)
            }
            #[doc = "Bit 8 - Enables RTC-CTS flow control. When high, allows data to be queued for transmission in TX FIFO if CTS is high."]
            #[inline(always)]
            pub fn ufce(&self) -> UfceR {
                UfceR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 13 - Controls the output mode of the TXD signal. Expects the slave controller to set the TXD signal to Open Drain when Multi-Controller is enabled."]
            #[inline(always)]
            pub fn uode(&self) -> UodeR {
                UodeR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Specifies the Wake Up Bit (WUB) to use when in Multi-Controller System mode."]
            #[inline(always)]
            pub fn twub(&self) -> TwubR {
                TwubR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Specifies whether to expect address (ID) frames with Wake Up Bits set to 1 or data frames with Wake Up Bits set to 0. Only used when in Multi-Controller System mode."]
            #[inline(always)]
            pub fn rwub(&self) -> RwubR {
                RwubR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - The length of each data frame."]
            #[inline(always)]
            pub fn umodelen(&mut self) -> UmodelenW<SioLcrSpec> {
                UmodelenW::new(self, 0)
            }
            #[doc = "Bit 1 - Whether to add a TX wake-up bit after data bits."]
            #[inline(always)]
            pub fn umodemc(&mut self) -> UmodemcW<SioLcrSpec> {
                UmodemcW::new(self, 1)
            }
            #[doc = "Bit 2 - How many stop bits to add."]
            #[inline(always)]
            pub fn usbl(&mut self) -> UsblW<SioLcrSpec> {
                UsblW::new(self, 2)
            }
            #[doc = "Bit 3 - Enable/disable parity-checking. MUST BE DISABLED when MCENABLE is on."]
            #[inline(always)]
            pub fn upen(&mut self) -> UpenW<SioLcrSpec> {
                UpenW::new(self, 3)
            }
            #[doc = "Bit 4 - Odd or even parity."]
            #[inline(always)]
            pub fn ueps(&mut self) -> UepsW<SioLcrSpec> {
                UepsW::new(self, 4)
            }
            #[doc = "Bits 5:6 - Selects the serial transfer clock. The baud rate is equal to the chosen clock frequency divided by 16."]
            #[inline(always)]
            pub fn scs(&mut self) -> ScsW<SioLcrSpec> {
                ScsW::new(self, 5)
            }
            #[doc = "Bit 8 - Enables RTC-CTS flow control. When high, allows data to be queued for transmission in TX FIFO if CTS is high."]
            #[inline(always)]
            pub fn ufce(&mut self) -> UfceW<SioLcrSpec> {
                UfceW::new(self, 8)
            }
            #[doc = "Bit 13 - Controls the output mode of the TXD signal. Expects the slave controller to set the TXD signal to Open Drain when Multi-Controller is enabled."]
            #[inline(always)]
            pub fn uode(&mut self) -> UodeW<SioLcrSpec> {
                UodeW::new(self, 13)
            }
            #[doc = "Bit 14 - Specifies the Wake Up Bit (WUB) to use when in Multi-Controller System mode."]
            #[inline(always)]
            pub fn twub(&mut self) -> TwubW<SioLcrSpec> {
                TwubW::new(self, 14)
            }
            #[doc = "Bit 15 - Specifies whether to expect address (ID) frames with Wake Up Bits set to 1 or data frames with Wake Up Bits set to 0. Only used when in Multi-Controller System mode."]
            #[inline(always)]
            pub fn rwub(&mut self) -> RwubW<SioLcrSpec> {
                RwubW::new(self, 15)
            }
        }
        #[doc = "Line Control Register. Controls the serial data format. Matches the same register found in the TMPR4937 CPU.\n\nYou can [`read`](crate::Reg::read) this register and get [`sio_lcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sio_lcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SioLcrSpec;
        impl crate::RegisterSpec for SioLcrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sio_lcr::R`](R) reader structure"]
        impl crate::Readable for SioLcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`sio_lcr::W`](W) writer structure"]
        impl crate::Writable for SioLcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SIO_LCR to value 0"]
        impl crate::Resettable for SioLcrSpec {}
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "TIMER"]
    pub timer: Timer,
    #[doc = "IPU"]
    pub ipu: Ipu,
    #[doc = "GIF"]
    pub gif: Gif,
    #[doc = "GS_PRIVILEGED"]
    pub gs_privileged: GsPrivileged,
    #[doc = "VIF"]
    pub vif: Vif,
    #[doc = "DMAC"]
    pub dmac: Dmac,
    #[doc = "INTC"]
    pub intc: Intc,
    #[doc = "SIO"]
    pub sio: Sio,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            timer: Timer::steal(),
            ipu: Ipu::steal(),
            gif: Gif::steal(),
            gs_privileged: GsPrivileged::steal(),
            vif: Vif::steal(),
            dmac: Dmac::steal(),
            intc: Intc::steal(),
            sio: Sio::steal(),
        }
    }
}
