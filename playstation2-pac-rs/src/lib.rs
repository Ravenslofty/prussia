#![doc = "Peripheral access API for PLAYSTATION2 microcontrollers (generated using svd2rust v0.36.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.36.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 0;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[doc = "Programmable Timers. See EE User's Manual, Chapter 4."]
pub type Timer = crate::Periph<timer::RegisterBlock, 0xb000_0000>;
impl core::fmt::Debug for Timer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer").finish()
    }
}
#[doc = "Programmable Timers. See EE User's Manual, Chapter 4."]
pub mod timer;
#[doc = "Image Data Processor. See EE User's Manual, Chapter 8."]
pub type Ipu = crate::Periph<ipu::RegisterBlock, 0xb000_2000>;
impl core::fmt::Debug for Ipu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ipu").finish()
    }
}
#[doc = "Image Data Processor. See EE User's Manual, Chapter 8."]
pub mod ipu;
#[doc = "GS Interface. See EE User's Manual, Chapter 7."]
pub type Gif = crate::Periph<gif::RegisterBlock, 0xb000_3000>;
impl core::fmt::Debug for Gif {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gif").finish()
    }
}
#[doc = "GS Interface. See EE User's Manual, Chapter 7."]
pub mod gif;
#[doc = "Privileged GS registers. Some are accessible via mapped EE addressed, but some require the GIF for accessing the relevant registers on the GS."]
pub type GsPrivileged = crate::Periph<gs_privileged::RegisterBlock, 0xb200_0000>;
impl core::fmt::Debug for GsPrivileged {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GsPrivileged").finish()
    }
}
#[doc = "Privileged GS registers. Some are accessible via mapped EE addressed, but some require the GIF for accessing the relevant registers on the GS."]
pub mod gs_privileged;
#[doc = "VU Interface. See EE User's Manual, Chapter 6."]
pub type Vif = crate::Periph<vif::RegisterBlock, 0xb000_3800>;
impl core::fmt::Debug for Vif {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vif").finish()
    }
}
#[doc = "VU Interface. See EE User's Manual, Chapter 6."]
pub mod vif;
#[doc = "DMA Controller. See EE User's Manual, Chapter 5."]
pub type Dmac = crate::Periph<dmac::RegisterBlock, 0xb000_8000>;
impl core::fmt::Debug for Dmac {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmac").finish()
    }
}
#[doc = "DMA Controller. See EE User's Manual, Chapter 5."]
pub mod dmac;
#[doc = "Interrupt Controller. See EE User's Manual, Chapter 3."]
pub type Intc = crate::Periph<intc::RegisterBlock, 0xb000_f000>;
impl core::fmt::Debug for Intc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Intc").finish()
    }
}
#[doc = "Interrupt Controller. See EE User's Manual, Chapter 3."]
pub mod intc;
#[doc = "Serial Input/Output"]
pub type Sio = crate::Periph<sio::RegisterBlock, 0xb000_f100>;
impl core::fmt::Debug for Sio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sio").finish()
    }
}
#[doc = "Serial Input/Output"]
pub mod sio;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "TIMER"]
    pub timer: Timer,
    #[doc = "IPU"]
    pub ipu: Ipu,
    #[doc = "GIF"]
    pub gif: Gif,
    #[doc = "GS_PRIVILEGED"]
    pub gs_privileged: GsPrivileged,
    #[doc = "VIF"]
    pub vif: Vif,
    #[doc = "DMAC"]
    pub dmac: Dmac,
    #[doc = "INTC"]
    pub intc: Intc,
    #[doc = "SIO"]
    pub sio: Sio,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            timer: Timer::steal(),
            ipu: Ipu::steal(),
            gif: Gif::steal(),
            gs_privileged: GsPrivileged::steal(),
            vif: Vif::steal(),
            dmac: Dmac::steal(),
            intc: Intc::steal(),
            sio: Sio::steal(),
        }
    }
}
